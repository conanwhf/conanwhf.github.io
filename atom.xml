<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Linux开发和七七八八]]></title>
  <subtitle><![CDATA[Conan学习笔记]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://conanwhf.github.io/"/>
  <updated>2018-02-13T03:35:59.271Z</updated>
  <id>http://conanwhf.github.io/</id>
  
  <author>
    <name><![CDATA[Conan Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[十五分种学会用matplotlib绘制图表]]></title>
    <link href="http://conanwhf.github.io/2018/02/12/DrawByMatplotlib/"/>
    <id>http://conanwhf.github.io/2018/02/12/DrawByMatplotlib/</id>
    <published>2018-02-12T09:31:26.000Z</published>
    <updated>2018-02-13T03:35:59.271Z</updated>
    <content type="html"><![CDATA[<p>上周做了个股指的回顾，想用Python画图看看最近20年不同指数的变化情况，需要用到常用的matplotlib库来绘制折线图。整个plot函数的功能和参数很多，但作为初学者，我只用到了一些基本和常用的功能，想必普通画图也已经够了。<br> </p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2018/02/12/DrawByMatplotlib/</p><p>访问原文「<a href='http://conanwhf.github.io/2018/02/12/DrawByMatplotlib/'>十五分种学会用matplotlib绘制图表</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
 </p>
<h1 id="u57FA_u7840"><a href="#u57FA_u7840" class="headerlink" title="基础"></a>基础</h1><p>绘制折线图，实际上是根据x,y两个数组的数据来绘制一组数据点，并将它们用直线连接起来。而将每个点想象在一个直角坐标系中，x,y两个数组中的数据，也就是每个点的xy坐标。所以，在绘制函数中，要求x,y的数目相等，否则便会报错：<code>ValueError: x and y must have same first dimension</code>。<br>下面是一个最简单的绘制折线的例子，如果你用过Matlab的话一定感到非常熟悉（绘制结果略）：</p>
<pre><code>#加载库
import matplotlib.pyplot as plt
#定义数据
x=[1,2,3,4,5]
y=[1,4,9,16,25]

fig,ax = plt.subplots()     #初始化
plt.plot(x, y)              #绘制函数
plt.show()                  #显示
</code></pre> <a id="more"></a> 
<p>其中plot()函数是最重要的一步，它也同样可以有很多参数，包括颜色，函数的标识名称，绘制点的样式等等，这些参数常用的部分大致如下：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>连接线型</th>
<th>标记</th>
<th>数据点型</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>实线（默认）</td>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>–</td>
<td>虚线</td>
<td>o</td>
<td>圆圈</td>
</tr>
<tr>
<td>:</td>
<td>点线</td>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>-.</td>
<td>点横线</td>
<td>.</td>
<td>实心点</td>
</tr>
<tr>
<td><strong>标记</strong></td>
<td><strong>颜色</strong></td>
<td>x</td>
<td>叉</td>
</tr>
<tr>
<td>r</td>
<td>红</td>
<td>s</td>
<td>正方形</td>
</tr>
<tr>
<td>g</td>
<td>绿</td>
<td>d</td>
<td>钻石</td>
</tr>
<tr>
<td>b</td>
<td>蓝</td>
<td>^</td>
<td>上三角</td>
</tr>
<tr>
<td>c</td>
<td>蓝绿</td>
<td>v</td>
<td>下三角</td>
</tr>
<tr>
<td>m</td>
<td>紫红</td>
<td>\&lt;</td>
<td>左三角</td>
</tr>
<tr>
<td>y</td>
<td>黄</td>
<td>></td>
<td>右三角</td>
</tr>
<tr>
<td>k</td>
<td>黑</td>
<td>p</td>
<td>正五角形</td>
</tr>
<tr>
<td>w</td>
<td>白</td>
<td>h</td>
<td>正六角形</td>
</tr>
</tbody>
</table>
<p>除了对绘制的折线本身的样式定义，还有对于x,y轴和图例的定义。而在实际中，由于我们通常只是想绘制某个函数或者一组数据的图像，x轴并不那么重要，常常简化为<code>range(0,n)</code>，用得更多的是对y轴的定义：<br><code>ax.set_ylim(min, max)</code>以及<code>set_yticks(range(min, max, step))</code>。下面是一个更常用的定制版折线图绘制：</p>
<pre><code>y=[1,4,9,16,25]

fig,ax = plt.subplots()
plt.title(&quot;This is a plot image&quot;)       #图像名称
ax.set_ylim(0, 30, 2)                   # y坐标轴的范围  
ax.set_yticks(range(0, 30, 2))      # y坐标轴的刻度
#绘制折线，其中数据点为实心正五边形，用虚线连接，颜色为蓝色
plt.plot(range(0,5), y, &quot;p:&quot;,label=&quot;sample&quot;, color=&apos;b&apos;)
plt.legend(loc=&apos;best&apos;)                  # 设定图例的位置
plt.grid(True)                          # 打开网格
plt.show()
</code></pre><p>绘制后的结果如下图。其他更多高级的用法随便搜索一下就能找到无数详细介绍，我就不啰嗦了。<br><img src="https://whf.d.pr/nlyXhY+" alt=""></p>
<h1 id="u591A_u6761_u6298_u7EBF_u7684_u7ED8_u5236"><a href="#u591A_u6761_u6298_u7EBF_u7684_u7ED8_u5236" class="headerlink" title="多条折线的绘制"></a>多条折线的绘制</h1><p>有时候我们需要绘制多条折线，用于将不同的函数放在一起比较，会有各种不同的需求。首先定义一下基本概念：下文所谓的“图表”，就是一幅折线图，或者说是一个“子图”；而”窗口”，就是运行之后弹出来的一个window，带有最小化、关闭等按钮。运行语句<code>fig,ax = plt.subplots()</code>后，拿到的两个变量fig, ax实际上就是指初始化的窗口和图像。</p>
<h2 id="u5728_u540C_u4E00_u4E2A_u7A97_u53E3_u7ED8_u5236_u51E0_u4E2A_u4E0D_u540C_u7684_u56FE_u8868"><a href="#u5728_u540C_u4E00_u4E2A_u7A97_u53E3_u7ED8_u5236_u51E0_u4E2A_u4E0D_u540C_u7684_u56FE_u8868" class="headerlink" title="在同一个窗口绘制几个不同的图表"></a>在同一个窗口绘制几个不同的图表</h2><p>如果我们需要在同一个窗口中绘制几个不同的图，即将几幅图并排显示在一块儿，可以使用<code>add_subplot()</code>函数来做到。<code>add_subplot(a,b,c)</code>定义了一个新的图表，它首先将窗口分割成a*b的网格，然后返回第c格（按照从上到下、从左至右的顺序，从1数起）。下面这个例子能比较清晰地看到如何来绘制好几个折线图。</p>
<pre><code>import matplotlib.pyplot as plt
#生成数据
y1=[1,4,9,16,25]
y2=[2,3,4,5,6]
y4=[12,10,1,7,-3]
#在同一个fig中初始化几个不同的图
fig = plt.figure()
ax1 = fig.add_subplot(2,2,1)
#ax2 = fig.add_subplot(2,2,2)
ax3 = fig.add_subplot(2,2,3)
ax4 = fig.add_subplot(2,2,4)
#依次在几个图表上绘制线条
ax1.plot(range(0,5), y1, &quot;p:&quot;,label=&quot;ax1&quot;, color=&apos;r&apos;)
ax1.legend(loc=&apos;best&apos;)
ax1.grid(True)
ax4.plot(range(0,5), y4, &quot;o-&quot;,label=&quot;y4&quot;, color=&apos;k&apos;)
# 不指定目的图表，则绘制在最后一个初始化的窗口中
plt.plot(range(0,5), y2, &quot;o-&quot;,label=&quot;y2&quot;, color=&apos;b&apos;)

plt.show()
</code></pre><p>画出的图像：<br><img src="https://whf.d.pr/aXw2r1+" alt=""><br>从图像对照代码我们可以知道：</p>
<ol>
<li>当使用ax.plot()时，绘制会指定在某个图表中</li>
<li>如果不初始化网格内的某个图(add_subplot)，那一部份会自动留白（见ax2部分）</li>
<li>如果使用add_subplot初始化了一个图表却没有画线，则会只有一个自动生成的坐标系和刻度</li>
<li>如果使用plt.plot/legend等实际上是配置某个图表而不是整个窗口的函数，那么系统会自动使用最后一个<strong>初始化</strong>的图表，在上面的例子中是ax4。</li>
</ol>
<h2 id="u5728_u540C_u4E00_u5F20_u56FE_u8868_u4E0A_u753B_u51E0_u6761_u4E0D_u540C_u7684_u6298_u7EBF"><a href="#u5728_u540C_u4E00_u5F20_u56FE_u8868_u4E0A_u753B_u51E0_u6761_u4E0D_u540C_u7684_u6298_u7EBF" class="headerlink" title="在同一张图表上画几条不同的折线"></a>在同一张图表上画几条不同的折线</h2><p>有时候需要在同一个图表上画几条不同的折线，也是很简单，直接重复绘制就可以了：</p>
<pre><code>import matplotlib.pyplot as plt
#生成待绘制数据
data=range(-20,20)
A = list(map(lambda x:x**2, data))
B = list(map(lambda x:x**2+100, data))
C = list(map(lambda x:(x+5)**2, data))
#初始化窗口和图表
fig,ax = plt.subplots()
#绘制A，B，C三条线
ax.plot(data, A, label=&quot;y=x^2&quot;, color=&apos;r&apos;)
ax.plot(data, B, label=&quot;y=x^2+10&quot;, color=&apos;g&apos;)
ax.plot(data, C, label=&quot;y=(x+1)^2&quot;, color=&apos;b&apos;)
plt.legend(loc=&apos;best&apos;)
plt.show()
</code></pre><p>这样得到的结果是：<br><img src="https://whf.d.pr/dtabEv+" alt=""></p>
<h2 id="u5728_u4E0D_u540C_u7684_u7A97_u53E3_u7ED8_u5236_u56FE_u8868"><a href="#u5728_u4E0D_u540C_u7684_u7A97_u53E3_u7ED8_u5236_u56FE_u8868" class="headerlink" title="在不同的窗口绘制图表"></a>在不同的窗口绘制图表</h2><p>接下来改讨论下在不同的窗口绘制图表了。有了之前的经验，我们很快能知道，这种方式的不同就是将折线画在不同的fig上。但要注意的是，在前一个窗口绘制结束时，需要调用plt.close(0)，然后在最后调用plt.show()来显示所有图像。还是使用之前的数据为例，这次的绘制部分稍有不同：</p>
<pre><code>#首次初始化，并绘制两条折线
fig,ax = plt.subplots()
ax.plot(data, A, label=&quot;y=x^2&quot;, color=&apos;r&apos;)
ax.plot(data, B, label=&quot;y=x^2+100&quot;, color=&apos;g&apos;)
#结束当前窗口绘制
plt.close(0)
#重新初始化窗口和图表，并再次绘制
fig,ax = plt.subplots()
ax.plot(data, C, label=&quot;y=(x+5)^2&quot;, color=&apos;b&apos;)
#结束绘制，显示所有
plt.show()
</code></pre><p>跑完程序得到了两个窗口：<br><img src="https://whf.d.pr/DEP4ZQ+" alt=""><br>可以看到窗口的标题上分别标记为Figure1和Figure2。如果在程序中不是用plt.close(0)而是直接使用plt.show()，第一个窗口会绘制完毕并弹出，然而整个进程会阻塞，直到你手动关闭Figure1，才会继续跑后面的内容。</p>
<h2 id="u5728_u540C_u4E00_u5F20_u56FE_u4E0A_u7ED8_u5236_u957F_u5EA6_u4E0D_u540C_u7684_u51E0_u6761_u6298_u7EBF"><a href="#u5728_u540C_u4E00_u5F20_u56FE_u4E0A_u7ED8_u5236_u957F_u5EA6_u4E0D_u540C_u7684_u51E0_u6761_u6298_u7EBF" class="headerlink" title="在同一张图上绘制长度不同的几条折线"></a>在同一张图上绘制长度不同的几条折线</h2><p>关于图表和窗口的问题讨论完了，但我还遇到了一个需求：如果几条折线的数据长度不同怎么办？例如统计年度数据，有的项目从2000年到2009年，有的却从2001到2007？之前我们绘制的数据长度都是一样的，plot()函数本身也要求x,y的长度一致，不然拒绝绘制。开始我采用将数据不足的部分补0的方法，但效果还是不完美，后来发现实际上这个问题的解决方案也很简单：只要在每个plot()函数中指定x的范围，让其和传入的y数据个数相同就可以了。</p>
<pre><code>import matplotlib.pyplot as plt
A=[1,2,3,4,5]
B=[5,6,3,4,8,1,-2]
C=[0.1, 0.4, 10]
x=range(2001,2010)
fig,ax = plt.subplots()
ax.plot(x[0:len(A)], A, label=&quot;A&quot;, color=&apos;r&apos;)
ax.plot(x[0:len(B)], B, label=&quot;B&quot;, color=&apos;g&apos;)
ax.plot(x[0:len(C)], C, label=&quot;C&quot;, color=&apos;b&apos;)
plt.show()
</code></pre><p>于是，在图上可以看到长度不同的三条折线：<br><img src="https://whf.d.pr/SSoFoW+" alt=""></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>为了自己使用方便，我写了一个函数，用来在同一个图中绘制一组折线图。支持可变折线数目，支持不同数据长度，自动变化折线颜色，支持绘制多组图表，也可以作为这篇文章的一个相对完整的Demo。源码地址：<a href="https://github.com/conanwhf/PythonLab/blob/master/Lab03.py" target="_blank" rel="external">Demo</a>，自取。</p>
<h1 id="u4E3E_u4E00_u53CD_u4E09"><a href="#u4E3E_u4E00_u53CD_u4E09" class="headerlink" title="举一反三"></a>举一反三</h1><p>说了这么半天，图表、图表，光说折线图了，其他的图呢？其实其他几种图表的绘制本质上是一样的，完全可以自己举一反三。例如把plot()替换成别的函数：</p>
<pre><code>ax1.plot(range(0,5), y, color=&apos;r&apos;)
ax2.scatter(range(0,5), y, color=&apos;k&apos;)
ax3.bar(range(0,5), y, color=&apos;b&apos;)
ax4.barh(range(0,5), y, color=&apos;y&apos;)
</code></pre><p>画出的图像如下图。同一组数据，几个不同的绘制函数分别画了折线图、散点图、柱状图、条状图四种样式。当然，他们的高级参数还是有些许不同的，在实际使用中根据需要再查细节即可。<br><img src="https://whf.d.pr/kTWNwb+" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上周做了个股指的回顾，想用Python画图看看最近20年不同指数的变化情况，需要用到常用的matplotlib库来绘制折线图。整个plot函数的功能和参数很多，但作为初学者，我只用到了一些基本和常用的功能，想必普通画图也已经够了。<br> <!-- indicate-the-source --> </p>
<h1 id="u57FA_u7840"><a href="#u57FA_u7840" class="headerlink" title="基础"></a>基础</h1><p>绘制折线图，实际上是根据x,y两个数组的数据来绘制一组数据点，并将它们用直线连接起来。而将每个点想象在一个直角坐标系中，x,y两个数组中的数据，也就是每个点的xy坐标。所以，在绘制函数中，要求x,y的数目相等，否则便会报错：<code>ValueError: x and y must have same first dimension</code>。<br>下面是一个最简单的绘制折线的例子，如果你用过Matlab的话一定感到非常熟悉（绘制结果略）：</p>
<pre><code>#加载库
import matplotlib.pyplot as plt
#定义数据
x=[1,2,3,4,5]
y=[1,4,9,16,25]

fig,ax = plt.subplots()     #初始化
plt.plot(x, y)              #绘制函数
plt.show()                  #显示
</code></pre>]]>
    
    </summary>
    
      <category term="Matplotlib" scheme="http://conanwhf.github.io/tags/Matplotlib/"/>
    
      <category term="Python" scheme="http://conanwhf.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么放弃学习iOS开发]]></title>
    <link href="http://conanwhf.github.io/2017/12/31/WhyIDropTheApple/"/>
    <id>http://conanwhf.github.io/2017/12/31/WhyIDropTheApple/</id>
    <published>2017-12-31T09:25:39.000Z</published>
    <updated>2018-02-05T10:19:45.608Z</updated>
    <content type="html"><![CDATA[<p>首先是结论：我决定放弃学习iOS开发。在这两年的时间里，我学习了swift语言，学习了简单的iOS应用的一些内容，包括各种控件、界面元素、动画、操作的实现等等。我练习了一些swift语言本身的Demo，并用纯swift写了一些小的app，至今纯属练手，质量和创意都还达不到上架的要求。事实上从第二年开始我就比较少写iOS代码了，但即使是一年这个进度也是很差的了。<br>一直自我评价是个学习速度比较快的人，大学里花很短的时间完成过不少使用不同语言的小项目，但也许是老了学习能力变差了，这次的iOS学习却是让我感觉最困难的。一开始我就碰到了swift语言不稳定的问题，我开始的时候正是1.0到2.0的转换时期，很多用法、API的变化让我搜索问题的时候一头雾水，因为写文章的人并不会特意说明自己使用的版本，对于新人来说，看着1.0的教程，用着2.0的编译器确实有点难受，好在这也不是什么特别大的问题，克服克服就过了。但是后来的3.0、4.0就有点夸张了，我是那种Makefile里面要写-O3还绝对不允许自己代码编译的时候出现任何warning的人，看着更新一下Xcode再打开自己的项目一下子出来几百个红黄感叹号，我真的要晕过去了！！！ </p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/12/31/WhyIDropTheApple/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/12/31/WhyIDropTheApple/'>我为什么放弃学习iOS开发</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>真正的问题出在开始学写应用了之后。 <a id="more"></a>我尝试写一点小的项目，结果发现iOS的开发原来是如此的复杂—各种API和依附其上的潜规则实在是太多了！即使是现在正在吐槽的我，一想到那些巨量的库和函数、属性、各种用法，我就开始脑袋放空半天无从说起。iOS自己是一个精密的系统，开放的功能虽然不全但是用起来绕口，有点不符合日常思维的感觉，需要开发者有很好的iOS的思维。另外它对应用的要求也非常高，动辄出现各种细枝末节的问题，还有很多鸡零狗碎的数据，都需要你花费不少的精力。比如什么任务栏高度是多少像素，如何避免在retina屏幕上使用双倍像素的图片，还有什么底部自动出现的一像素的线条之类，更讨厌的是你想去搜索一下问题的答案，却会见到各种版本的不同处理方式，iOS7，8，9，10，11，12……一路走来的iOS，其多变性让大佬惊喜、让新手哭泣。<br>在学习的过程中，我还在github维护了一个收集swift版iOS开发资源和教程的小项目，订阅了一些相关的信息来源，阅读之后整理在上面。随着读到的东西越来越多，内容越来越广泛，我的心态也越来越崩溃：我离一个成熟的iOS开发者还差了十万八千里。事实上我还在家solo办公接一些Linux系统开发的工作，忙碌起来业余学习的时间便捉衿见肘，更让我感到成功之日遥遥无期。让我首次想到放弃的时刻，是发布了swift3.0之后。当时我对着Xcode发了半天呆，恨不得立刻删掉应用再也不碰什么鬼swift了。后来虽然硬着头皮花了很多时间把swift的语法和函数又过了一遍，但“不能半途而废”和“不要过于在意沉没成本”的两个敌对的想法一直在脑子里打架，直到iPhoneX的问世。看着被iPhoneX+iOS12+Xcode9的适配折磨到奄奄一息还拼命发着教程的各路英雄豪杰，我实在忍不了了：去你的iOS开发！<br>怒摔键盘之后，我冷静地思考了一下自己学习iOS开发的初衷，看看时至今日这些原因还是否存在：</p>
<ol>
<li>手机端应用的流行是未来趋势，想学习。手机在日常生活中扮演的重要地位不言而喻，这个趋势依然存在，然而iOS开发的热度明显是在下降。这其中我认为有两方面的原因：一是Apple和Google阵营在手机上的实力差距大不如之前的悬殊，甚至如今谁更厉害大家都是各有所见；二是随着Web端的兴盛，基于系统的应用有衰退的趋势，将来如果系统能全面支持基于H5的应用，那么纯应用的低位便岌岌可危了。</li>
<li>想学习一门新的语言。开始的时候，我是很喜欢Swift的，对于用了多年C的我来说，不管是语法上还是思想上都有很多高级特性，让人很有尝试的欲望。虽然我对于除C以外的很多语言都略懂皮毛，但swift给我的感觉是能够当作C以外的第二语言，特别是开源这个动作很让人对它的未来有所期待。但是它一次次的迭代升级、糟糕的稳定性，繁琐的语法细节，让我最终不胜其烦。与此同时，由于工作需要接触到了python，其简单易用的程度和海量的公开库都让我惊喜连连，更别提它对各种系统的兼容程度了！虽然也同样有很多让人无从下口的槽点，跟C的严谨度更是不可同日而语，但瑕不掩瑜，我已经把python当作自己的日常语言，写个程序算点东西、画个图分析数据什么的，大大提高效率。一次书写，包括UI全平台可用，我所有的终端：Mac、 Windows7-10、Ubuntu、远程服务器Cento、甚至连树莓派都能一行不用改，简直太美好了！</li>
<li>Apple的软件开发收入不错。这个就……我不知道是不是一开始我就误会了，当初想用业余时间学点新东西，如果想换份工作选择也大点。但是现在看起来，iOS开发者的市场，在一大波培训班学员的冲击下，已经大不如前，反而Linux开发一直都还算稳定。当个独立开发者，我感觉需要投入全部的时间和精力，光业余玩票是玩不起来的，除非本人特别聪明。<br>目前Apple自身似乎也有日薄西山的趋势，近两年不论是软件还是硬件都频出差错。早些年讨论iOS应用限免或者推荐之类的话题还很有热度，现在好像都进入了瓶颈期或者说平淡期。就我自己而言，从iPhone4就开始每年紧跟时代换手机，这次iPhoneX却不知为何一点欲望也没有。MacbookPro用了三年也不想换，原本很渴望MacPro更新产品线就买，结果出来了之后内心毫无波动……<br>回想一下自己的失败，当然最大的原因是自己不够聪明不够努力，以半吊子的心态去玩玩，然后发现果然玩不转。现在看来，选择从swift入手是一个错误的决定，学习用一个不稳定的语言去写一个不稳定的系统环境（这里的不稳定是指API）上的应用，实在是有点为难自己了。加上大多数教程和资料其实都不是基于swift而是OC，这个难度就更大一点。另外一方面是我的学习方法不系统，对于这种庞大的内容来说是完全不能够适应的。我是一个在编程学习上习惯以结果为导向的码农，不管是新语言还是新功能，需要学什么就直接去写，不会的地方再查资料，写着写着自然就学会了。这种方式一直以来都比较奏效，但在iOS学习的过程中，变化因素比较多，系统本身也很复杂，常常发现不是自己想的那样，为了完成一个功能，从一个切入点能延伸到好几个别的地方，结果把自己搞晕了。<br>不多谈了，总之我决定结束自己的iOS开发学习，中止目前每月进行的开发tips发布，同时这个资源收集项目<a href="https://github.com/conanwhf/ResourceDoc" title="ResourceDoc" target="_blank" rel="external">ResourceDoc</a>也停止更新。以上！</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先是结论：我决定放弃学习iOS开发。在这两年的时间里，我学习了swift语言，学习了简单的iOS应用的一些内容，包括各种控件、界面元素、动画、操作的实现等等。我练习了一些swift语言本身的Demo，并用纯swift写了一些小的app，至今纯属练手，质量和创意都还达不到上架的要求。事实上从第二年开始我就比较少写iOS代码了，但即使是一年这个进度也是很差的了。<br>一直自我评价是个学习速度比较快的人，大学里花很短的时间完成过不少使用不同语言的小项目，但也许是老了学习能力变差了，这次的iOS学习却是让我感觉最困难的。一开始我就碰到了swift语言不稳定的问题，我开始的时候正是1.0到2.0的转换时期，很多用法、API的变化让我搜索问题的时候一头雾水，因为写文章的人并不会特意说明自己使用的版本，对于新人来说，看着1.0的教程，用着2.0的编译器确实有点难受，好在这也不是什么特别大的问题，克服克服就过了。但是后来的3.0、4.0就有点夸张了，我是那种Makefile里面要写-O3还绝对不允许自己代码编译的时候出现任何warning的人，看着更新一下Xcode再打开自己的项目一下子出来几百个红黄感叹号，我真的要晕过去了！！！ <!-- indicate-the-source --><br>真正的问题出在开始学写应用了之后。]]>
    
    </summary>
    
      <category term="iOS" scheme="http://conanwhf.github.io/tags/iOS/"/>
    
      <category term="iOS开发杂项" scheme="http://conanwhf.github.io/categories/iOS%E5%BC%80%E5%8F%91%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2017-12]]></title>
    <link href="http://conanwhf.github.io/2017/12/31/ReadingList2017-12/"/>
    <id>http://conanwhf.github.io/2017/12/31/ReadingList2017-12/</id>
    <published>2017-12-31T02:36:54.000Z</published>
    <updated>2018-02-12T03:52:10.833Z</updated>
    <content type="html"><![CDATA[<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>名侦探柯南漫画</li>
<li>Pocket</li>
</ol>
<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2><ol>
<li>机器学习实践</li>
</ol>
<h2 id="u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0810-12_u6708_uFF09_33-75"><a href="#u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0810-12_u6708_uFF09_33-75" class="headerlink" title="买的正版非免费书（10-12月）             33.75"></a>买的正版非免费书（10-12月）             <strong>33.75</strong></h2><ol>
<li>面向机器智能的TensorFlow实践 <strong>12.50</strong></li>
<li>算法竞赛入门经典——训练指南 <strong>10.02</strong></li>
<li>算法竞赛入门经典（第2版）   <strong>4.99</strong></li>
<li>Python金融实战 (异步图书)   <strong>21.22</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>兴奋万分地薅羊毛！某天逛亚马逊， <a id="more"></a>看到有“科技好书-下单五折”的活动，里面好像有基本不错，就打开网页浏览一下，顺便看到有另外一个活动：电子工业出版社的部分书，下单五折。再仔细看看，这两个活动的内容有些书是重复的，点进去一看，果然是同时参加两个活动……确实有想买的又同时参加两个活动的书，心里暗爽：技术类书籍一般折扣不多，这次可以25折拿下！一结帐，我惊呆了：免费！亚马逊良心企业啊！两个五折的结果是免费？！我简直兴奋得不行，继某次不知道什么活动开心地狂薅86本之后，又一次机会来了！！当然，激动之下，我也没有把所有的免费都拿下，毕竟有的烂书光是放在自己的库里都觉得碍眼。比较好的有：</p>
<ul>
<li>Web信息架构:设计大型网站(第3版) </li>
<li>有效需求分析 </li>
<li>机器学习算法原理与编程实践 </li>
<li>SEO深度解析:全面挖掘搜索引擎优化的核心秘密(第2版)(改版) </li>
<li>大象无形：虚幻引擎程序设计浅析 </li>
<li>Swift进阶 </li>
<li>Android移动性能实战 </li>
<li>Python 3面向对象编程 </li>
<li>数据恢复技术深度揭秘(第二版) </li>
<li>深入理解并行编程 </li>
<li>跨境电商与国际物流——机遇、模式及运作 </li>
<li>Python Web开发实战 </li>
<li>啊哈C语言！逻辑的挑战（修订版） </li>
<li>安全简史——从隐私保护到量子密码 </li>
<li>大数据智能——互联网时代的机器学习和自然语言处理技术 </li>
<li>自己动手设计物联网 </li>
<li>NLP汉语自然语言处理原理与实践 </li>
<li>网络爬虫全解析——技术、原理与实践 </li>
<li>白帽子讲Web扫描 (安全技术大系) </li>
<li>Python机器学习算法 </li>
<li>MATLAB计算机视觉与深度学习实战<br>多数是可以拿来当参考书翻翻，不必字字句句阅读的。嗯……很满意！</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>名侦探柯南漫画</li>
<li>Pocket</li>
</ol>
<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2><ol>
<li>机器学习实践</li>
</ol>
<h2 id="u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0810-12_u6708_uFF09_33-75"><a href="#u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0810-12_u6708_uFF09_33-75" class="headerlink" title="买的正版非免费书（10-12月）             33.75"></a>买的正版非免费书（10-12月）             <strong>33.75</strong></h2><ol>
<li>面向机器智能的TensorFlow实践 <strong>12.50</strong></li>
<li>算法竞赛入门经典——训练指南 <strong>10.02</strong></li>
<li>算法竞赛入门经典（第2版）   <strong>4.99</strong></li>
<li>Python金融实战 (异步图书)   <strong>21.22</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>兴奋万分地薅羊毛！某天逛亚马逊，]]>
    
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.github.io/tags/BookList/"/>
    
      <category term="Reading" scheme="http://conanwhf.github.io/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2017年11月]]></title>
    <link href="http://conanwhf.github.io/2017/12/01/Tips201711/"/>
    <id>http://conanwhf.github.io/2017/12/01/Tips201711/</id>
    <published>2017-12-01T09:25:39.000Z</published>
    <updated>2017-12-07T09:04:32.064Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>禁止WKWebView的左右弹性属性：让webView的scrollView不能左右滑动即可，也就是让webView的内容一直水平居中。<br>self.webView.scrollView.delegate = self;<ul>
<li>(void)scrollViewDidScroll:(UIScrollView *)scrollView{<br>  // 让webview的内容一直居中显示<br>  scrollView.contentOffset = CGPointMake((scrollView.contentSize.width - screenWidth) / 2, scrollView.contentOffset.y);<br>}</li>
</ul>
</li>
<li>使用UIWebView装载一个网页后，可能需要提取其内的信息，比较好的方法是使用JavaScript。方法UIWebView.stringByEvaluatingJavaScript可以执行一个脚本。</li>
<li>xcode9打包版本只能是8.2及以下版本,或者9.0及更高版本；xcode9不支持8.3和8.4版本；xcode9新打包要在构建版本的时候加入1024*1024 AppSore icon</li>
<li>tableView在iOS11默认使用Self-Sizing，tableView的estimatedRowHeight、estimatedSectionHeaderHeight、estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension</li>
<li>模拟器网速调整： 限制时输入下面两行，根据需要修改下面的数字：  <a id="more"></a><br>  <code>sudo ipfw pipe 1 config bw 350kbit/s plr 0.05 delay 10000ms;</code><br>  <code>sudo ipfw add pipe 1 dst-port http</code><br>  不想再去限制网速是，输入下面的命令行:<br>  <code>sudo ipfw flush</code></li>
<li>reloadRowsAtIndexPaths: withRowAnimation: 在刷新的时候会有cell进入和移出的动画, 所以同时需要至少两个可用的的cell(包括复用池中的cell)，而 reloadData 会先将所有cell都先放到复用池中, 然后再从复用池中取可以复用的cell</li>
<li>UITableViewCell实例上添加子视图，有两种方式：<a href="/">cell addSubview:view</a>或<a href="/">cell.contentView addSubview:view</a>,一般情况下，两种方式没有区别。但是在多选编辑状态，直接添加到cell上的子视图将不会移动，而添加在contentView上的子视图会随着整体右移。所以，推荐使用<a href="/">cell.contentView addSubview:view</a>方式添加子视图</li>
<li>如何便捷地统计代码的行数：<ol>
<li>打开终端；</li>
<li>通过cd命令到达我们的工程文件，这里注意如果要避免统计引用的第三方库的代码量，我们就要进一步进到我们自己写的代码文件中去，一般是一个与工程文件同名的文件；</li>
<li>如果想列出每个文件的行数，输入命令：<br> <code>find.-name&quot;*.m&quot;-or-name&quot;*.h&quot;-or-name&quot;*.xib&quot;-or-name&quot;*.c&quot;|xargswc-l</code></li>
<li>如果想直接列出总代码行数，输入命令：<br> <code>find.-name&quot;*.m&quot;-or-name&quot;*.h&quot;-or-name&quot;*.xib&quot;-or-name&quot;*.c&quot;|xargsgrep-v&quot;^$&quot;|wc-l</code><br>这个统计过程会去掉空行，但注释是会计算在内的。</li>
</ol>
</li>
<li>拨打电话的字符串是需要经过NSURL转码，特殊字符需要转换成ASCLL码才能调用。ASCLL码表，#所对应的是%23，*所对应的是%2A</li>
<li>UIImagePickerController的裁剪选择视图向下偏移了status bar的高度，但是裁剪的时候还是按照y=0计算，导致结果产生偏移。（猜测是iOS 11 UIScrollView的contentInsetAdjustmentBehavior属性导致）</li>
<li>UITableView iOS 11新增了一个属性：dragDelegate</li>
<li>裁剪区域本身就是在 UIImageView 上放上一层 UIView，再在 UIView 上绘制出一个白边框的方格 Layer。</li>
<li>根据苹果文档中关于后台执行的描述，任何app都有10分钟左右的后台任务执行时间。 10分钟后，app会被iOS强行挂起。但是，有5类app允许有“无限的”后台运行时间：<ol>
<li>Audio。</li>
<li>Location/GPS。</li>
<li>VoIP。</li>
<li>Newsstand。</li>
<li>Exernal Accessory 。<br>你可以将任何app声明为上述5种类型以获得无限的后台运行时间，但当你提交app到App Store时，苹果会审查你的app，一旦发现你“滥用”了后台API，你的app将被拒绝。</li>
</ol>
</li>
<li>跳转 App Store 需要真机运行</li>
<li>在 iOS 11 上，UIViewController 的 automaticallyAdjustsScrollViewInsets 已经 deprecated 了。UIScrollView 自动调整 ContentInset 的行为接下去是自己管理了，而不是让 UIViewController 来管理了。我们可以通过将 UIScrollView 的 contentInsetAdjustmentBehavior 这个新增 UIScrollViewContentInsetAdjustmentBehavior 属性，设置成 .never ，来关掉对它的自动调整。当然了，这个值默认是 .automatic ，也就是会根据 NavigationBar 和 TabBar 来自动调整。</p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/12/01/Tips201711/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/12/01/Tips201711/'>开发Tips收集-2017年11月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
 
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>禁止WKWebView的左右弹性属性：让webView的scrollView不能左右滑动即可，也就是让webView的内容一直水平居中。<br>self.webView.scrollView.delegate = self;<ul>
<li>(void)scrollViewDidScroll:(UIScrollView *)scrollView{<br>  // 让webview的内容一直居中显示<br>  scrollView.contentOffset = CGPointMake((scrollView.contentSize.width - screenWidth) / 2, scrollView.contentOffset.y);<br>}</li>
</ul>
</li>
<li>使用UIWebView装载一个网页后，可能需要提取其内的信息，比较好的方法是使用JavaScript。方法UIWebView.stringByEvaluatingJavaScript可以执行一个脚本。</li>
<li>xcode9打包版本只能是8.2及以下版本,或者9.0及更高版本；xcode9不支持8.3和8.4版本；xcode9新打包要在构建版本的时候加入1024*1024 AppSore icon</li>
<li>tableView在iOS11默认使用Self-Sizing，tableView的estimatedRowHeight、estimatedSectionHeaderHeight、estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension</li>
<li>模拟器网速调整： 限制时输入下面两行，根据需要修改下面的数字：]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.github.io/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.github.io/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.github.io/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《机器学习实战》笔记（一）：K近邻]]></title>
    <link href="http://conanwhf.github.io/2017/10/02/KNN/"/>
    <id>http://conanwhf.github.io/2017/10/02/KNN/</id>
    <published>2017-10-02T05:31:26.000Z</published>
    <updated>2017-10-02T06:40:08.000Z</updated>
    <content type="html"><![CDATA[<p>机器学习最近太火，本来不想跟风，但是看到alphaGo的表现和最近的业内新闻，深深感觉到不赶紧跟一跟就要被时代的浪潮拍死在沙滩上了……没太多时间潜心磨练代码，只能从经典《机器学习实战》开始跟着写写，一章一章慢慢过，然后记录一下自己的理解和碰到的问题。<br>事实上，我在大学里已经学过一门《模式识别》，算是机器学习的前身，那时的内容和现在的实际应用相比已经是垂垂老矣，但有的部分也可以算作是复习。整本书的示例代码是python2+numpy，但我觉得照书打一遍一点意思也没有，于是改用自己相对比较熟悉的python3+pandas（其实也不太熟，边百度能写出代码的水平）重构代码，顺便练习python。这里要吐槽一下作者的github，还专门放了个<strong> <a href="https://github.com/pbharrin/machinelearninginaction3x" title="machinelearninginaction3x" target="_blank" rel="external">machinelearninginaction3x</a></strong>的项目，我估计就是从原版fork出来还没来得及改吧，打开里面还是python2的代码。<br> </p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/10/02/KNN/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/10/02/KNN/'>《机器学习实战》笔记（一）：K近邻</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
<h2 id="CH01_uFF1A_u673A_u5668_u5B66_u4E60_u57FA_u7840"><a href="#CH01_uFF1A_u673A_u5668_u5B66_u4E60_u57FA_u7840" class="headerlink" title="CH01：机器学习基础"></a>CH01：机器学习基础</h2><p>第一章就没啥可说的了，介绍一点机器学习的概念。我的理解是机器学习并不是一种创造的过程，不能无中生有，它其实就是通过各种数据在学习怎么将事物分类。这个分类和学习都不是狭义上的，学习的数据可以没有正确答案（无监督学习），而分类目标可以不是单纯的类别（预测数值型数据）。简单来说，机器学习的目的就是通过已有数据构造一个分类器，来预测其他数据的结果。<br><a id="more"></a></p>
<h2 id="CH02_uFF1Ak-_u8FD1_u90BB_u7B97_u6CD5"><a href="#CH02_uFF1Ak-_u8FD1_u90BB_u7B97_u6CD5" class="headerlink" title="CH02：k-近邻算法"></a>CH02：k-近邻算法</h2><h3 id="u7B97_u6CD5"><a href="#u7B97_u6CD5" class="headerlink" title="算法"></a>算法</h3><p>k-近邻(kNN，k-NearestNeighbor)，顾名思义就是通过k个最近的邻居的身份来决定自己身份的分类方法。而所谓的邻居和自己的距离，是通过欧式距离来计算的。具体算法：</p>
<ol>
<li>对所有已知数据归一化处理；</li>
<li>对n组（<strong>即每个邻居</strong>）已知数据（包含m个特征点数据）进行计算，得出这个邻居与待分类数据的欧式距离；</li>
<li>对得到的所有距离进行排序，取出前k个距离；</li>
<li>对前k个距离进行统计计数，将最多的一个类别作为待分类数据的类别。<br>以下照搬：<blockquote>
<p><strong>优点</strong>：精度高、对异常值不敏感、无数据输入假定。<br><strong>缺点</strong>：计算复杂度高、空间复杂度高。 适用数据范围：数值型和标称型。</p>
</blockquote>
</li>
</ol>
<p>计算复杂度高很容易理解，毕竟如果已知的训练样本集内数据是n组，每组数据包含m个特征点，那么即使不考虑归一化，要获取任何一个新样本的分类，需要n*m次计算。不过我认为空间复杂度倒是还好，毕竟可以通过各种技巧来节约空间，例如每次只读一个样本，并且只记录最小的前k个距离（k一般小于20所以几乎可以忽略），这样最少只需要2*m个数据空间，只是每次分类都要全部重新读取训练样本，时间会大大增加了。</p>
<h3 id="u5B9E_u8DF5"><a href="#u5B9E_u8DF5" class="headerlink" title="实践"></a>实践</h3><p>这一章的实践内容主要是手写数字识别。程序上的事情没什么好说的，我的主要改动就是把作者的numpy改成了pandas，并且将分类结果存在了dataframe同一个表中而不是单独分开，代码<a href="https://github.com/conanwhf/ML-Action/tree/master/CH02" target="_blank" rel="external">在此</a>。<br>碰到了两个坑。首先是约会对象的demo中，我获得的结果和书上不一样。查了半天确定程序没写错，原来是作者在github上提供的数据集和书中用的不一样。<br>另外一个坑就太坑了：手写数字识别的时候，同一个程序会跑出不一样的结果！这个问题我debug了半天，先是抽出有争议的待测样本专门测试，发现这个问题是random的😱；然后反复加打印看数据，最终发现坑在这里：<br><code>neighbors = data.head(k)[CLASS_COL_NAME].value_counts()</code><br>这个<code>value_counts</code>是pandas中用来统计计数并排序的，会降序输出统计结果。如原始数据是（2，2，2，3，3，1），则会输出（大意，格式可能不对）：2:3, 3:2, 1:1。而问题在于当我的原始数据是(1, 2, 3)时，它的output变成随机的！！！1:1, 2:1, 3:1； 2:1, 1:1, 3:1； 3:1, 2:1, 1:1……一切皆有可能😳！你说它错了吧，它也没错，可是你这个函数输出不确定是什么鬼！我原本是根据<code>value_counts</code>的输出，取第一名作为结果，也就是k近邻中最多的那个类别，但由于这种“并列第一”时的不确定，我的程序判定结果也变得不确定了。最后我只好手动处理，如果有“并列第一”的情况，就选择距离最近的那个邻居的类别作为分类结果。</p>
<h3 id="u6742_u8C08"><a href="#u6742_u8C08" class="headerlink" title="杂谈"></a>杂谈</h3><p>手写数字识别这个问题刚好大学学模式识别的时候我自己做过。那时候是纯粹用特征点匹配解决的，先把图片框定范围，骨架化，提取特征点，然后对照带权重的特征点计算特征向量，最后匹配最佳结果，识别率大概在85%-90%之间。所以当看到书上用kNN做手写数字识别，真的是震惊到了，从没想过kNN可以做这个，因为在我的想法中，kNN的每个特征都是有意义的，而手写数字图片中每个像素点的0或1，是无意义的。但实践证明，使用kNN的方法，成功率高达98%以上。这个事实让我有一种豁然开朗的感觉：过去模式匹配的那一套确实已经过时了，现在有这么多新的方法，或者是旧方法的新思路在向我招手，加上硬件日益强大的计算能力所能做到的远超从前，仅凭我自己能做到的事一定更多更复杂，想想还挺激动人心的。<br>不过话说回来，我对kNN的神奇功效依然并不那么信任，因为我总觉得kNN的成功率是建立在特征点的有效性上面的。例如一个预测学生成绩的程序，过去的成绩、作业完成度都可以是特征点，但在家喝水的杯子是玻璃杯还是塑料杯这种事就不能作为特征点，因为和学习成绩毫无关系，将其加入计算的话反而会影响预测结果。在手写数字识别这一点上，我依然持同样的保留态度：这一章的图片都是经过特别归一化的，边距、大小都完全统一，风格也基本类似，这就人为地建立了一种像素点和数字本身的特征映射；而在真正的手写体中，不同字体或者风格所带来的区别可能完全毁掉这种映射关系，除非重新建立一套训练样本集。我想这本书将来的东西应该会讲到更多的东西，来解决这个问题吧？拭目以待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>机器学习最近太火，本来不想跟风，但是看到alphaGo的表现和最近的业内新闻，深深感觉到不赶紧跟一跟就要被时代的浪潮拍死在沙滩上了……没太多时间潜心磨练代码，只能从经典《机器学习实战》开始跟着写写，一章一章慢慢过，然后记录一下自己的理解和碰到的问题。<br>事实上，我在大学里已经学过一门《模式识别》，算是机器学习的前身，那时的内容和现在的实际应用相比已经是垂垂老矣，但有的部分也可以算作是复习。整本书的示例代码是python2+numpy，但我觉得照书打一遍一点意思也没有，于是改用自己相对比较熟悉的python3+pandas（其实也不太熟，边百度能写出代码的水平）重构代码，顺便练习python。这里要吐槽一下作者的github，还专门放了个<strong> <a href="https://github.com/pbharrin/machinelearninginaction3x" title="machinelearninginaction3x">machinelearninginaction3x</a></strong>的项目，我估计就是从原版fork出来还没来得及改吧，打开里面还是python2的代码。<br> <!-- indicate-the-source --></p>
<h2 id="CH01_uFF1A_u673A_u5668_u5B66_u4E60_u57FA_u7840"><a href="#CH01_uFF1A_u673A_u5668_u5B66_u4E60_u57FA_u7840" class="headerlink" title="CH01：机器学习基础"></a>CH01：机器学习基础</h2><p>第一章就没啥可说的了，介绍一点机器学习的概念。我的理解是机器学习并不是一种创造的过程，不能无中生有，它其实就是通过各种数据在学习怎么将事物分类。这个分类和学习都不是狭义上的，学习的数据可以没有正确答案（无监督学习），而分类目标可以不是单纯的类别（预测数值型数据）。简单来说，机器学习的目的就是通过已有数据构造一个分类器，来预测其他数据的结果。<br>]]>
    
    </summary>
    
      <category term="kNN" scheme="http://conanwhf.github.io/tags/kNN/"/>
    
      <category term="MachineLearning" scheme="http://conanwhf.github.io/categories/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2017-09]]></title>
    <link href="http://conanwhf.github.io/2017/09/30/ReadingList2017-09/"/>
    <id>http://conanwhf.github.io/2017/09/30/ReadingList2017-09/</id>
    <published>2017-09-30T02:36:54.000Z</published>
    <updated>2018-02-12T03:53:04.052Z</updated>
    <content type="html"><![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>大脑使用指南：其实你活在大脑创造的虚拟世界中</strong><br>很有意思的一本大脑神经科学科普书，书中内容跟使用指南没有半点关系，但副标题基本可以概括主要思想了。整本书不长，很容易就读完了，也没有讲很多高深的东西，大部分的时候甚至感觉说得太浅了，像是给小孩子看的。但是就内容来说，确实很有意思，对大脑工作的机制和很多现象有了一些了解，值得一读。</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>名侦探柯南漫画</li>
<li>Pocket</li>
</ol>
<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2><ol>
<li>机器学习实践</li>
</ol>
<h2 id="u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0807-09_u6708_uFF09_33-75"><a href="#u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0807-09_u6708_uFF09_33-75" class="headerlink" title="买的正版非免费书（07-09月）             33.75"></a>买的正版非免费书（07-09月）             <strong>33.75</strong></h2><ol>
<li>程序员代码面试指南:IT名企算法与数据结构题目最优解 <strong>16.76</strong></li>
<li>Python爬虫开发与项目实战 <strong>16.99</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>腰伤基本好了以后，我终于可以恢复运动了。可能是体重的压力太大，也可能是半年没运动肌肉已经退化，乍一开跑才两三公里，第二天的膝盖便开始隐痛，我可不想再伤一回。原本转战泳池，但最近的阳光慢慢不充沛了，泳池的水也常常感觉太凉，于是我选择了椭圆机。在椭圆机上身体相对比较稳定，看书或者看片都是极好的选择。于是这个月虽然恢复运动的时间只有十来天，就着每天这半小时无聊的时间，我的阅读时间也大大增加了。大屏的静境配上蓝牙遥控器，其实还蛮酷炫的。<br>不知道是不是政策原因或者别的什么压力，我订阅的中文传媒精选已经停止发送了，现在每个月的固定项目就只有柯南的漫画。我发现看漫画需要离得很近，即使是椭圆机这种姿势的距离，看漫画也总觉得无法集中精神，看不进去；看专业书又感觉手痒，不对照着写点代码就像没看过书一样。幸好我想起来自己还有堆积如山的pocket没有清掉，一篇文章3-10分钟，正好适用于这种半碎片阅读时间。要不是特意想想还真想不起来我还有pocket这种东西，IFTTT还在每周忠实地把我的RSS订阅转发到Pocet里，一打开已经攒了273条未读了……😰</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>大脑使用指南：其实你]]>
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.github.io/tags/BookList/"/>
    
      <category term="Reading" scheme="http://conanwhf.github.io/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于域名的一点说明]]></title>
    <link href="http://conanwhf.github.io/2017/09/28/aboutAddress/"/>
    <id>http://conanwhf.github.io/2017/09/28/aboutAddress/</id>
    <published>2017-09-28T01:35:25.000Z</published>
    <updated>2017-09-28T03:39:02.000Z</updated>
    <content type="html"><![CDATA[<p>继去年三月gitcafe牺牲以后，最近我发现coding也开始服务不稳定了。原本提交到显示的时间差最多只有一两个小时，但不知道为啥昨天的提交一直到今天早上还没显示出来。查看托管的源码没问题，并且重新提交了一次就马上更新了，可有了gitcafe的前车之鉴，我不由得担心起coding的生命周期来。顺便今天去看了看gitcafe，原本只是不可更新，现在是整个站点都没了。尽管属于预料之中，我还是很不爽，这就意味着我之前在开发者头条提交的链接失效了。就算没有SEO的意思，还是总觉得不完美了……不，岂止是不完美，简直是丑陋😡！<br>于是我打算重新调整策略：把github.io作为域名，coding.me的内容完全作为一个镜像，国内服务商还是有点玄，搞不好哪天就挂了。主要是查看过统计后台后，我发现：<br></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/09/28/aboutAddress/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/09/28/aboutAddress/'>关于域名的一点说明</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
<ol>
<li>通过github.io打开页面的人远远超过coding.me</li>
<li>即使是中文关键词，通过google搜索的人也比baidu多</li>
<li>百度链接提交并没有屏蔽github<br>所以看起来，在目前github还没有被封的情况下，用git是个更好的选择。以上！</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>继去年三月gitcafe牺牲以后，最近我发现coding也开始服务不稳定了。原本提交到显示的时间差最多只有一两个小时，但不知道为啥昨天的提交一直到今天早上还没显示出来。查看托管的源码没问题，并且重新提交了一次就马上更新了，可有了gitcafe的前车之鉴，我不由得担心起cod]]>
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.github.io/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派打造的家庭环境监控]]></title>
    <link href="http://conanwhf.github.io/2017/09/16/EnvMonitor/"/>
    <id>http://conanwhf.github.io/2017/09/16/EnvMonitor/</id>
    <published>2017-09-16T09:31:26.000Z</published>
    <updated>2017-09-27T11:28:44.000Z</updated>
    <content type="html"><![CDATA[<p>最近空气质量又有下降的趋势，想想手头的RPI2B，干脆拿来改造成一个环境监控系统吧，放在客厅随时可以看到，情况不对马上开净化器😊。传感器部分都是以前就买了的，平时拿来偶尔玩一下。主要是三个：一个空气质量检测的激光传感器，一个温湿度的DHT22，一个凑数的带光感的数模转换。屏幕是一块5寸的HDMI破电阻屏，用来搭建本体的是两包白色塑料小积木，所有东西均购自淘宝，包括树莓派物料成本大约500+。说起来这个成本很高了，主要是树莓派本身加一个屏幕，光用来做这个有点浪费。好在我本来也是要放在那边当小服务器用，跑个定时脚本，偶尔看个kernel什么的。</p>
<h2 id="u786C_u4EF6_u90E8_u5206"><a href="#u786C_u4EF6_u90E8_u5206" class="headerlink" title="硬件部分"></a>硬件部分</h2><a id="more"></a>
<p>因为传感器都是做好了的，树莓派自己也引出了两排Pin脚，硬件其实就是连几根线而已。只有一个问题需要考虑就是传感器都是上电即工作的，如果一直通电的话，过不了多久估计就烧了。所以我决定用GPIO当作开关来控制sensor的电源，只在需要获得数据时打开。这样一来那两个只需要3.3V的sensor还好，直接用GPIO给电即可，空气质量那个传感器需要5V的就麻烦了。还有LCD屏幕，也是要求5V，并且本身是USB供电，只好把原有的拨动开关拆了，小改电路，使用一个接入的5V电源来解决。<br>最终的硬件连线图如下：</p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/09/16/EnvMonitor/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/09/16/EnvMonitor/'>树莓派打造的家庭环境监控</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br><img src="http://whf.d.pr/hhTgSG+" alt=""><br>图中的空气质量sensor和屏幕的电源都外接了一个场效应管，用来决定5V电源Pin的通断，由一个GPIO接入来控制。空气质量的数据是UART传输，PCF8591的接口是I2C，而DHT11则直接使用GPIO的一个Pin来传输数据（总感觉有点不靠谱的），另外添加了三个LED灯来实时反应空气质量的等级。</p>
<h2 id="u8F6F_u4EF6_u90E8_u5206"><a href="#u8F6F_u4EF6_u90E8_u5206" class="headerlink" title="软件部分"></a>软件部分</h2><p>软件语言使用的是Python3，一个不在乎速度的上上之选。我虽然是那种一边百度一边写python的超级新手，但用过以后就再也不想换回繁琐的C了，更别说在树莓派上有那么多现成的库可以给你用。</p>
<h3 id="u6574_u4F53_u7ED3_u6784"><a href="#u6574_u4F53_u7ED3_u6784" class="headerlink" title="整体结构"></a>整体结构</h3><p>软件方面只有三个主要的线程，两个负责拿数据，一个负责UI：<br><img src="http://whf.d.pr/QctyUV+" alt=""><br>程序跑起来后除了UI，会自己开两个线程进行循环，在循环中获取系统、sensor的状态并刷新在UI上。运行的模式有两种：实时和日常。实时模式主要是给需要迅速获得状态的时候使用，例如刚刚打开净化器想看看质量是否在持续改善，或者是网络有问题的时候看看能否ping通google；而日常模式则是无人关注的日常行为。主界面有一个按钮可以切换这两种模式，线程内部会根据切换后的状态判断自己应该睡眠多久再进行下一轮状态更新。<br>在日常模式中，系统每个循环会获取所有传感器的数据并更新上报至Yeelink，以及根据空气质量调整相对应的LED灯。而在实时模式，每个循环内则会另外获取一些操作系统状态来显示，并刷新ping服务器（Google）的结果。除了日常和实时两个模式中获取的状态，还有一个单独的线程用来刷新开机时间和公网IP。这两个数据对实时的要求不高，更新频率也很低，就直接固定为30分钟一次了。</p>
<h3 id="u4F20_u611F_u5668_u6570_u636E_u83B7_u53D6"><a href="#u4F20_u611F_u5668_u6570_u636E_u83B7_u53D6" class="headerlink" title="传感器数据获取"></a>传感器数据获取</h3><p>传感器方面，以前都是用过的，底层的库也很成熟，所以代码量很小，主要是封装一下变成类库。要说重新写的部分，就是自己写了个Power的类，免得分散在GPIO的相关代码里面，很难看。以前用的DHT11，这次换成DHT22，懒得再自己写程序了，直接用的官方库。</p>
<h3 id="UI_u8BBE_u8BA1"><a href="#UI_u8BBE_u8BA1" class="headerlink" title="UI设计"></a>UI设计</h3><p>UI部分我用的Python自带的tkinter，虽然是头一次用，但毕竟是Python，随便看看文档就搞定了，API简单得不得了。当然，主要是因为我的UI很简单：显示label，button，监听点击和关闭事件就是所有需求了。而这些对于任何一个语言的UI来说，用法基本都是通用的。唯一有点不同的是它对于控件的排列方式，使用了个叫<strong>grid</strong>的方法，实际上是将整个界面划分为N*M的小方格，再通过对控件所占用方格的位置、大小、对齐属性，来决定控件的具体位置。<br>另外一个小问题是在调试时发生的，我发现在SSH的状态下，无法从命令行启动UI，报错的具体内容我忘了，大概意思是找不到具体设备。网上搜了一下有人遇到同样的问题，年代久远，且无人回答。后来看了下API的文档，发现窗口的初始化函数Tk是可以带参数的：</p>
<ol>
<li>在有UI的桌面环境下打开终端，运行<code>export</code></li>
<li>在输出结果中找到<code>DISPLAY=XXXX</code>的部分，比如说我的是<code>DISPLAY=&quot;:0.0&quot;</code></li>
<li>在代码中添加参数：<code>tk.Tk(screenName=&quot;:0.0&quot;)</code><br>问题解决。</li>
</ol>
<h3 id="u6570_u636E_u4E0A_u4F20"><a href="#u6570_u636E_u4E0A_u4F20" class="headerlink" title="数据上传"></a>数据上传</h3><p>Yeelink是一个对个人用户免费的物联网服务，你可以将自己的数据上传，并在Web端查看。虽然时常抽风，但既然是免费的我还能抱怨什么呢？感谢天感谢地，感谢Yeelink让我和家人可以随时随地用手机查看家里的环境数据😜。系统每次获取到sensor的数据后会自动上报给Yeelink，让我奇怪的是官方好像只有接口文档而没有给出范例代码，网上的也大都有点过时了，害得我想偷个懒都不成。虽然GitHub上有，但我还是占用一些篇幅放出这部份代码，以造福想用搜索引擎偷懒的小朋友们吧：</p>
<pre><code>#!/usr/bin/python3
import time
import json
import requests

#yeelink api配置
apiUrl=&apos;http://api.yeelink.net/v1.1/device/%s/sensor/%s/datapoints&apos;
apiKey=&apos;123456&apos; #请填入专属的api key
apiHeaders={&apos;U-ApiKey&apos;:apiKey,&apos;content-type&apos;: &apos;application/json&apos;}
deviceID = 1232312
sensorID = {&apos;pm25&apos;:123, &apos;pm10&apos;: 456,&apos;temperature&apos;:789, &apos;humidity&apos;:111}

#上传sensor数据到yeelink
def upload_to_yeelink(name, value):
    url= apiUrl % (deviceID,sensorID[name])
    strftime=time.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;)
    #print(url, strftime)
    data={&quot;timestamp&quot;:strftime , &quot;value&quot;: value}
    try:
        res=requests.post(url,headers=apiHeaders,json=data, timeout=3.0)
        if res.status_code!=200:
            print(&quot;status_code:&quot;,res.status_code)
        else:
            pass
    except:
        print(&quot;report to yeelink fail&quot;)

if __name__ == &quot;__main__&quot;:
    upload_to_yeelink(&apos;pm25&apos;, 100)
</code></pre><p>从哪里获取deviceID、sensorID我就不多说了，注册和新建的时候自然都知道了。值得一提的是其中的timeout参数（3.0那个），是因为我发现即使网络没问题，有时候也会无限卡死在等response的地方，不知道是不是服务器会抽风。<br>使用这段代码需要先装requests库，原因？自然是为了偷懒。不然原生的http api处理什么json, error，timeout要多写好几行呢！</p>
<h3 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h3><p>软件方面的其他内容还有三个小地方值得注意：</p>
<ol>
<li>桌面图标。要想完全脱离键盘用UI来操作，一个桌面的打开快捷方式必不可少。原来我以为直接放一个main的软链接就行了，结果人家直接不显示，原来需要固定格式的桌面图标文件才行。我以chrome的图标为基准修改了一个，还能自己定义ico，挺好玩。</li>
<li>循环睡眠的代码。之前我想当然地在日常模式中直接写了sleep(600)，结果发现这个bug太蠢了：在UI上切换入实时模式时根本无法实时响应变化，非要等10分钟后睡醒了才知道。后来就改成了无论那种模式都是每次睡一秒，醒来看看状态是否变为实时模式，以决定是否要继续睡。</li>
<li>循环时间。在循环中，每个cycle的时间并不真的是1秒或者10分钟，那个只是睡眠的时间；整个cycle还包括了获取数据的时间、上报数据的时间、以及其他开销。</li>
</ol>
<h2 id="u78B0_u5230_u7684_u95EE_u9898"><a href="#u78B0_u5230_u7684_u95EE_u9898" class="headerlink" title="碰到的问题"></a>碰到的问题</h2><p>改造系统的过程中碰到了不少问题，记得起来的写一下。</p>
<h3 id="u7535_u538B_u95EE_u9898"><a href="#u7535_u538B_u95EE_u9898" class="headerlink" title="电压问题"></a>电压问题</h3><p>我的树莓派上除了接这些sensor和屏幕，还有一个蓝牙、一个USB WIFI、一个摄像头，可想而知耗电量是相当大的了。如果只提供5V1A的供电，系统则会在屏幕右上角显示一个黄色的闪电符号，提醒你电量不足。但即使是电量不足，程序也都是能运行的，只是……会影响sensor的读数。<br>刚开始放到电视柜上的时候，发现空气质量的读数突然变得巨大，完全不正常，而拿去书房debug又降下来很多（依然不正常），百思不得其解，直到把屏幕拿掉读数完全正常，才发现是给电的问题。最后我用了两个5V2A的USB供电（一个专供显示屏），才算解决了这个问题。</p>
<h3 id="DHT22_u7684_u5B98_u65B9_u5E93"><a href="#DHT22_u7684_u5B98_u65B9_u5E93" class="headerlink" title="DHT22的官方库"></a>DHT22的官方库</h3><p>说起来虽然DHT系列的sensor本身质量不怎么样，公司还不错，能提供python的库直接用，而且同时支持DHT22和DHT11。DHT11之前我是自己写的，拿一个GPIO Pin来发命令、收数据，该说这想法很👍呢还是很😫呢？其实用C还好，用python就总觉的太不……专业。DHT11的数据特别是湿度实在是太不准了，差了十万八千里，有个Pin脚好像也有点问题，于是打算换个DHT22试试。结果嘛，虽然比原来准了一点但依然有25%-40%的误差🙄，并且这个官方给的库坑得我不轻。<br>首先是无响应问题。在硬件都正常的情况下，API很偶尔会无响应，估计是因为timming的问题miss掉了某个状态之类的。其实timeout是有的，但是那时间长得令人发指，直接可以当作死循环了。这个问题我也懒得去搞什么花样来解决了，死等就死等吧，别真死就行。<br>然后是返回值的问题。返回值一般是float的，比如35.4这类，坑的是如果它是35.0，就会直接给你个int的35，害得我用.1f输出就死了，需要自己强制转换下类型；这还不够奇葩，奇葩的是如果有什么问题拿不到数据，它直接给你个NULL，害得我在转换类型时又死了😳……心累！</p>
<h3 id="u6563_u70ED_u95EE_u9898"><a href="#u6563_u70ED_u95EE_u9898" class="headerlink" title="散热问题"></a>散热问题</h3><p>除了电压，散热也是会影响sensor工作的。而最直接的影响，就是温度检测了。机器跑了两天后，我突然发现上报的温度太高，比普通温度计测量的结果高差不多4度。而同样的，当我拿去书房debug，一切又恢复了正常😓……这次我没那么傻了，估计是散热问题，之前做的积木壳，只留出一面开口用来插数据线和通风，确实散热太差，CPU长期保持在59℃也是挺吓人的。于是我将外壳加高了两层，让里面的各种线和元器件不要那么拥挤，又在侧面加了个小风扇，果然解决问题，CPU降到了45℃，温度测量也正常了。<br>值得一提的是这个风扇是当初买rpi亚克力壳子送的，接上之后持续发出我无法忍受的高频噪音，我这才想起来为什么当初被我扔到角落里了😌。想来想去，采取了折中的手段：将原本需要5V的风扇电源接到3.3V上，风扇转速降低，但是一点都不响了。CPU这次大概在48℃左右还可以接受，温度的sensor也读数正常。</p>
<h2 id="u6700_u7EC8_u6548_u679C"><a href="#u6700_u7EC8_u6548_u679C" class="headerlink" title="最终效果"></a>最终效果</h2><p>整个项目中，组装其实是最大的挑战：用那个小积木拼东西手太疼了啊！拼了我整整一天，手指头都脱皮了，才搞定整个造型。<br>这是没有盖上屏幕的样子：<br><img src="http://whf.d.pr/135Aov+" alt=""><br>以及最终成品：<br><img src="http://whf.d.pr/VaydLR+" alt=""><br>项目源码已上传至GitHub：<a href="https://github.com/conanwhf/Rpi-envMonitor" title="Rpi-envMonitor" target="_blank" rel="external">Rpi-envMonitor</a>，欢迎Star！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近空气质量又有下降的趋势，想想手头的RPI2B，干脆拿来改造成一个环境监控系统吧，放在客厅随时可以看到，情况不对马上开净化器😊。传感器部分都是以前就买了的，平时拿来偶尔玩一下。主要是三个：一个空气质量检测的激光传感器，一个温湿度的DHT22，一个凑数的带光感的数模转换。屏幕是一块5寸的HDMI破电阻屏，用来搭建本体的是两包白色塑料小积木，所有东西均购自淘宝，包括树莓派物料成本大约500+。说起来这个成本很高了，主要是树莓派本身加一个屏幕，光用来做这个有点浪费。好在我本来也是要放在那边当小服务器用，跑个定时脚本，偶尔看个kernel什么的。</p>
<h2 id="u786C_u4EF6_u90E8_u5206"><a href="#u786C_u4EF6_u90E8_u5206" class="headerlink" title="硬件部分"></a>硬件部分</h2>]]>
    
    </summary>
    
      <category term="RaspberryPi" scheme="http://conanwhf.github.io/tags/RaspberryPi/"/>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Centos中安装和使用Python3]]></title>
    <link href="http://conanwhf.github.io/2017/07/12/CentosPython/"/>
    <id>http://conanwhf.github.io/2017/07/12/CentosPython/</id>
    <published>2017-07-12T10:31:26.000Z</published>
    <updated>2017-07-12T12:32:17.000Z</updated>
    <content type="html"><![CDATA[<p>前几天碰到一个有点尴尬的需求：我一直有个Bandwagon的服务器用来做SS，自己写了个Python3的脚本，想用这个服务器定时启动跑一下。结果发现Bandwagon的SS只支持Centos的系统，而Centos系统里又只默认安装了python2.6，并且SS也必须要Python2.6才能跑。<br>虽然Bandwagon支持更换操作系统，可选的版本也很多，但我实在懒得折腾，想想还要自己安装维护SS服务就头大，只好考虑在Centos上安装Python3了。</p>
<h2 id="Install_python3"><a href="#Install_python3" class="headerlink" title="Install python3"></a>Install python3</h2><p>不同于Ubuntu和Debian的apt-get，在Centos上的安装工具是yum，这个我没用过，但是也大同小异。首先是需要安装几个开发工具库，脚本也是网上看到的，有的是已经有了的，姑且无脑安装一下吧。<a id="more"></a></p>
<h3 id="dev_libs_install"><a href="#dev_libs_install" class="headerlink" title="dev libs install"></a>dev libs install</h3><pre><code>yum -y update
yum groupinstall -y ‘development tools’
yum install epel-release
yum install -y zlib-devel bzip2-devel openssl-devel xz-libs wget
yum clean all
</code></pre> </p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/07/12/CentosPython/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/07/12/CentosPython/'>在Centos中安装和使用Python3</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

<h3 id="Python_install"><a href="#Python_install" class="headerlink" title="Python install"></a>Python install</h3><p>然后就可以装Python了：<br><code>yum install python34</code><br>安装完成后，系统中会出现两个Python，分别在/usr/lib64/python3.4/和/usr/lib64/python2.6/。使用<code>ls -lia /usr/bin/python*</code>可以看到，python2 和 python3 分别指向两个不同的python版本，但python则是跟python2一样的一个binary。这也意味着我们可以使用python2和python3来分别调用两个版本的python，同时系统默认的python版本是python2.6。</p>
<h2 id="Pip"><a href="#Pip" class="headerlink" title="Pip"></a>Pip</h2><p>安装好python后，接下来必装的就是pip了。</p>
<pre><code>curl  https://bootstrap.pypa.io/get-pip.py | python3 -
</code></pre><p>安装完毕又出现一个问题，就是两个python是分开的，安装后的pip默认是直接给<strong>python</strong>安装库，所以即使安装了，也是给python2的，python3用不了。开始我采用的解决方法是修改/usr/bin/python的软链接，使系统的python版本默认为python3.4，但是这样做的结果是yum用不了（这个尚且有解）并且ss服务也启动不了了（这个不能接受）。为了避免类似的问题，我放弃了修改整个系统的python版本，而是直接改了pip所使用的python版本：<br><code>vi /usr/bin/pip</code>，将第一行的<strong>/usr/bin/python修改为/usr/bin/python3</strong><br>这样，使用pip install就是将库安装在python3了。然后可以升级一下pip:</p>
<pre><code>pip install —upgrade pip
</code></pre><h2 id="Libxml"><a href="#Libxml" class="headerlink" title="Libxml"></a>Libxml</h2><p>顺便说个题外话，关于如何安装libxml。我需要安装python的xml库，但使用<code>pip install lxml</code>的时候报错，说系统没有xml库，安装一下即可：<br>    yum install libxml2-dev libxslt</p>
<h2 id="Crond"><a href="#Crond" class="headerlink" title="Crond"></a>Crond</h2><p>环境配置都完成了，终于可以把我的脚本跑起来了。这个破系统连crond都没有默认跑起来，还是只能自己手动干活：</p>
<ol>
<li><code>yum install crond</code></li>
<li>in /etc/rc.d/rc.local, add:<br><code>/sbin/service crond start</code></li>
<li>crontab -e<br><code>0 */2 * * * python3 /root/test/main.py</code></li>
</ol>
<p>搞定收工！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天碰到一个有点尴尬的需求：我一直有个Bandwagon的服务器用来做SS，自己写了个Python3的脚本，想用这个服务器定时启动跑一下。结果发现Bandwagon的SS只支持Centos的系统，而Centos系统里又只默认安装了python2.6，并且SS也必须要Python2.6才能跑。<br>虽然Bandwagon支持更换操作系统，可选的版本也很多，但我实在懒得折腾，想想还要自己安装维护SS服务就头大，只好考虑在Centos上安装Python3了。</p>
<h2 id="Install_python3"><a href="#Install_python3" class="headerlink" title="Install python3"></a>Install python3</h2><p>不同于Ubuntu和Debian的apt-get，在Centos上的安装工具是yum，这个我没用过，但是也大同小异。首先是需要安装几个开发工具库，脚本也是网上看到的，有的是已经有了的，姑且无脑安装一下吧。]]>
    
    </summary>
    
      <category term="Centos" scheme="http://conanwhf.github.io/tags/Centos/"/>
    
      <category term="Python" scheme="http://conanwhf.github.io/tags/Python/"/>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2017年07月]]></title>
    <link href="http://conanwhf.github.io/2017/07/12/Tips201707/"/>
    <id>http://conanwhf.github.io/2017/07/12/Tips201707/</id>
    <published>2017-07-12T09:25:39.000Z</published>
    <updated>2017-07-12T10:57:50.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>点击通知栏的通知进入程序时，会触发App Delegate里的方法，分为以下两种情况：<ol>
<li>程序未启动（即底部任务栏里没有进程）时：<br>　　<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>。对于launchOptions参数，需要经过以下处理：<code>NSDictionary* pushNotificationKey = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]</code>，其中的pushNotificationKey才是从服务端推送过来的数据，使用键值对方式就可以读取服务器传递过来的额外参数了。<br>应用还没有加载，这时如果点击通知的显示按钮，会调用didFinishLaunchingWithOptions，不会调用didReceiveRemoteNotification方法。如果点击通知的关闭按钮，再点击应用，只会调用didFinishLaunchingWithOptions方法。 <a id="more"></a></li>
<li>程序已启动：如果程序已经启动，并驻留在内存中，不管程序是在前台（Foreground）还是在后台（Background），如果点击通知栏的通知进入程序将触发以下方法：<br>　　<code>- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo</code>，其中的userInfo参数，就已经是服务端推送过来的数据，也是采用键值对方式进行读取。如果点击关闭再点击应用，则上面两个方法都不会被调用这时，只能在applicationWillEnterForeground或者applicationDidBecomeActive,根据发过来通知中的badge进行判断是否有通知，然后发请求获取数据</li>
</ol>
</li>
<li>真机测试时提示Could not find Developer Disk Image.这是由于真机系统过高或者过低，Xcode中没有匹配的配置包文件，我们可以通过这个路径进入配置包的存放目录： <code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport</code>，将需要的配置包加入到这个文件夹来解决问题。</li>
<li>使用CAShapeLayer画线的优势：<ol>
<li>渲染快,采用硬件加速,比用Core Graphics快很多;</li>
<li>高效使用内存,由于不需要像普通layer那样创建寄宿图,所以无论改layer多大,都不要占用太多内存;</li>
<li>超出图层依然可以绘图,不会被图层边界裁剪掉;</li>
<li>不会出现像素化, CAShapeLayer在做3D变换时,不会像普通有寄宿图的CALayer那样变得像素画.</li>
</ol>
</li>
<li>最常发生的是View的内存泄露问题，首先查看是发生内存泄露的view之间是否有delegate的关系，若有，则去看delegate属性有没有声明weak，一般的由于service或者读取缓存等异步操作引起的内存泄露问题。</li>
<li>用约束做UIView动画<ol>
<li>把需要改的约束Constraint拖条线出来，成为属性</li>
<li>在需要动画的地方加入代码，改变此属性的constant属性</li>
<li>开始做UIView动画，动画里边调用layoutIfNeeded方法</li>
</ol>
</li>
<li>layoutSubviews方法什么时候调用？<ol>
<li>init方法不会调用</li>
<li>addSubview方法等时候会调用</li>
<li>bounds改变的时候调用</li>
<li>scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑)</li>
<li>旋转设备的时候调用</li>
<li>子视图被移除的时候调用</li>
</ol>
</li>
<li>NSSystemTimeZoneDidChangeNotification监听修改时间界面的两个按钮状态变化UIApplicationSignificantTimeChangeNotification 监听用户改变时间 （只要点击自动设置按钮就会调用） NSSystemClockDidChangeNotification 监听用户修改时间（时间不同才会调用）</li>
<li>开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题。</li>
</ul>
 </p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/07/12/Tips201707/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/07/12/Tips201707/'>开发Tips收集-2017年07月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>点击通知栏的通知进入程序时，会触发App Delegate里的方法，分为以下两种情况：<ol>
<li>程序未启动（即底部任务栏里没有进程）时：<br>　　<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>。对于launchOptions参数，需要经过以下处理：<code>NSDictionary* pushNotificationKey = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]</code>，其中的pushNotificationKey才是从服务端推送过来的数据，使用键值对方式就可以读取服务器传递过来的额外参数了。<br>应用还没有加载，这时如果点击通知的显示按钮，会调用didFinishLaunchingWithOptions，不会调用didReceiveRemoteNotification方法。如果点击通知的关闭按钮，再点击应用，只会调用didFinishLaunchingWithOptions方法。]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.github.io/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.github.io/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.github.io/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2017-06]]></title>
    <link href="http://conanwhf.github.io/2017/06/30/ReadingList2017-06/"/>
    <id>http://conanwhf.github.io/2017/06/30/ReadingList2017-06/</id>
    <published>2017-06-30T02:36:54.000Z</published>
    <updated>2018-02-12T03:53:00.321Z</updated>
    <content type="html"><![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>浪潮之巅</strong><br>这本书好多年前红得发紫，也是那时候就打开读一读，但是不知道为什么一而再再而三地没有读下去。这次在它红了近十年之后，终于终结了，然而我的感觉是：平淡得很。<a id="more"></a>
</p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/06/30/ReadingList2017-06/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/06/30/ReadingList2017-06/'>读书清单 2017-06</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

可能是时间证明了一切，十年前那些激动人心的事情，现在已经早就化为日常；又或者是读者的眼界已经今非昔比，除了偶尔赞叹一下之外反而时常对于作者字里行间透露的美帝优越感or崇拜感到不太舒服，这种感觉在开始金融的部分后才稍稍缓解。或者说，这本书对我来说，只有最后两章是有意思的。<br>潮起潮落，IT的浪潮已经席卷世界，IT公司的浪潮却上下颠簸让人唏嘘。走到现在，看看当红炸子鸡Apple、goole、facebook，听听如潮涌般一浪高过一浪的人工智能、深度学习，有一种不知他们要将这个世界带往何处的茫然感觉。我甚至经常感到毛骨悚然，因为这变革的速度太快，快到随时可能失控，快到也许有一天，人类的命脉真的掌握在01创建的智慧中，到时候谁又能说它们不是一种新的生命物种呢？</li>
<li><strong>蒋勋说红楼梦</strong><br>太长，越读到后面重复感越强，放弃了。 </li>
<li><strong>《经济学人》2016必读精选-当黑天鹅坐上无人车</strong><br>同样的烂尾，有点快餐读物的感觉。</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选<br>貌似从9月开始不更新了</li>
<li>名侦探柯南漫画</li>
</ol>
<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2><ol>
<li>大脑使用指南：其实你活在大脑创造的虚拟世界中</li>
</ol>
<h2 id="u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0804-06_u6708_uFF09_54-98"><a href="#u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0804-06_u6708_uFF09_54-98" class="headerlink" title="买的正版非免费书（04-06月）             54.98"></a>买的正版非免费书（04-06月）             <strong>54.98</strong></h2><ol>
<li>中国科幻丛书（套装共7册）                        <strong>12.99</strong> </li>
<li>中信历史的镜像系列（套装共10本）                  <strong>39.99</strong></li>
<li>上帝的图书馆 (世界奇幻大师丛书)                                   <strong>1.00</strong></li>
<li>疯狂成瘾者：TED脑科学家的戒瘾成功之路（高铭力荐的《天生变态狂》姊妹篇） <strong>1.00</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这段时间比较背运，莫名其妙腰受伤了，左腿甚至整个半边身子都发麻，左脚发木。开始以为是腰椎或者脑部的问题，排队拍核磁共振、等结果搞了两个月，结果医生说看片子啥事没有，就是普通的伤到了神经。说实话我真的挺不信的，没见过几个突然神经受伤的，但也没什么办法，只能好好养着。开始两周根本就是躺着，下地走两步就加重病情，后来渐渐好转，悬着的心才慢慢放下来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>浪潮之巅</strong><br>这本书好多年前红得发紫，也是那时候就打开读一读，但是不知道为什么一而再再而三地没有读下去。这次在它红了近十年之后，终于终结了，然而我的感觉是：平淡得很。]]>
    
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.github.io/tags/BookList/"/>
    
      <category term="Reading" scheme="http://conanwhf.github.io/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（七）uBoot中的启动器]]></title>
    <link href="http://conanwhf.github.io/2017/06/14/bootup-7-loader/"/>
    <id>http://conanwhf.github.io/2017/06/14/bootup-7-loader/</id>
    <published>2017-06-14T09:31:26.000Z</published>
    <updated>2017-06-14T11:33:50.000Z</updated>
    <content type="html"><![CDATA[<p>前面说了那么多，系统已经烧写完毕，按理说没什么问题了，但是我的系统依然跑不起来！通过debug发现，我的kernel镜像按照debian文件系统的要求重命名成了”vmlinuz-XXX”，但我的烧写进去的uboot却在打印信息中明确表示：我找的是zImage！在BeagleBoneBlack的TF卡烧写启动模式中，它的kernel也是修改了命名，但却能顺利引导，是因为把kernel的文件名信息写入了uEnv.txt文件，但是为什么在我的板子上就会失败呢？<a id="more"></a><br></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/06/14/bootup-7-loader/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/06/14/bootup-7-loader/'>ARM板移植Linux系统启动（七）uBoot中的启动器</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>又是一通debug……原来，启动BeagleBoneBlack的TF卡上的uboot跟我编译出来的不一样，它会事先尝试读取<strong>uEnv.txt</strong>文件，如果成功的话，就用文件中配置的环境变量覆盖原有的，从而达到根据不同配置来引导的效果。这就牵涉到了uboot中的启动器，而这个步骤，在我拿到的release里面是没有的😳。这个问题卡住了我不少时间，很奇怪为什么和烧写相对应的源码，在TI的release里面竟然没有放出来，竟然需要自己修改，也不知道是不是我什么地方搞错了。<br>还是老规矩，我们通过阅读源码一步一步地解决问题。</p>
<h2 id="u542F_u52A8_u5668_u7684_u8C03_u7528_u6D41_u7A0B"><a href="#u542F_u52A8_u5668_u7684_u8C03_u7528_u6D41_u7A0B" class="headerlink" title="启动器的调用流程"></a>启动器的调用流程</h2><h3 id="u9009_u62E9_u4ECE_u67D0_u8BBE_u5907_u542F_u52A8"><a href="#u9009_u62E9_u4ECE_u67D0_u8BBE_u5907_u542F_u52A8" class="headerlink" title="选择从某设备启动"></a>选择从某设备启动</h3><p>上次在讲uboot启动过程的时候，提到如何修改autoboot的尝试启动顺序：<code>include/configs/am335x_evm.h</code>文件中定义的</p>
<pre><code>define BOOT_TARGET_DEVICES(func) \
    func(MMC, mmc, 0) \
    func(LEGACY_MMC, legacy_mmc, 0) \
    func(MMC, mmc, 1) \
    func(LEGACY_MMC, legacy_mmc, 1) \
    func(NAND, nand, 0) \
    func(PXE, pxe, na) \
    func(DHCP, dhcp, na)
endif
</code></pre><p>这里的每一行代表了一种启动方式，以<code>LEGACY_MMC</code>为例，可以看到他们表面上是一个很长的字符串，实际上是一个函数的执行列表，或者说执行他们就等于执行一个函数队列。</p>
<pre><code>define BOOTENV_DEV_LEGACY_MMC(devtypeu, devtypel, instance) \
&quot;bootcmd_&quot; #devtypel #instance &quot;=&quot; \
&quot;setenv mmcdev &quot; #instance&quot;; &quot;\
&quot;setenv bootpart &quot; #instance&quot;:1 ; &quot;\
&quot;run mmcboot\0&quot;
</code></pre><p>这些setenv, run有没有很熟悉？是的，他们就是uboot中的命令，在运行的时候uboot也可以直接调用他们以及所有的环境变量。</p>
<h3 id="u5BF9_u5E94_u7684_u542F_u52A8_u51FD_u6570"><a href="#u5BF9_u5E94_u7684_u542F_u52A8_u51FD_u6570" class="headerlink" title="对应的启动函数"></a>对应的启动函数</h3><p>上面步骤的核心是函数（为了方便，权当它就是函数了）<strong>mmcboot</strong>，它定义在<code>include/configs/ti_armv7_common.h</code>。打开文件，你会看到满屏的巨长的一个字符串，不要害怕，就当它是一个个完整的函数，遵守格式修改就OK。<strong>注意：这部分代码因为本身全部是字符串的原因，对格式要求特别严格，修改的时候尽量不要从网页直接copy/paste，以避免很多格式问题。编译之前多检查空格和tab，以及每行末尾多余的空格问题，不然会造成编译失败。</strong><br>可以看到，这里的函数中，有一个<code>loadbootenv</code>，便是用来从uEnv.txt中读取环境变量的：<br><code>&quot;loadbootenv=load ${devtype} ${bootpart} ${loadaddr} ${bootdir}/${bootenvfile}\0&quot;\</code><br>但mmcboot中并没有用到它，尝试在其中添加loadbootenv（格式已被注释破坏，请自行修改后再用）：</p>
<pre><code>&quot;mmcboot=mmc dev ${mmcdev}; &quot; \首先设置mmc的硬件switch
   &quot;setenv devnum ${mmcdev}; &quot; \
   &quot;setenv devtype mmc; &quot; \然后是设备号等设置
   &quot;if mmc rescan; then &quot; \如果mmc硬件初始化成功，
       &quot;echo SD/MMC found on device ${mmcdev};&quot; \
       则读取env数据，并更新环境变量
       &quot;if run loadbootenv; then &quot; \
           &quot;echo Loaded env from ${bootenvfile};&quot; \
           &quot;run importbootenv;&quot; \
       &quot;fi;&quot; \
       &quot;echo debug: Get info=[${uname_r} ${bootfile} ${fdtfile}] ... ; &quot; \
       尝试加载各种img并启动
       &quot;if run loadimage; then &quot; \
           &quot;if test ${boot_fit} -eq 1; then &quot; \
               &quot;run loadfit; &quot; \
           &quot;else &quot; \
               &quot;run mmcloados;&quot; \
           &quot;fi;&quot; \
       &quot;fi;&quot; \
   &quot;fi;\0&quot; \
</code></pre><h3 id="u73AF_u5883_u53D8_u91CF_u548C_u51FD_u6570_u7684_u4FEE_u6539"><a href="#u73AF_u5883_u53D8_u91CF_u548C_u51FD_u6570_u7684_u4FEE_u6539" class="headerlink" title="环境变量和函数的修改"></a>环境变量和函数的修改</h3><p>事实上，上面这些（其实是一个）字符串，就是我们在uboot命令行中使用printenv所看到的各种环境变量了。在uboot尝试读取各种文件的过程中，环境变量作为参数配置扮演了很重要的角色。从哪里读、读哪个目录、文件名是什么、读取到内存什么地址……还有引导的流程、需要传递给kernel的启动参数，无一不是靠这些环境变量来决定。读者认真阅读的话，一定能看懂uboot引导kernel的整个流程和参数的配置过程。<br>经过上面的修改，系统果然尝试读取uEnv.txt并且成功启动了kernel，但依然会在启动时崩溃，因为找不到可以挂载的文件系统。自己检查log，发现uboot给的启动参数为<code>root=PARTUUID=${uuid} rw</code>，这里的UUID又是通过<code>finduuid=part uuid mmc ${bootpart} uuid\0</code>来获取的。不知道为什么我编译出来的这一套系统在BeagleBoneBlack上可以正确得到uuid，在我工作的板子上却不行。由于时间关系，原因我没有深究下去，大概还是因为缺少EEPROM的缘故吧。我决定修改uboot来绕过这个问题。为了尽量保持代码原样，我添加了一个<code>args_mmc_new</code>来作为我的启动参数：</p>
<pre><code>&quot;args_mmc_new=setenv bootargs console=ttyS0,115200n8 ${optargs} &quot;\
                &quot;root=/dev/mmcblk${mmcdev}p1 rw &quot; \
                &quot;rootfstype=${mmcrootfstype} rootwait\0&quot; \
</code></pre><p>然后在调用的地方替换原来的：</p>
<pre><code>&quot;mmcloados=run args_mmc_new; &quot; \
               &quot;if test ${boot_fdt} = yes || test ${boot_fdt} = try; then &quot; \
                       &quot;if run loadfdt; then &quot; \
                               &quot;echo debug: [${bootargs}] ... ; &quot; \
                               &quot;echo debug: [bootz ${loadaddr} - ${fdtaddr}] ... ; &quot; \
                               &quot;bootz ${loadaddr} - ${fdtaddr}; &quot; \
                       &quot;else &quot; \
                               &quot;if test ${boot_fdt} = try; then &quot; \
                                       &quot;bootz; &quot; \
                               &quot;else &quot; \
                                       &quot;echo WARN: Cannot load the DT; &quot; \
                               &quot;fi; &quot; \
                       &quot;fi; &quot; \
               &quot;else &quot; \
                       &quot;bootz; &quot; \
               &quot;fi;\0&quot; \
</code></pre><p>至此，整个系统才是真正地能够顺利跑起来。</p>
<h2 id="u81EA_u5DF1_u6DFB_u52A0USB_u542F_u52A8_u7684_u652F_u6301"><a href="#u81EA_u5DF1_u6DFB_u52A0USB_u542F_u52A8_u7684_u652F_u6301" class="headerlink" title="自己添加USB启动的支持"></a>自己添加USB启动的支持</h2><p>讲到这里，整个启动器的原理已经很清楚了。为了验证和练习，我自己照葫芦画瓢添加了一个USB启动的支持。这个support的本质跟emmc启动是一样的，只是系统的数据被烧写在USB上（不包括uboot），这样也相当于我变相做了一个不带bootloader的TF卡系统，能够更加方便地调试kernel了。毕竟可以在PC上对系统内容进行修改，万一把系统玩坏了，还能随时修复不用麻烦地重新烧写。<br>首先是在<code>include/configs/am335x_evm.h</code>文件中添加USB启动的选项：</p>
<pre><code>#define BOOT_TARGET_DEVICES(func) \
    func(LEGACY_USB, legacy_usb, 0) \
    func(LEGACY_MMC, legacy_mmc, 1) \
    func(LEGACY_MMC, legacy_mmc, 0)
</code></pre><p>然后仿照EMMC定义USB的启动函数表：</p>
<pre><code>#define BOOTENV_DEV_LEGACY_USB(devtypeu, devtypel, instance) \
    &quot;bootcmd_&quot; #devtypel #instance &quot;=&quot; \
    &quot;setenv usbdev &quot; #instance&quot;; &quot;\
    &quot;setenv bootpart &quot; #instance&quot;:1 ; &quot;\
    &quot;run usbboot\0&quot;
</code></pre><p>最后在<code>include/configs/ti_armv7_common.h</code>添加USB启动的函数：</p>
<pre><code>#define DEFAULT_USB_TI_ARGS \
    &quot;usbdev=0\0&quot;\
    &quot;args_usb=setenv bootargs console=ttyS0,115200 ${optargs} &quot; \
            &quot;root=/dev/sda1 rw &quot; \
            &quot;rootfstype=ext4 rootwait\0&quot; \
    &quot;usbboot=usb reset; &quot; \
            &quot;setenv devnum ${usbdev}; &quot; \
            &quot;setenv devtype usb; &quot; \
            &quot;if usb start; then &quot; \
                    &quot;echo USB device found on device ${usbdev}:${bootpart};&quot; \
                    &quot;if run loadbootenv; then &quot; \
                            &quot;echo Loaded env from ${bootenvfile};&quot; \
                            &quot;run importbootenv;&quot; \
                    &quot;fi;&quot; \
            &quot;echo debug: Get info=[${uname_r} ${bootfile} ${fdtfile}] ... ; &quot; \
            &quot;if run loadimage; then &quot; \
                    &quot;run args_usb; &quot; \
                    &quot;echo debug: [${bootargs}] ... ; &quot; \
                    &quot;if run loadfdt; then &quot; \
                            &quot;echo debug: [bootz ${loadaddr} - ${fdtaddr}] ... ; &quot; \
                            &quot;bootz ${loadaddr} - ${fdtaddr}; &quot; \
                    &quot;else &quot; \
                            &quot;echo WARN: Cannot load the DT; &quot; \
                    &quot;fi; &quot; \
            &quot;fi;&quot; \
    &quot;fi;\0&quot; \
</code></pre><p>大功告成！😊</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面说了那么多，系统已经烧写完毕，按理说没什么问题了，但是我的系统依然跑不起来！通过debug发现，我的kernel镜像按照debian文件系统的要求重命名成了”vmlinuz-XXX”，但我的烧写进去的uboot却在打印信息中明确表示：我找的是zImage！在BeagleBoneBlack的TF卡烧写启动模式中，它的kernel也是修改了命名，但却能顺利引导，是因为把kernel的文件名信息写入了uEnv.txt文件，但是为什么在我的板子上就会失败呢？]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（六）烧写系统到emmc]]></title>
    <link href="http://conanwhf.github.io/2017/06/14/bootup-6-flasher/"/>
    <id>http://conanwhf.github.io/2017/06/14/bootup-6-flasher/</id>
    <published>2017-06-14T04:31:26.000Z</published>
    <updated>2017-06-14T11:31:31.000Z</updated>
    <content type="html"><![CDATA[<p>能够从Uart把系统跑起来，基本上已经完成了移植工作的关键。但此时自动的引导流程还没有建立好，要想让系统能正常启动，必须将数据烧写到存储设备里去。烧写的原理对于所有的板子都是一样的，只是烧写数据的来源和目标有区别，掌握原理以后就可以自己灵活修改，不用拿着从ftp烧写的脚本对着USB烧写的需求一筹莫展。:-) <a id="more"></a><br> </p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/06/14/bootup-6-flasher/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/06/14/bootup-6-flasher/'>ARM板移植Linux系统启动（六）烧写系统到emmc</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
<h2 id="BeagleBoneBlack_u7684_u70E7_u5199"><a href="#BeagleBoneBlack_u7684_u70E7_u5199" class="headerlink" title="BeagleBoneBlack的烧写"></a>BeagleBoneBlack的烧写</h2><p>BeagleBoneBlack支持外部TF卡(emmc)烧写系统。它的流程是启动时长按某个button进入TF启动模式，然后修改init命令行参数让系统重新启动后自动运行烧写脚本。这个过程其实分几个步骤：</p>
<ol>
<li>按住button调整启动模式。BeagleBoneBlack有两种顺序不同的启动模式：｛SPI0，MMC0，USB0，UART0｝和｛MMC1，MMC0，UART0，USB0｝，按下时进入第二种模式。TF卡是外接在MMC1上，即意味着按下button时优先启动TF卡上的系统。<strong>注意这里的MMC0和MMC1是硬件意义上的，与进入系统后的设备结点mmc0,mmc1没有对应关系，可以不同。</strong></li>
<li>BootROM在TF卡上寻找到uboot数据，进入uboot；然后uboot引导卡上的kernel，进入系统。</li>
<li>如果此时的init参数已经修改，则自动运行init指定的脚本，进行烧写系统的工作。</li>
<li>烧写完毕，系统自动断电，等待重新上电启动。</li>
</ol>
<p>从这个过程我们可以推理出几件事：</p>
<ul>
<li>因为引导系统的uboot也是来自于外部TF卡，这种烧写方法可以用在完全被破坏的无法启动的板子上，例如板载emmc被彻底擦除干净的设备。这就意味着你可以随意折腾你的板载系统，不用害怕，TF卡烧写是一种有效的救援措施</li>
<li>官方的烧写教程是让我们enable uEnv.txt中的一行代码<code>cmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh</code>，这个flasher-v3.sh就是官方的烧写脚本。进入系统后手动运行效果也是一样的</li>
<li>从整个引导的过程来看，MMC0和MMC1的启动没有区别，所以实际上我们可以制作自己的TF卡系统而不是只局限于烧录，便于调试和使用（像RasspberryPi那样，换一张卡换个系统，甚至可以跑Windows），并且emmc是可读写的，修改的任何数据都会保留，不会重启消失</li>
<li>我们同样可以修改flasher-v3.sh，来完成自己的需求<br>关于怎么玩BeagleBoneBlack，不是这篇文章的讨论重点，我只是为了弄清楚BeagleBoneBlack的烧写机制以为己用。TF卡烧写很好用，可惜我的板子没有TF卡。:(</li>
</ul>
<h2 id="u70E7_u5199_u524D_u7684_u51C6_u5907"><a href="#u70E7_u5199_u524D_u7684_u51C6_u5907" class="headerlink" title="烧写前的准备"></a>烧写前的准备</h2><ol>
<li>编译kernel， uboot，获得zImage, MLO, u-boot.img等binary</li>
<li>准备一个根文件系统，通常Linux发行版会提供一个小型的文件系统，将Kernel镜像（一般放在/boot下），以及编译出来的驱动等等更新，打包并压缩。</li>
<li>编写合适的烧写脚本，等下会详细介绍。</li>
<li>确定你能进入console，并且在console里能access上面所提到的文件和脚本。</li>
<li>将准备好的文件拷贝进某个存储介质，例如USB，或者放在服务器端等待tftp获取。</li>
</ol>
<h2 id="u70E7_u5199_u6D41_u7A0B"><a href="#u70E7_u5199_u6D41_u7A0B" class="headerlink" title="烧写流程"></a>烧写流程</h2><p>flasher-v3.sh整个脚本很长，用的各种判断和变量也非常多，刚开始读难免眼花缭乱。我基于这个脚本，根据自己的需要，重新写了一份。文件系统烧写的原理都是一样：将存放源数据的设备挂载成文件夹A，将烧写的目标设备挂载成文件夹B，然后读取A中的数据解压，将文件系统写入B中。而对于bootloader的情况就比较复杂，他们的数据写入通常是不基于文件系统的，而写入的位置必须跟BootROM相对应，需要阅读厂商的文档。<br>我做的项目不是开源，所以无法发布完整的烧写脚本，读者可以根据大致流程自行编写。</p>
<h3 id="u53D8_u91CF_u5B9A_u4E49"><a href="#u53D8_u91CF_u5B9A_u4E49" class="headerlink" title="变量定义"></a>变量定义</h3><pre><code>source=&quot;/dev/sda1&quot;
destination=&quot;/dev/mmcblk1&quot;
src=&quot;/tmp/usb/&quot;
dst=&quot;/tmp/dst/&quot;
spl_file=&quot;${src}/MLO&quot;
uboot_file=&quot;${src}/u-boot.img&quot;
rootfs_file=&quot;${src}/rootfs.tar.gz&quot;
boot_label=&quot;TEST&quot;
boot_fstype=ext3
</code></pre><p>这里定义几个全局变量方便使用，分别是数据源和目标设备的设备结点和挂载点，以及一些文件名的定义。读者可以根据需要自行修改，例如mmcblk1换成sdc1，或者从TF烧写而不是USB的时候将sda1换成mmcblk0p1等等。</p>
<h3 id="u70E7_u5199bootloader_uFF08uboot_uFF09"><a href="#u70E7_u5199bootloader_uFF08uboot_uFF09" class="headerlink" title="烧写bootloader（uboot）"></a>烧写bootloader（uboot）</h3><p>bootloader的烧写包括两个文件：MLO和u-boot.img，烧写是直接使用dd写入数据，参数来自TI官方release。</p>
<pre><code># 烧写之前先擦除整块emmc
echo &quot;Erasing: ${destination} any partion information&quot;
dd if=/dev/zero of=${destination} bs=1M count=20
sync

# 烧写SPL和uboot
spl_opt=&quot;count=1 seek=1 conv=notrunc bs=128k&quot;
uboot_opt=&quot;count=2 seek=1 conv=notrunc bs=384k&quot;

echo &quot;dd if=${spl_file} of=${destination} ${spl_opt}&quot;
dd if=${spl_file} of=${destination} ${spl_opt}

echo &quot;dd if=${uboot_file} of=${destination} ${uboot_opt}&quot;
dd if=${uboot_file} of=${destination} ${uboot_opt}
</code></pre><h3 id="u5BF9_u70E7_u5199_u7684_u76EE_u6807_u8BBE_u5907_u5206_u533A"><a href="#u5BF9_u70E7_u5199_u7684_u76EE_u6807_u8BBE_u5907_u5206_u533A" class="headerlink" title="对烧写的目标设备分区"></a>对烧写的目标设备分区</h3><p>过去，kernel的镜像文件的数据是不基于文件系统的，也就是并非以一个文件的形式存放在某个目录里，因为那时的uboot并没有文件系统的支持，只能从固定的块、页、扇区读取数据。后来特别是EFI被广泛运用后，将关键的文件系统相关数据写在一个单独的Fat32分区中成了一种普遍的方案，通常会将它们只读挂载在/boot下，系统数据和各种库文件是分开的，日常使用更加安全。而现在，uboot支持了更多的文件系统，也就使得我们可以将所有数据都放在一起，怎么设计这些分区，也就更加随意和灵活。TI所用的脚本中，就有了两种选择：fat+ext4或者整个emmc只有一个ext4分区。在这块板子上我选择了后面的方案，方便后期的开发和调试，烧写方案也比较简洁。<br>烧写的工具使用的是sfdisk，请确保你的最小系统中包含这个工具。</p>
<pre><code># 参数变量设置
sfdisk_options=&quot;--force --Linux --in-order --unit M&quot;
sfdisk_boot_startmb=1
sfdisk_fstype=&quot;L&quot;

# 使用sfdisk分区
test_sfdisk=$(LC_ALL=C sfdisk --help | grep -m 1 -e &quot;--in-order&quot; || true)
if [ &quot;x${test_sfdisk}&quot; = &quot;x&quot; ] ; then
    echo &quot;sfdisk: [2.26.x or greater]&quot;
    if [ &quot;x${bootrom_gpt}&quot; = &quot;xenable&quot; ] ; then
        sfdisk_options=&quot;--force --label gpt&quot;
    else
        sfdisk_options=&quot;--force&quot;
    fi
    sfdisk_boot_startmb=&quot;${sfdisk_boot_startmb}M&quot;
fi
echo &quot;sfdisk: [$(LC_ALL=C sfdisk --version)]&quot;
echo &quot;sfdisk: [sfdisk ${sfdisk_options} ${destination}]&quot;
echo &quot;sfdisk: [${sfdisk_boot_startmb},${sfdisk_boot_endmb},${sfdisk_fstype},*]&quot;

LC_ALL=C sfdisk ${sfdisk_options} &quot;${destination}&quot; &lt;&lt;-__EOF__
    ${sfdisk_boot_startmb},,${sfdisk_fstype},*
__EOF__
</code></pre><p>分区完毕，将分区格式化为ext3，然后就可以往里面写数据了。</p>
<pre><code>echo &quot;mkfs.${boot_fstype} ${destination}p1 -L ${boot_label}&quot;
mkfs.${boot_fstype} ${destination}p1 -L ${boot_label}
sync
</code></pre><h3 id="u70E7_u5199_u6587_u4EF6_u7CFB_u7EDF"><a href="#u70E7_u5199_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="烧写文件系统"></a>烧写文件系统</h3><p>文件系统的烧写实际上就是数据拷贝的过程。在TI的TF卡烧写方式中，是将当前系统（也就是TF卡上的系统）的所有文件都拷贝到目标文件夹，再进行一定的动态支持处理，我这里是直接将准备好的文件系统包解压到对应的地方。首先挂载分区：</p>
<pre><code>#mount emmc partition
mkdir -p $dst
mount ${destination}p1 $dst -o async,noatime
is_mounted=$(grep ${destination}p /proc/mounts | awk &apos;{print $2}&apos;)
if grep -q ${destination}p /proc/mounts; then
        echo &quot;Found mounted partition(s) on &quot; ${destination}&quot;: &quot; $is_mounted
else
        echo &quot;No eMMC partition found. exit.&quot;
        exit
fi
</code></pre><p>然后将数据解压，并做一点点小的处理，确保login系统的正常运行：</p>
<pre><code>cd $dst
tar xzvf $rootfs_file
cd - 

if [ -d $dst/etc/ssh/ ] ; then
    #ssh keys will now get regenerated on the next bootup
    touch $dst/etc/ssh/ssh.regenerate
    sync
fi
</code></pre><p>最后将挂载点umount，完成全部烧写工作：  </p>
<pre><code>umount $dst || umount -l $dst
dd if=${destination} of=/dev/null count=100000
sync
echo &quot;Syncing: ${destination} complete&quot;
</code></pre><p>至此，全部烧写完毕，板子应该能顺利地跑起来了，开机试试吧！:-)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>能够从Uart把系统跑起来，基本上已经完成了移植工作的关键。但此时自动的引导流程还没有建立好，要想让系统能正常启动，必须将数据烧写到存储设备里去。烧写的原理对于所有的板子都是一样的，只是烧写数据的来源和目标有区别，掌握原理以后就可以自己灵活修改，不用拿着从ftp烧写的脚本对着USB烧写的需求一筹莫展。:-)]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（五）Uboot命令行]]></title>
    <link href="http://conanwhf.github.io/2017/06/13/bootup-5-ubootcmd/"/>
    <id>http://conanwhf.github.io/2017/06/13/bootup-5-ubootcmd/</id>
    <published>2017-06-13T09:31:26.000Z</published>
    <updated>2017-06-13T17:02:15.000Z</updated>
    <content type="html"><![CDATA[<p>上次说到uboot的启动方式，最后会使用autoboot尝试引导kernel，如果失败或者被手动取消，则进入uboot的命令行。最新的uboot命令行已经发展得比较完善，很大程度上接近shell，包含了各种基本的驱动和完整的工具。这些工具的源码大多在<code>u-boot/cmd</code>下，查看Makefile可以看到，根据不同的配置编译出很多命令，你也可以通过搜索字符串<code>U_BOOT_CMD(</code>来查找这些命令的命名。这些命令的列表可以通过命令行输入<code>help</code>来查看，大致分成几个大类。<a id="more"></a><br></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/06/13/bootup-5-ubootcmd/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/06/13/bootup-5-ubootcmd/'>ARM板移植Linux系统启动（五）Uboot命令行</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
<h2 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h2><p>以boot开头的命令，围绕引导kernel的启动过程，有<strong>boot, bootm, bootz, bootefi, bootp</strong>等等。这其中boot和bootd只是重复调用了autoboot的过程，适用于手动设置参数后启动的情况；其他的boot命令，则适用于不同kernel镜像数据来源。</p>
<h3 id="bootm_2C_bootz_2C_booti"><a href="#bootm_2C_bootz_2C_booti" class="headerlink" title="bootm, bootz, booti"></a>bootm, bootz, booti</h3><p>这几个都是从内存中的某个地址获得kernel image。bootz是启动zImage，而bootm和booti是启动uImage，其中booti专门用来启动ARM64的kernel image。<br>它们的基本语法是：<code>bootX &lt;kernel address&gt; &lt;rootdisk address&gt; &lt;fdt(dts file) address&gt;</code>，这里的address都是指内存的物理地址，需要提前把image和file加载到内存中，其中根文件系统的地址可以省略（包含在kernel image中），用<strong>-</strong>来代替。<br>在常规的启动引导过程中，uboot的各种启动方式实际上最后都是调用<strong>bootz</strong>的，但之前会设置很多环境变量作为启动的参数。在调试过程中，我们也同样可以手动设置好参数，直接用bootX系列来启动系统。</p>
<h3 id="bootefi_2C_bootp_2C_nboot"><a href="#bootefi_2C_bootp_2C_nboot" class="headerlink" title="bootefi, bootp, nboot"></a>bootefi, bootp, nboot</h3><p>这三个命令用于不同来源的kernel image，一个来自efi分区中的启动image，一个来自于网络，一个来自nand flash。它们只是比bootz多了一步加载行为，即将kernel image从某个设备拷贝到内存中，本质上是一样的。类似的命令还有<strong>tftpboot, usbboot, dhcp, nfs, rarpboot</strong>等。</p>
<p>其他boot系的命令也是大同小异，通过help能够看到对应的说明，需要自己根据情况选择使用。</p>
<h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>uboot的环境变量跟shell的很相似，是存放在内存中的一些字符串。一个完整的evn包括名字(name)和值(value)，可以通过<code>$XXXX</code>来完成嵌套和调用。它们服务于最后的boot行为，用来定义启动过程中的各种顺序、参数、路径、IP地址等等，你可以通过<code>printenv</code>来查看当前所有的环境变量。 </p>
<ul>
<li><code>askenv &lt;name&gt;</code>：查询某个变量的值</li>
<li><code>editenv &lt;name&gt;</code>：修改某个变量的值，一般用于比较value比较长的情况</li>
<li><p><code>saveenv</code>：将所有环境变量保存在存储装置中。这个装置可以是nand flash, nor flash, 或者EEPROM，由uboot的源码来定义存储的位置和地址等信息：</p>
<pre><code>if defined(CONFIG_ENV_IS_IN_NAND)
    #define CONFIG_ENV_OFFSET               0x001c0000
    #define CONFIG_ENV_OFFSET_REDUND        0x001e0000
    #define CONFIG_SYS_ENV_SECT_SIZE        CONFIG_SYS_NAND_BLOCK_SIZE
#elif !defined(CONFIG_ENV_IS_NOWHERE)
/* Not NAND, SPI, NOR or eMMC env, so put ENV in a file on FAT */
    #define CONFIG_ENV_IS_IN_FAT
    #define FAT_ENV_INTERFACE               &quot;mmc&quot;
    #define FAT_ENV_DEVICE_AND_PART         &quot;0:1&quot;
    #define FAT_ENV_FILE                    &quot;uboot.env&quot;
#endif/
define CONFIG_ENV_SIZE     (128 &lt;&lt; 10)
</code></pre></li>
<li><code>setenv &lt;name&gt; &lt;value&gt;</code>：修改某个变量的值，如果value为空则表示删除这个变量</li>
</ul>
<h3 id="u5E38_u7528_u7684_u73AF_u5883_u53D8_u91CF"><a href="#u5E38_u7528_u7684_u73AF_u5883_u53D8_u91CF" class="headerlink" title="常用的环境变量"></a>常用的环境变量</h3><p>在调试中，特别是网络调试中，环境变量的设置很重要。一般的网络操作包括ping, boot等等都需要事先设定好正确的环境变量。这里列举几个常用的：</p>
<ul>
<li>baudrate，串口控制台的波特率</li>
<li>netmask，网络掩码</li>
<li>ethaddr，MAC地址</li>
<li>serverip &amp; ipaddr，TFTP服务器端的IP地址以及本地的IP地址</li>
<li>bootfile，默认的启动文件名，在网络启动模式中也是默认的下载文件名</li>
<li>bootargs，传递给Linux内核的启动参数</li>
<li>fdtfile &amp; fdtaddr，dts文件默认文件名以及load的内存地址</li>
</ul>
<h2 id="u5916_u90E8_u8BBE_u5907"><a href="#u5916_u90E8_u8BBE_u5907" class="headerlink" title="外部设备"></a>外部设备</h2><p>uboot自带很多外设的驱动，包括USB，MMC，Nand，Nor，GPIO，SPI，MII，I2C……具体的使用帮助可以通过<code>help &lt;tool&gt;</code>来查看。例如USB，在插入U盘的情况下，使用<code>usb start</code>便能看到有partition被检测到，接下来可以通过文件系统的支持来读取和查看U盘上的文件和目录。</p>
<h2 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h2><p>我使用的这个uboot version为2017.03版本，其中已经包含了对fat, ext(2,3,4), cramfs, cbfs, jffs2, ubifs, yaffs2,zfs, reiserfs等相当多的文件系统支持。这其中用得最多的应该是fat和extX了。以fat为例，几个最重要的命令如下：</p>
<ul>
<li><code>fatinfo &lt;interface&gt; &lt;dev[:part]&gt;</code>：显示某个设备或分区的信息，如<code>fatinfo mmc 0</code></li>
<li><code>fatload &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; [bytes]</code>：将某个文件前X byte加载到指定的内存地址中，最后一个参数为空时加载整个文件，如<code>fatload usb 0:1 zImage 0x80000000</code>会把U盘上的zImage拷贝到内存的0x80000000处</li>
<li><code>fatls  &lt;interface&gt; &lt;dev[:part]&gt; [directory]</code> ：读取并打印目录中的文件列表，如<code>fatls mmc 1:1</code>会打印mmc1 partition1的根目录文件列表</li>
<li><code>fatwrite &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; [bytes]</code>：将指定内存开始的X byte保存为文件，如<code>fatwrite mmc 0:1 0x80000000 img 0x1000</code>会将内存0x80000000起始的4K数据保存在emmc0的第一个分区<br>其他几个不同的文件系统的工具可照葫芦画瓢。<br>文件系统的支持不但意味着在uboot命令行我们可以手动进行文件的读写，还意味着在启动阶段，uboot可以从支持的文件系统分区中读取相应的数据，也就是说，从一个ext4的partition找到zImage并启动是可行的。这给我们配置启动参数以更大的灵活性和可定制性，从TF等设备启动系统也是基于这样的支持。</li>
</ul>
<h2 id="u83B7_u53D6_u6570_u636E_u548C_u5904_u7406"><a href="#u83B7_u53D6_u6570_u636E_u548C_u5904_u7406" class="headerlink" title="获取数据和处理"></a>获取数据和处理</h2><p>uboot关于数据的处理都是基于物理地址的，除了source和destination的地址，还有一种长度参数length，表示按照字节、字、长来处理内存数据。其中.b以字节为单位；.w以字为单位；.l以长字为单位。<strong>注意tool\<len\>中间不能有空格，例如需要直接输入<code>cmp.b XXX XXX XXX</code></len\></strong>。</p>
<ul>
<li><code>cmp&lt;len&gt; &lt;addr1&gt; &lt;addr2&gt; &lt;count&gt;</code>：比较addr1和add2的长度为count的（基于length计算）数据</li>
<li><code>cp&lt;len&gt; &lt;src&gt; &lt;dst&gt; &lt;count&gt;</code>：把count个数据从src复制到dst</li>
<li><code>mw&lt;len&gt; &lt;addr&gt; &lt;vaule&gt; [count]</code>：把addr开始的count个数据设为vaule</li>
<li><code>md&lt;len&gt; addr count</code>：读取并显示addr开始的数据内容</li>
<li><code>crc32 addr count res</code>：使用crc32校验addr开始的长度为count的数据，将结果存放在地址res中</li>
</ul>
<h3 id="u4ECE_u4E32_u53E3_u83B7_u53D6_u548C_u53D1_u9001_u6570_u636E"><a href="#u4ECE_u4E32_u53E3_u83B7_u53D6_u548C_u53D1_u9001_u6570_u636E" class="headerlink" title="从串口获取和发送数据"></a>从串口获取和发送数据</h3><p>在调试中经常需要从串口传输少量数据，虽然用起来比较麻烦，但有时也是必须的。跟串口传输相关的几个tool有：<br>loadb - load binary file over serial line (kermit mode)<br>loads - load S-Record file over serial line<br>loadx - load binary file over serial line (xmodem mode)<br>loady - load binary file over serial line (ymodem mode)<br>它们除了传输协议不同，别的都是一样的。一般的调用格式为：<code>loadX &lt;addr&gt; &lt;baudrate&gt;</code>，波特率一般都是115200，addr则是数据加载到的目的内存地址，默认为kernel加载地址，定义在<br><code>include/configs/ti_armv7_common.h:#define CONFIG_SYS_LOAD_ADDR        0x82000000</code><br>这几个工具的使用，因为是全命令行的，步骤比较多，但网上教程也很多，需要自查即可。</p>
<h2 id="u5176_u4ED6_u547D_u4EE4"><a href="#u5176_u4ED6_u547D_u4EE4" class="headerlink" title="其他命令"></a>其他命令</h2><p>其他还有一些普通命令，大多跟shell很像，比如<strong>ping, echo, unzip</strong>等等。不太常用，也很简单，就不啰嗦了，需要的可以自己用help看看用法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上次说到uboot的启动方式，最后会使用autoboot尝试引导kernel，如果失败或者被手动取消，则进入uboot的命令行。最新的uboot命令行已经发展得比较完善，很大程度上接近shell，包含了各种基本的驱动和完整的工具。这些工具的源码大多在<code>u-boot/cmd</code>下，查看Makefile可以看到，根据不同的配置编译出很多命令，你也可以通过搜索字符串<code>U_BOOT_CMD(</code>来查找这些命令的命名。这些命令的列表可以通过命令行输入<code>help</code>来查看，大致分成几个大类。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（四）配置Kernel]]></title>
    <link href="http://conanwhf.github.io/2017/06/12/bootup-4-kernel/"/>
    <id>http://conanwhf.github.io/2017/06/12/bootup-4-kernel/</id>
    <published>2017-06-12T09:31:26.000Z</published>
    <updated>2017-06-12T15:07:39.000Z</updated>
    <content type="html"><![CDATA[<p>如今的Linux比uboot要成熟得更多，所有的模块都是可配置的。所以基本上对于kernel的移植，特别是这种已经有基础源码的项目，代码改动其实相当少，更多是时间花在调试和配置上。在所有工作中，最主要的困难恐怕就是怎么把系统跑进console了。</p>
<h2 id="uImage__26amp_3B_zImage"><a href="#uImage__26amp_3B_zImage" class="headerlink" title="uImage &amp; zImage"></a>uImage &amp; zImage</h2><p>这个问题太基础，只是因为跟手动跑系统有关，所以稍微提一下。kernel编译后的成果是zImage，uImage只是添加了一个长度为0x40的头，用来记录给uboot的相关信息。虽然uImage是专门给uboot用的，但uboot的启动并不一定要uImage，它既可以接受uImage也可以接受zImage。可以说：uImage的头信息本质上是一种启动参数的传递形式。<br>制作uImage的工具是<strong>mkimage</strong>，它是来自于uboot。为了避免各种可能的版本问题，建议直接使用uboot编译后的<code>uboot/tools/mkimage</code>。而uImage的制作脚本则包含在kernel的编译脚本中，使用命令：<br><code>make uImage LOADADDR=0x80008000</code><br>即可编译获得uImage，前提是你已经将mkimage放入了编译环境的/bin/文件夹下。LOADADDR是kernel的启动地址（<strong>注意，这不是真正的kernel运行地址</strong>），uBoot会将kernel拷贝到此地址后（实际中也可能不拷贝）执行。关于uboot使用的几个内存地址的具体讲解也很多，这么些年也没什么变化，需要了解的可以自行去搜索。</p>
<h2 id="u6839_u6587_u4EF6_u7CFB_u7EDF_u7684_u5236_u4F5C"><a href="#u6839_u6587_u4EF6_u7CFB_u7EDF_u7684_u5236_u4F5C" class="headerlink" title="根文件系统的制作"></a>根文件系统的制作</h2><p>一个系统必须要有文件系统才能跑起来，即使是很小很小的文件系统。目前一个最基本的文件系统都是基于Busybox制作的，制作过程的教程很多也大同小异，我就不赘述了。有的厂商或者Linux系统发行商也会提供根文件系统的下载，不过大多太过冗余，需要自行裁剪。<a id="more"></a><br></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/06/12/bootup-4-kernel/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/06/12/bootup-4-kernel/'>ARM板移植Linux系统启动（四）配置Kernel</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>对于一块空板子，通常的做法是用一个能进入命令行的最小文件系统，然后将完整的文件系统和kernel等烧写到存储设备上。所以如何做一个能够启动的最小系统，就成了第一个步骤。由于这种最小系统启动时还不会用到存储装置（emmc or nand flash），文件系统是跑在RAM里的，有两种做法：将其包含在Kernel的镜像中，或者用uboot加载到内存后告诉kernel加载的内存地址。</p>
<h3 id="u5E26Ramdisk_u7684Kernel_u955C_u50CF"><a href="#u5E26Ramdisk_u7684Kernel_u955C_u50CF" class="headerlink" title="带Ramdisk的Kernel镜像"></a>带Ramdisk的Kernel镜像</h3><p>menuconfig里面配置kernel:<br>General setup  —> 选中Initial RAM filesystem and RAM disk (initramfs/initrd) support，将（）Initramfs source file(s)填写为准备好的根文件系统路径<br><img src="http://whf.d.pr/zWYCTN+" alt=""><br>保存，编译后即可。</p>
<h3 id="U-boot_u652F_u6301_u7684rootfs_u955C_u50CF"><a href="#U-boot_u652F_u6301_u7684rootfs_u955C_u50CF" class="headerlink" title="U-boot支持的rootfs镜像"></a>U-boot支持的rootfs镜像</h3><p>另一种方法是使用单独的根文件系统镜像，这样不需要重新编译kernel，只需要把数据重新打包即可。</p>
<ol>
<li><p>生成空白Image，可以稍微预留大一点，全0数据压缩后可以忽略：</p>
<pre><code>dd if=/dev/zero of=TEMP bs=1M count=5
</code></pre></li>
<li><p>将image挂载为loop文件系统</p>
<pre><code>losetup /dev/loop0 TEMP
sudo mke2fs -m 0 /dev/loop0
mkdir -p loop 
sudo mount -t ext2 /dev/loop0 loop
</code></pre></li>
<li><p>将数据copy到挂载后的image中，然后卸载：</p>
<pre><code>sudo cp -raf initramfs/* loop
sudo umount loop; rm -rf loop
</code></pre></li>
<li><p>压缩并制作成img:</p>
<pre><code>gzip -v9 TEMP
mkimage -n &apos;YOUR_MARK ext2 uboot ramdisk&apos; -A arm -O linux -T ramdisk -C gzip -d TEMP.gz ramdisk.img
</code></pre><p>这里的mkimage就是上文提到的来自于uboot的工具，它同样也只是将已有的文件加了一个uboot可以识别的头信息。注意这里的<code>-A arm</code>必须和kernel的目标平台相对应，否则uboot会拒绝引导。</p>
</li>
</ol>
<h2 id="DTS_28Device_Tree_Source_29"><a href="#DTS_28Device_Tree_Source_29" class="headerlink" title="DTS(Device Tree Source)"></a>DTS(Device Tree Source)</h2><p>在老的内核版本中，关于硬件的定义、配置和描述都是通过各种头文件和<code>#define</code>来实现的，而在新的内核中已经全部使用了DTS来描述硬件信息，从而实现了更加灵活的硬件支持和配置。DTS中的“硬件描述”，准确地说是设备描述，包括所有的硬件设备和软件设备节点，从CPU到外设，从型号描述到地址定义，具体到设备节点到硬件的链接等等，都可以定义。<br>DTS的具体表达文件是<code>*.dtb</code>，它们是由一组遵循特定语法的dts源文件编译而成，放在<code>arch/$PLATFORM/boot/dts</code>下，对于arm板来说就是<code>arch/arm/boot/dts/</code>。这个文件夹底下的文件有点像config file，每个<code>*.dts</code>文件对应一种配置，而dts文件又可以通过include某些<code>$SLICON.dtsi</code>来作为配置的基础，在此基础上添加、覆盖原有内容。一个dts一般只对应一种板子，但同一块板子可以使用几种不同的dts，例如可以通过指定不同的dtb文件，来选择启动时将HDMI还是LCD屏作为标准输出（lcdc0）。以BeagleBoneBlack举例，它的基本启动配置是am335x-boneblack.dts，而它又inlcude了am33xx.dtsi, am335x-bone-common.dtsi, am33xx-pruss-rproc.dtsi等文件。<br>查找编译所对应的dts file，可以查看<code>arch/arm/boot/dts/Makefile</code>，看看kernel config里定义的<code>CONFIG_SOC_XXX</code>所对应编译出来的dtb文件。一般来说一个芯片下有好几个dtb文件，它们就是对应了不同的应用场景，需要根据需要选择一个来作为启动配置。如果需要添加自己的dts文件，除了新建一个dts文件以外，还要记得在这个Makefile中把自己的target dtb添加进去。<br>关于DTS设备定义的语法，也不是这篇文章的重点，请允许我跳过。</p>
<h3 id="u4F7F_u7528DTS_u542F_u52A8_u7CFB_u7EDF"><a href="#u4F7F_u7528DTS_u542F_u52A8_u7CFB_u7EDF" class="headerlink" title="使用DTS启动系统"></a>使用DTS启动系统</h3><p>之前我并没有使用过DTS，对它也只有耳闻，所以开始移植的时候并没有想到这个部分。做好了kernel在uboot中手动引导启动后，我发现系统停在了<code>Starting kernel ...</code>这样的打印信息之后。经过搜索资料，我发现很有可能是因为uboot和kernel的机器号(Mechine ID)不匹配，为了确定这个问题，我在kernel config中打开low-level的调试选项：</p>
<blockquote>
<p>Kernel hacking  —><br>|- (X) Kernel low-level debugging functions (read help!)<br>-|— Kernel low-level debugging port (Kernel low-level debugging…   —><br>—- |- ( ) Kernel low-level debugging messages via OMAP36XX UART4<br>—- |- ( ) Kernel low-level debugging messages via OMAP4/5 UART4<br>—- |- ( ) Kernel low-level debugging messages via TI81XX UART1<br>—- |- ( ) Kernel low-level debugging messages via TI81XX UART2<br>—- |- ( ) Kernel low-level debugging messages via TI81XX UART3<br>—- |- (X) Kernel low-level debugging messages via AM33XX UART1<br>|- (X) Early printk</p>
</blockquote>
<p>记得选对UART驱动，不然是看不到打印的。这个驱动不是在kernel的drivers里面配置对了就可以的，driver里面的驱动要等基本的项目初始化后才会跑，这里指的是提前初始化UART以提供打印的驱动程序。<br>然后再次尝试，看打印信息果然是这个原因，但奇怪的是，在aviliable mechine的list里面，只有一个0xFFFFFFFF的mechine ID。我跟踪了很久的kernel和uboot代码，还是对此一筹莫展，直到再次搜索了类似的情况，发现有人说使用新版本的kernel才会出现这种情况，才想到了是没有使用DTS的原因。<br>于是我添加了对dts文件的地址指定：</p>
<pre><code>fatload usb 0:1 0x82000000 am335x-boneblack.dtb
fatload usb 0:1 0x83000000 uImage
bootm 0x83000000 - 0x82000000
</code></pre><p>这次uboot将dtb加载并传递了地址给kernel，kernel能够看到所需要的各种初始化信息，终于顺利地将系统跑了起来。</p>
<h2 id="u7F16_u8BD1_u540E_u7684_u6587_u4EF6location"><a href="#u7F16_u8BD1_u540E_u7684_u6587_u4EF6location" class="headerlink" title="编译后的文件location"></a>编译后的文件location</h2><p>至此，系统已经能够跑进console，剩下的就是引导和烧写问题了。编译后的相关文件location如下，在制作文件系统时需要将它们更新至软件包中：</p>
<ul>
<li>kernel: ./boot/zImage</li>
<li>dts: ./boot/dst/XXX.dtb</li>
<li>firmware: ./lib/firmware/</li>
<li>module:/lib/modules/$KERNEL_VERSION</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>如今的Linux比uboot要成熟得更多，所有的模块都是可配置的。所以基本上对于kernel的移植，特别是这种已经有基础源码的项目，代码改动其实相当少，更多是时间花在调试和配置上。在所有工作中，最主要的困难恐怕就是怎么把系统跑进console了。</p>
<h2 id="uImage__26amp_3B_zImage"><a href="#uImage__26amp_3B_zImage" class="headerlink" title="uImage &amp; zImage"></a>uImage &amp; zImage</h2><p>这个问题太基础，只是因为跟手动跑系统有关，所以稍微提一下。kernel编译后的成果是zImage，uImage只是添加了一个长度为0x40的头，用来记录给uboot的相关信息。虽然uImage是专门给uboot用的，但uboot的启动并不一定要uImage，它既可以接受uImage也可以接受zImage。可以说：uImage的头信息本质上是一种启动参数的传递形式。<br>制作uImage的工具是<strong>mkimage</strong>，它是来自于uboot。为了避免各种可能的版本问题，建议直接使用uboot编译后的<code>uboot/tools/mkimage</code>。而uImage的制作脚本则包含在kernel的编译脚本中，使用命令：<br><code>make uImage LOADADDR=0x80008000</code><br>即可编译获得uImage，前提是你已经将mkimage放入了编译环境的/bin/文件夹下。LOADADDR是kernel的启动地址（<strong>注意，这不是真正的kernel运行地址</strong>），uBoot会将kernel拷贝到此地址后（实际中也可能不拷贝）执行。关于uboot使用的几个内存地址的具体讲解也很多，这么些年也没什么变化，需要了解的可以自行去搜索。</p>
<h2 id="u6839_u6587_u4EF6_u7CFB_u7EDF_u7684_u5236_u4F5C"><a href="#u6839_u6587_u4EF6_u7CFB_u7EDF_u7684_u5236_u4F5C" class="headerlink" title="根文件系统的制作"></a>根文件系统的制作</h2><p>一个系统必须要有文件系统才能跑起来，即使是很小很小的文件系统。目前一个最基本的文件系统都是基于Busybox制作的，制作过程的教程很多也大同小异，我就不赘述了。有的厂商或者Linux系统发行商也会提供根文件系统的下载，不过大多太过冗余，需要自行裁剪。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（三）UBOOT移植]]></title>
    <link href="http://conanwhf.github.io/2017/06/09/bootup-3-uboot/"/>
    <id>http://conanwhf.github.io/2017/06/09/bootup-3-uboot/</id>
    <published>2017-06-09T09:31:26.000Z</published>
    <updated>2017-06-14T10:41:25.000Z</updated>
    <content type="html"><![CDATA[<p>经过这些年的演变，U-boot已经从一个简单的loader慢慢发展成了一个小小系统，硬件上原生支持各种平台、外设，软件上支持Fat&amp;ext234等文件系统、传输协议、测试工具，可以说相当完善了。这种进化，负面影响是让整体变得更复杂臃肿，但也有更多的正面影响，是让我们的移植工作更加简单、模块化。</p>
<h2 id="Uboot_u4EE3_u7801_u7ED3_u6784"><a href="#Uboot_u4EE3_u7801_u7ED3_u6784" class="headerlink" title="Uboot代码结构"></a>Uboot代码结构</h2><p>代码结构是了解uboot的基础，作为一个成熟的开源软件，uboot的代码结构很清晰。绝大多数的代码都是通用的，所以在移植过程中，基本上只需要找到自己的对应平台，修改板子特有的部分即可。<a id="more"></a><br></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/06/09/bootup-3-uboot/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/06/09/bootup-3-uboot/'>ARM板移植Linux系统启动（三）UBOOT移植</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>├── api                uboot提供的API接口<br>├── arch               与体系结构相关的代码<br>│   ├── arm<br>│   │   ├── mach-omap2  BeagleBoneBlack使用的架构<br>│   ├── x86<br>├── board              根据不同的具体开发板而定制的代码<br>│   ├── ti             厂商：TI<br>│   │   ├── am335x     BeagleBoneBlack使用的平台，主要的改动应该在这里，包括内存初始化<br>│   │   ├── beagle<br>│   │   ├── common<br>│   │   ├── evm<br>├── cmd                通用命令行处理工具<br>├── common             通用核心代码，主要给uboot使用，部分SPL<br>│   ├── spl            SPL的通用代码<br>├── configs            配置文件<br>├── disk               磁盘分区相关<br>├── doc                文档<br>├── drivers            各种驱动，uboot使用<br>├── dts                dtb文件的编译脚本<br>├── examples           范例<br>├── fs                 文件系统代码<br>├── include            公用头文件<br>│   ├── configs        不同板子配置选项的头文件<br>├── lib                通用库<br>├── net                网络相关<br>├── post               Power On Self Test，开机自检程序<br>├── scripts            编译脚本<br>├── test               测试程序<br>├── tools              相关小工具<br>如果是想要重新编译和优化uboot，那么通常修改配置文件即可；如果是一块硬件上有修改的板子，那么则需要另外关注board/XXX/部分，基于原有的初始化代码进行修改；如果是完全新设计的芯片，则必须根据芯片不同模块的datasheet自己添加一套初始化代码，只有arm平台的一些基本内容可以通用了。</p>
<h2 id="u542F_u52A8_u6D41_u7A0B"><a href="#u542F_u52A8_u6D41_u7A0B" class="headerlink" title="启动流程"></a>启动流程</h2><p>前一篇讲SPL的启动的时候提到，最初从<code>start.S</code> call到了<code>crt0.S</code>。<code>crt0.S</code>会先后调用<code>board_init_f()</code>和<code>board_init_r()</code>两个函数，当作为SPL编译时<code>board_init_f()</code>是直接返回的，而在uboot时是有用的。大致上来说，<code>board_init_f()</code>侧重于基础硬件的初始化，以及软件堆栈等方面的准备，更底层一点；而<code>board_init_r()</code>则更多的是软件方面的初始化，并且最终完成uboot启动过程或进入命令行。</p>
<h3 id="common/board_f-c"><a href="#common/board_f-c" class="headerlink" title="common/board_f.c"></a><code>common/board_f.c</code></h3><p>这是uboot(实际上是uboot第二阶段，<strong>u-boot.img</strong>所包含的内容，下文不再区分)的入口函数<code>board_init_f()</code>所在的文件。可以看到函数<code>board_init_f()</code>很简单，初始化全局变量后，就根据一个<code>init_sequence_f</code>依次运行不同的函数，失败则把系统hang住，成功当然就是进入正常的启动流程中去了。<code>init_sequence_f</code>在同一个文件中也有定义，很长，我删减无关平台的内容大致看看：</p>
<pre><code>static init_fnc_t init_sequence_f[] = {
//==========基本数据init，malloc数据块
    setup_mon_len,
#ifdef CONFIG_OF_CONTROL
    fdtdec_setup,
#endif
#ifdef CONFIG_TRACE
    trace_early_init,
#endif
    initf_malloc,
    initf_console_record,
//初始化CPU
    arch_cpu_init,      /* basic arch cpu dependent setup */
    mach_cpu_init,      /* SoC/machine dependent CPU setup */
    initf_dm,
    arch_cpu_init_dm,
    mark_bootstage,     /* need timer, go after init dm */
#if defined(CONFIG_BOARD_EARLY_INIT_F)
    board_early_init_f,
#endif
//==========Timer
#if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \
        defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \
        defined(CONFIG_SH) || defined(CONFIG_SPARC)
    timer_init,     /* initialize timer */
#endif
//==========初始化环境变量
    env_init,       /* initialize environment */
//==========初始化串口，并打印信息
    init_baud_rate,     /* initialze baudrate settings */
    serial_init,        /* serial communications setup */
    console_init_f,     /* stage 1 init of console */
    display_options,    /* say that we are here */
    display_text_info,  /* show debugging info if required */
    print_cpuinfo,      /* display cpu info (and speed) */
#if defined(CONFIG_DISPLAY_BOARDINFO)
    show_board_info,
#endif
//==========基本外设初始化，包括I2C，SPI，WatchDog等
    INIT_FUNC_WATCHDOG_INIT
#if defined(CONFIG_MISC_INIT_F)
    misc_init_f,
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
    init_func_i2c,
#endif
#if defined(CONFIG_HARD_SPI)
    init_func_spi,
#endif
//==========内存初始化
    announce_dram_init,
    /* TODO: unify all these dram functions? */
#if defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \
        defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) || \
        defined(CONFIG_SH)
    dram_init,      /* configure available RAM banks */
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_SYS_DRAM_TEST)
    testdram,
#endif /* CONFIG_SYS_DRAM_TEST */
    INIT_FUNC_WATCHDOG_RESET
//==========一堆显示相关的初始化，略
    /*
     * Now that we have DRAM mapped and working, we can
     * relocate the code and continue running from DRAM.
     *
     * Reserve memory at end of RAM for (top down in that order):
     *  - area that won&apos;t get touched by U-Boot and Linux (optional)
     *  - kernel log buffer
     *  - protected RAM
     *  - LCD framebuffer
     *  - monitor code
     *  - board info struct
     */
//==========将环境变量重置，并打印相关信息
    setup_machine,
    reserve_global_data,
    reserve_fdt,
    reserve_arch,
    reserve_stacks,
    setup_dram_config,
    show_dram_config,
    display_new_sp,
#ifdef CONFIG_SYS_EXTBDINFO
    setup_board_extra,
#endif
    INIT_FUNC_WATCHDOG_RESET
    reloc_fdt,
    setup_reloc,
    NULL,
};
</code></pre><h2 id="common/board_r-c"><a href="#common/board_r-c" class="headerlink" title="common/board_r.c"></a><code>common/board_r.c</code></h2><p>类似的，在<code>board_init_r()</code>中也会按顺序调用这么一个函数列表，函数名都很容易看懂，具体就不列出来了。跟<code>board_init_f()</code>不同的是，它最后有一个<code>run_main_loop</code>：</p>
<pre><code>init_fnc_t init_sequence_r[] = {
    initr_trace,
    initr_reloc,
    ......
    run_main_loop,
};
</code></pre><p>这个函数会进入一个死循环，尝试自动启动系统或者进入uboot的命令行：</p>
<pre><code>static int run_main_loop(void)
{
ifdef CONFIG_SANDBOX
sandbox_main_loop_init();
endif
/* main_loop() can return to retry autoboot, if so just run it again */
for (;;)
main_loop();
return 0;
} 
</code></pre><h2 id="common/main-c"><a href="#common/main-c" class="headerlink" title="common/main.c"></a><code>common/main.c</code></h2><p>函数<code>main_loop()</code>的实现在main.c，可以看到，做好最后的准备工作后，uboot会尝试用<code>autoboot_command(s)</code>来启动kernel，如果失败，则进入<code>cli_loop()</code>函数中。</p>
<pre><code>void main_loop(void)
{
        const char *s;

        bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, &quot;main_loop&quot;);

#ifdef CONFIG_VERSION_VARIABLE
        setenv(&quot;ver&quot;, version_string);  /* set version variable */
#endif /* CONFIG_VERSION_VARIABLE */

        cli_init();

        run_preboot_environment_command();

#if defined(CONFIG_UPDATE_TFTP)
        update_tftp(0UL, NULL, NULL);
#endif /* CONFIG_UPDATE_TFTP */

        s = bootdelay_process();
        if (cli_process_fdt(&amp;s))
                cli_secure_boot_cmd(s);

        autoboot_command(s);

        cli_loop();
        panic(&quot;No CLI available&quot;);
}
</code></pre><h2 id="cli_loop_28_29"><a href="#cli_loop_28_29" class="headerlink" title="cli_loop()"></a><code>cli_loop()</code></h2><p>这个函数比较简单，追踪code可以看到，<code>common/cli.c, cli_loop()-&gt;common/cli_simple.c, cli_simple_loop()</code>， <code>cli_simple_loop()</code>就是uboot的命令行了，不断读取用户输入来做出反应，同样也是个死循环。所以绝大部分的时候，<code>main_loop()</code>中的循环并不会进行多次，而是一旦自动启动失败就进入了命令行，不会再次自动尝试启动。</p>
<h2 id="u4FEE_u6539_u79FB_u690D"><a href="#u4FEE_u6539_u79FB_u690D" class="headerlink" title="修改移植"></a>修改移植</h2><p>一般简单的板子移植，主要是内存初始化代码，和硬件配置选项，以及启动变量。硬件的驱动是不需要自己写的，但要配置准确。这些修改主要集中在两个地方：配置头文件和平台对应的board.c。以BeagleBoneBlack为例，它的特别内容都在以下两个文件中：</p>
<ul>
<li><code>board/ti/am335x/board.c</code></li>
<li><code>include/configs/am335x_evm.h</code><br>这是编译时脚本根据config中<code>CONFIG_TARGET_AM335X_EVM=y</code>来对应的，不同的平台文件会有所不同，但都可以通过查看Makefile和Kconfig来找到正确的文件。下文均以BeagleBoneBlack为例。</li>
</ul>
<h3 id="u542F_u52A8_u65B9_u5F0F"><a href="#u542F_u52A8_u65B9_u5F0F" class="headerlink" title="启动方式"></a>启动方式</h3><p>当uboot的启动流程进入到autoboot，其历史使命基本上也就完成了。但对于一个移植的板子来说，配置自动启动的选项却是一个很重要的问题。启动方式的列表定义在在<code>am335x_evm.h</code>中:</p>
<pre><code>define BOOT_TARGET_DEVICES(func) \
func(MMC, mmc, 0) \
func(LEGACY_MMC, legacy_mmc, 0) \
func(MMC, mmc, 1) \
func(LEGACY_MMC, legacy_mmc, 1) \
func(NAND, nand, 0) \
func(PXE, pxe, na) \
func(DHCP, dhcp, na)
endif
</code></pre><p>很容易看到这个启动方式是emmc,nand,PXE,DHCP，可以自己按照需要调整顺序或者添删。</p>
<h3 id="u5185_u5B58_u521D_u59CB_u5316"><a href="#u5185_u5B58_u521D_u59CB_u5316" class="headerlink" title="内存初始化"></a>内存初始化</h3><p>在<code>board/ti/am335x/board.c</code>中的函数<code>sdram_init()</code>就是内存的初始化函数，它会根据EEPROM得到的板子型号，对应不同的DRAM配置。阅读代码不难发现，配置具体信息是定义在<code>arch/arm/include/asm/arch-am33xx/ddr_defs.h</code>。如果需要修改或者添加不同的内存配置，修改这两个文件即可。</p>
<h3 id="u5176_u4ED6_u786C_u4EF6_u8C03_u6574"><a href="#u5176_u4ED6_u786C_u4EF6_u8C03_u6574" class="headerlink" title="其他硬件调整"></a>其他硬件调整</h3><p>绝大多数硬件的配置定义都在<code>am335x_evm.h</code>中，包括各种模块的Base address、初始化值、硬件定义等等，读者可以自行阅读。这些设置有的是根据芯片的手册而定，比如说memory的初始化值；有的是根据硬件设计而定，比如USB的Host &amp; PERIPHERAL设置；有的是可以根据需要自行决定，比如<code>CONFIG_SYS_BOOTM_LEN</code>。具体改什么、怎么改，要根据情况分析而定。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过这些年的演变，U-boot已经从一个简单的loader慢慢发展成了一个小小系统，硬件上原生支持各种平台、外设，软件上支持Fat&amp;ext234等文件系统、传输协议、测试工具，可以说相当完善了。这种进化，负面影响是让整体变得更复杂臃肿，但也有更多的正面影响，是让我们的移植工作更加简单、模块化。</p>
<h2 id="Uboot_u4EE3_u7801_u7ED3_u6784"><a href="#Uboot_u4EE3_u7801_u7ED3_u6784" class="headerlink" title="Uboot代码结构"></a>Uboot代码结构</h2><p>代码结构是了解uboot的基础，作为一个成熟的开源软件，uboot的代码结构很清晰。绝大多数的代码都是通用的，所以在移植过程中，基本上只需要找到自己的对应平台，修改板子特有的部分即可。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（二）SPL]]></title>
    <link href="http://conanwhf.github.io/2017/06/08/bootup-2-spl/"/>
    <id>http://conanwhf.github.io/2017/06/08/bootup-2-spl/</id>
    <published>2017-06-08T09:31:26.000Z</published>
    <updated>2017-06-12T15:12:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u542F_u52A8_u6A21_u5F0F"><a href="#u542F_u52A8_u6A21_u5F0F" class="headerlink" title="启动模式"></a>启动模式</h2><p>面对一块完全的空板子，首先要做的当然是让它启动起来。emmc/nand中完全没有内容，意味着没有uboot，没有命令行，所有的硬件包括内存都没有初始化，除了CPU。在上电的CPU之上，还跑了一个小小的叫做BootROM的程序。<br>通常每块芯片，都在硬件中包含了一个BootROM，是一个小程序，上电后自动运行，无法修改，不同的厂家有不同的设计，但都是给定几种不同的启动模式，然后循环检测。TI这块板就支持各种模式，如emmc, nand flash, network, spi, uart等。<br>所谓的不同启动模式，本质上也是类似的，都是从某个设备中读取很少的一点数据放到一定的地方（一般是SRAM或者STACK），然后把PC指针交给它。所以并不是支持什么启动就可以直接在设备上放操作系统了，BootROM能做的只是很基础的硬件初始化工作，更多的事情是需要Uboot来完成。<a id="more"></a><br></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/06/08/bootup-2-spl/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/06/08/bootup-2-spl/'>ARM板移植Linux系统启动（二）SPL</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>言归正传。对于我手头的这块板子，没有nand flash，没有外接emmc(TF卡)，没有网口，板载emmc是空的，那么只能从UART启动了。TI对于Uart启动模式的设计，是将编译出来的<strong>u-boot-spl.bin</strong>（下文称为spl）使用<strong>xmodem</strong>通过串口传输过去，跑起来之后再开启ymodem接收模式，等待串口用<strong>ymodem</strong>传输<strong>u-boot.img</strong>(下文称为u-boot)完毕，将u-boot跑起来。</p>
<h2 id="SRAM_u548CDRAM"><a href="#SRAM_u548CDRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h2><p>下载了代码，重新编译之后，却发现连spl都完全没有打印信息。经过跟踪代码添加打印，发现好像spl根本没有跑起来，这让人感到很奇怪。我手头的板子是改过内存芯片的，uboot跑不起来很正常，因为DRAM可能没有正确初始化。但SPL我认为应该是跑在SRAM里的，SRAM只要上电便可以使用，不应该没有任何反应。<br>阅读文档和Debug信息之后，发现竟然还有个配置选项，是先初始化DRAM，再让SPL从DRAM的固定地址启动。它们定义在编译uboot的config中：<br><code>configs/am335x_boneblack_defconfig</code></p>
<pre><code>CONFIG_SPL_STACK_R_ADDR=0x82000000
CONFIG_SPL_STACK_R=y
</code></pre><p>跟踪代码，可以看到在ARM的初始化汇编程序中会调用这样的函数：<br><code>arch/arm/lib/crt0.S</code></p>
<pre><code># if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK)
# ifdef CONFIG_SPL_BUILD
/* Use a DRAM stack for the rest of SPL, if requested */
bl      spl_relocate_stack_gd
cmp     r0, #0
movne   sp, r0
movne   r9, r0
# endif
ldr     r0, =__bss_start        /* this is auto-relocated! */
</code></pre><p>而函数<code>spl_relocate_stack_gd</code>则在<code>common/spl/spl.c</code>中实现。在config中将<code>CONFIG_SPL_STACK_R=y</code>删除，SPL则顺利地跑起来，有了打印信息。<br>这个部分当时我十分费解，因为SPL原本是不需要配置DRAM然后再跑的，但我看了一下TI和uboot的release，很多板子都用到了这样的配置，不明白为什么。解决这个问题后，我就将SPL放在SRAM里的设置保留了下去。后来继续做移植的时候，因为这个问题我掉了一个坑，才知道这样的设置是有原因的：<br>做到烧写bootloader的时候，发现我烧的bootloader跑不起来，总是出了一半打印信息就死了。经过回想，自己的bootloader除了不会影响的硬件设置改动，跟Beaglebone原生的release差别就在这个SRAM和DRAM的问题了，后来一试果然如此。大概是因为从eMMC启动的SPL需要初始化eMMC，有一些地方还是要用到DRAM，才这么设计的吧。</p>
<h2 id="u4EE3_u7801_u6D41_u7A0B"><a href="#u4EE3_u7801_u6D41_u7A0B" class="headerlink" title="代码流程"></a>代码流程</h2><p>SPL主要的内容分为三个部分：启动ARM的汇编，和uboot共享的设备初始化，以及SPL本身独有的代码。SPL自身的代码在common/spl/下，而每个板子特有的设备初始化代码在board/ti/am335x/下，通过查看<code>scripts/Makefile.spl</code>可以知道，用来引导启动的MLO文件实际上是基于u-boot-spl.bin做出来的，所以基本可以看作是同样的代码。整个SPL的作用可以说就是“初始化”，是各个层次的XXX_board_init()函数互相调用的过程，下面通过阅读代码把启动流程大致过一遍（代码部分提炼，删减不重要部分）。</p>
<h3 id="arch/arm/cpu/armv7/start-S"><a href="#arch/arm/cpu/armv7/start-S" class="headerlink" title="arch/arm/cpu/armv7/start.S"></a><code>arch/arm/cpu/armv7/start.S</code></h3><p>这是上电后最开始的代码部分，对部分寄存器的状态进行设置，完成后调用<code>_main</code></p>
<pre><code>/* Set vector address in CP15 VBAR register */
ldr     r0, =_start
mcr     p15, 0, r0, c12, c0, 0  @Set VBAR
# endif

/* the mask ROM code should have PLL and others stable */
# ifndef CONFIG_SKIP_LOWLEVEL_INIT
bl      cpu_init_cp15
# ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
bl      cpu_init_crit
# endif
# endif

bl      _main
</code></pre><h3 id="arch/arm/lib/crt0-S"><a href="#arch/arm/lib/crt0-S" class="headerlink" title="arch/arm/lib/crt0.S"></a><code>arch/arm/lib/crt0.S</code></h3><p>这段代码的开头注释写得很清楚，它是ARM启动很重要的一段过程，完成了代码段、基础硬件(RAM)、stack等的初始化和配置，最终将指针交给了<code>board_init_r()</code>。</p>
<h3 id="common/spl/spl-c"><a href="#common/spl/spl-c" class="headerlink" title="common/spl/spl.c"></a><code>common/spl/spl.c</code></h3><p>uboot中通用的SPL代码，基本的<code>board_init_r()</code>实现，首先初始化SPL需要的内存空间，然后通过<code>spl_board_init()</code>初始化板子的基础部分，接着按照<code>board_boot_order</code>中的设备依次尝试读取uboot数据，并启动uboot。</p>
<pre><code>void board_init_r(gd_t *dummy1, ulong dummy2)
{
u32 spl_boot_list[]() = {
    BOOT_DEVICE_NONE,
    BOOT_DEVICE_NONE,
    BOOT_DEVICE_NONE,
    BOOT_DEVICE_NONE,
    BOOT_DEVICE_NONE,
};
struct spl_image_info spl_image;

debug(&quot;&gt;&gt;spl:board_init_r()\n&quot;);

if (!(gd-&gt;flags &amp; GD_FLG_SPL_INIT)) {
    if (spl_init())
        hang();
    }

# ifdef CONFIG_SPL_BOARD_INIT
    spl_board_init();
# endif

memset(&amp;spl_image, &apos;\0&apos;, sizeof(spl_image));
board_boot_order(spl_boot_list);

if (boot_from_devices(&amp;spl_image, spl_boot_list,
  ARRAY_SIZE(spl_boot_list))) {
    puts(&quot;SPL: failed to boot from all boot devices\n&quot;);
    hang();
}
switch (spl_image.os) {
    case IH_OS_U_BOOT:
        debug(&quot;Jumping to U-Boot\n&quot;);
    break;
    default:
        debug(&quot;Unsupported OS image.. Jumping nevertheless..\n&quot;);
}

debug(&quot;loaded - jumping to U-Boot...&quot;);
spl_board_prepare_for_boot();
jump_to_image_no_args(&amp;spl_image);
}
</code></pre><h3 id="arch/arm/mach-omap2/boot-common-c"><a href="#arch/arm/mach-omap2/boot-common-c" class="headerlink" title="arch/arm/mach-omap2/boot-common.c"></a><code>arch/arm/mach-omap2/boot-common.c</code></h3><p>这是OMAP芯片的通用代码，实现了<code>spl_board_init()</code>。首先保存中间状态，然后call <code>preloader_consle_init()</code>来初始化Uart和打印显示（位于<code>common/spl/spl.c</code>）。完成之后我们便能通过UART看到在SPL中的打印信息。<br>接下来是硬件相关部分：初始化SPL，I2C，MISC，WatchDog，最后call到am33xx的spl代码<code>am33xx_spl_board_init()</code>。</p>
<pre><code>void spl_board_init(void)
{
/*  * Save the boot parameters passed from romcode.
     * We cannot delay the saving further than this,
         * to prevent overwrites.
         */
        save_omap_boot_params();

        /* Prepare console output */
        preloader_console_init();

# if defined(CONFIG_SPL_NAND_SUPPORT) || defined(CONFIG_SPL_ONENAND_SUPPORT)
    gpmc_init();
# endif
# ifdef CONFIG_SPL_I2C_SUPPORT
    i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE);
# endif
# if defined(CONFIG_AM33XX) &amp;&amp; defined(CONFIG_SPL_MUSB_NEW_SUPPORT)
    arch_misc_init();
# endif
# if defined(CONFIG_HW_WATCHDOG)
    hw_watchdog_init();
# endif
# ifdef CONFIG_AM33XX
    am33xx_spl_board_init();
# endif
}
</code></pre><h3 id="board/ti/am335x/board-c"><a href="#board/ti/am335x/board-c" class="headerlink" title="board/ti/am335x/board.c"></a><code>board/ti/am335x/board.c</code></h3><p>特定板子的硬件实现，完成了<code>am33x_spl_board_init()</code>。这里根据<code>board_is_XXX()</code>函数确定不同的板子型号，继而进行不同的硬件初始化流程。要注意这个板子的型号是根据EEPROM中烧录的信息来确定的，如果硬件上有修改，需要手动进行一些特殊处理。我手头的板子就是没有这个EEPROM的，当时也给我造成了一点小麻烦。<br>这些硬件初始化都完成后，就可以一路跳回<code>common/spl/spl.c, board_init_r()</code>，跑后续的uboot启动流程。至此，SPL任务完成！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u542F_u52A8_u6A21_u5F0F"><a href="#u542F_u52A8_u6A21_u5F0F" class="headerlink" title="启动模式"></a>启动模式</h2><p>面对一块完全的空板子，首先要做的当然是让它启动起来。emmc/nand中完全没有内容，意味着没有uboot，没有命令行，所有的硬件包括内存都没有初始化，除了CPU。在上电的CPU之上，还跑了一个小小的叫做BootROM的程序。<br>通常每块芯片，都在硬件中包含了一个BootROM，是一个小程序，上电后自动运行，无法修改，不同的厂家有不同的设计，但都是给定几种不同的启动模式，然后循环检测。TI这块板就支持各种模式，如emmc, nand flash, network, spi, uart等。<br>所谓的不同启动模式，本质上也是类似的，都是从某个设备中读取很少的一点数据放到一定的地方（一般是SRAM或者STACK），然后把PC指针交给它。所以并不是支持什么启动就可以直接在设备上放操作系统了，BootROM能做的只是很基础的硬件初始化工作，更多的事情是需要Uboot来完成。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（一）启动流程]]></title>
    <link href="http://conanwhf.github.io/2017/05/30/bootup-1-main/"/>
    <id>http://conanwhf.github.io/2017/05/30/bootup-1-main/</id>
    <published>2017-05-30T09:31:26.000Z</published>
    <updated>2017-06-12T15:12:39.000Z</updated>
    <content type="html"><![CDATA[<p>几年前，我是一个标准的原厂Linux系统开发人员，用公司自己的芯片，移植整套BSP。对于Linux系统启动方面，自认为摸得很熟了，从上电加载的汇编码到Linux内核及文件系统的配置，无一不留下了我修改的代码，细节精确到nand flash的某block某page放了什么代码，内存某个地址加载的是什么，代码某个改动是为了兼容什么project，一清二楚。所以最近接到这个移植系统的工作，信心挺足，估摸硬件没有问题的话几天之内移植就能完成，哪知道被现实结结实实打脸。<br>之前我用的Linux系统是2.6，Uboot版本不详但Fat32的支持还是我们自己移植进去的，可以说相当跟不上时代了。最新的Kernel早就采用了DTS，Uboot也加了很多功能和驱动，我在移植的过程中几乎完成了一次重新学习的过程。虽然我这次用的板是基于TI的，但我希望能不局限于具体的板子型号，而是把规律性的东西写出来，让后来人有个参考。<a id="more"></a><br></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.github.io/2017/05/30/bootup-1-main/</p><p>访问原文「<a href='http://conanwhf.github.io/2017/05/30/bootup-1-main/'>ARM板移植Linux系统启动（一）启动流程</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
<h2 id="u786C_u4EF6_u73AF_u5883"><a href="#u786C_u4EF6_u73AF_u5883" class="headerlink" title="硬件环境"></a>硬件环境</h2><p>首先交代背景。我在前公司做的板子硬件是自己设计的，系统烧写在nand flash上，也支持从SD卡加载Uboot和Kernel uImage启动。大致的启动流程是BootROM上电读取nandflash上某个固定page的数据，大小不超过2K（为了兼容不同的nand flash page），这是IPL，然后自加载启动程序，初始化RAM, flash，接着读取Uboot，用Uboot加载flash上的内核和跟文件系统，跑起来。Uboot、Kernel、rootdisk都是用特定的工具写在Flash固定的位置，没有基于文件系统。<br>这次我要做的板子，硬件是基于TI的BeagleBoneBlack，拿掉了一些不需要的硬件，也修改了一些东西。影响比较大的是拿掉了CapeSystem用的EEPROM，网口，TF卡，以及换了一块内存芯片，能用的只剩下USB，和内部的一块emmc。TI的文档对于手动修改、编译、烧写等方面的信息写得语焉不详，源码也有点问题，我的移植过程变得跟想象的不太一样，有点摸索前进的感觉。</p>
<h2 id="u542F_u52A8_u6D41_u7A0B"><a href="#u542F_u52A8_u6D41_u7A0B" class="headerlink" title="启动流程"></a>启动流程</h2><p>言归正传。对于任何Linux系统启动的流程，其实都是一样的：</p>
<ol>
<li>系统上电，BootROM寻找可以用来启动的设备，从设备中读取SPL</li>
<li>运行SPL读取和跑起来真正的Uboot</li>
<li>在Uboot中读取Kernel、根文件系统、DTB，加载到各自的内存地址中</li>
<li>将启动参数通过启动命令传递给Kernel，跳转到Kernel运行</li>
<li>Kernel初始化基本部分，加载根文件系统，启动完毕</li>
</ol>
<p>SPL和Uboot都来自于U-boot的release，有部分共用的代码，编译完毕同时得到。注意在TI的SDK中（其他的我不清楚是否一样）,SPL有两种形式：u-boot-spl.bin和MLO。它们一个是串口启动用，一个是eMMC/Nandflash启动用，不能混用。以上每个阶段不同的东西跑起来的步骤都是一样的：被加载到内存的某个地址，PC指针跳转运行。区别只是在于<strong>被谁加载、从哪里加载、加载到内存的哪里</strong>。</p>
<h3 id="u542F_u52A8_u6D41_u7A0B_u7684_u53D8_u5F0F"><a href="#u542F_u52A8_u6D41_u7A0B_u7684_u53D8_u5F0F" class="headerlink" title="启动流程的变式"></a>启动流程的变式</h3><h4 id="u88AB_u8C01_u52A0_u8F7D"><a href="#u88AB_u8C01_u52A0_u8F7D" class="headerlink" title="被谁加载"></a><strong>被谁加载</strong></h4><p>对于一个完整的流程而言，每个文件被谁加载基本上都是固定的，除了根文件系统。根文件系统既有可能被uboot加载，也可能被kernel加载。注意被uboot加载时，根文件系统需要做成一个uboot能够接受的image，有固定的头，类似zImage和uImage的区别。而在调试过程中，加载的过程有可能是手动的，或者通过不同的设备传输拷贝，被谁加载其实完全不重要了。</p>
<h4 id="u4ECE_u54EA_u91CC_u52A0_u8F7D"><a href="#u4ECE_u54EA_u91CC_u52A0_u8F7D" class="headerlink" title="从哪里加载"></a><strong>从哪里加载</strong></h4><p>这个问题的各种变化，就对应了不同的启动模式（一般意义上的，非硬件意义上）。你当然可以所有的东西都读取自内置emmc，也可以插卡让系统从卡上加载；你也可以从Uart传输uboot的image跑起来，进入uboot的命令行，手动从TF卡或者网络读取kernel；你甚至可以在uboot中从nand flash读取Kernel image，从网络获得根文件系统，从usb中加载dtb，从TF卡里拿到启动参数，最后把它们综合到一起，引导整个系统。</p>
<h4 id="u52A0_u8F7D_u5230_u5185_u5B58_u7684_u54EA_u91CC"><a href="#u52A0_u8F7D_u5230_u5185_u5B58_u7684_u54EA_u91CC" class="headerlink" title="加载到内存的哪里"></a><strong>加载到内存的哪里</strong></h4><p>其实也很简单：加载到哪里都可以，只要不冲突。首先是要计算好文件的大小，不要让后来加载的文件覆盖了之前的；然后是最好将Kernel从较高的地址跑起来，规划好内存分区，以免kernel跑起来后破坏了根文件系统等数据。关于怎么定义内存地址，又是另外一个话题，网上教程很多，我就不多说了。</p>
<h4 id="u52A0_u8F7D_u6587_u4EF6_u7684_u53D8_u5316"><a href="#u52A0_u8F7D_u6587_u4EF6_u7684_u53D8_u5316" class="headerlink" title="加载文件的变化"></a>加载文件的变化</h4><p>在实际中，Kernel启动的阶段变化很多，Kernel、根文件系统、DTB这三个部分也并非形式僵化的三个文件。比如大部分日常启动时，uboot只加载了kernel和dtb，文件系统往往是kernel后来自己mount上去的，这时候只是传递了一个启动参数，_root=XXXXX_；而调试阶段常用的自带rootdisk的kernel，也不需要另外加载根文件系统。DTB文件是DTS全面应用之后才出现的，定义了板子的硬件设备信息，经过某些特殊配置有时也是可以省略（理论上，并未亲测过）。</p>
<p>   在调试中，往往会遇到很多启动的问题，明确启动的这几个基本原则和流程，能让调试的过程更轻松。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>几年前，我是一个标准的原厂Linux系统开发人员，用公司自己的芯片，移植整套BSP。对于Linux系统启动方面，自认为摸得很熟了，从上电加载的汇编码到Linux内核及文件系统的配置，无一不留下了我修改的代码，细节精确到nand flash的某block某page放了什么代码，内存某个地址加载的是什么，代码某个改动是为了兼容什么project，一清二楚。所以最近接到这个移植系统的工作，信心挺足，估摸硬件没有问题的话几天之内移植就能完成，哪知道被现实结结实实打脸。<br>之前我用的Linux系统是2.6，Uboot版本不详但Fat32的支持还是我们自己移植进去的，可以说相当跟不上时代了。最新的Kernel早就采用了DTS，Uboot也加了很多功能和驱动，我在移植的过程中几乎完成了一次重新学习的过程。虽然我这次用的板是基于TI的，但我希望能不局限于具体的板子型号，而是把规律性的东西写出来，让后来人有个参考。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2017-03]]></title>
    <link href="http://conanwhf.github.io/2017/03/31/ReadingList2017-03/"/>
    <id>http://conanwhf.github.io/2017/03/31/ReadingList2017-03/</id>
    <published>2017-03-31T02:36:54.000Z</published>
    <updated>2018-02-12T03:52:53.400Z</updated>
    <content type="html"><![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li>嫌疑人X的献身<br>这本书是因为看到3月31日有凯凯王和鱼蛋演的电影版上映，决定要先读一遍小说，才开始看的。之前在门口徘徊了好多次，也没有拿起过第二本的东野圭吾，这算是第一本真正的东野吧。<br>这本小说比想象中短很多，原本是抱着看大片的心态，结果半集电视剧的长度就结束了……原以为渐入佳境的时候，撇了一眼进度，却是快结束了！如果说这是东野的经典之作，那么多多少少让我失望了。小说的构思和故事结构是唯一经典的地方，但其他血肉和更多细节的缺失，让我有一种在看故事梗概的感觉。也因为之前被书评剧透“看到最后才发现不是你以为的”，所以心里已经有了差不多的猜测，最终的真相大白时我的震撼也小了很多。总的来说，这是个精彩的故事，却不是本出色的小说。有点遗憾作者浪费了一个好故事，明明可以花更多的笔墨，将故事讲得更大更详细，将人物塑造得更深刻更立体。Anyway，花这点时间读到一个好故事，怎么也不算亏。</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选</li>
<li>名侦探柯南漫</li>
</ol>
<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2><ol>
<li>蒋勋说红楼梦</li>
<li>《经济学人》2016必读精选-当黑天鹅坐上无人车</li>
<li>大脑使用指南：其实你活在大脑创造的虚拟世界中</li>
</ol>
<h2 id="u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_0-99"><a href="#u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_0-99" class="headerlink" title="买的正版非免费书             0.99"></a>买的正版非免费书             <strong>0.99</strong></h2><ol>
<li>独裁者手册                <strong>0.99</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这个月公婆来了，加上我月中开始重重重感冒到卧床不起，到月底炎症还没全好利索，自然也没怎么读书。除了点杂志漫画，就读了一本小说。新买了一个Switch，玩塞尔达荒野之息玩得不亦乐乎，再加上拼图，哪有时间搞学习啊？想想大人尚且如此，小孩子贪玩也就真的没什么可说的了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li>嫌疑人X的献身<br>这本书是因为看]]>
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.github.io/tags/BookList/"/>
    
      <category term="Reading" scheme="http://conanwhf.github.io/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多说评论关闭]]></title>
    <link href="http://conanwhf.github.io/2017/03/23/DuoShuoClose/"/>
    <id>http://conanwhf.github.io/2017/03/23/DuoShuoClose/</id>
    <published>2017-03-23T09:35:25.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚发现多说不正常，去官网看，才发现多说已经要关了……</p>
<blockquote>
<p>重要通知: 多说即将关闭<br>多说网 发表于 3月21日<br>因公司业务调整，非常遗憾的向大家宣布多说项目即将关闭。 我们将于2017年6月1日正式关停服务，在此之前您可以通过后台的数据导出功能导出自己站点的评论数据。 对此给您造成的不便，我们深表歉意，感谢您的一路相伴。</p>
</blockquote>
<p>感谢多说在过去日子里提供的服务，一个无法变现的项目难以为继，作为程序员我能理解。合适的新评论系统我还没有找到，国内的服务太多广告太一言难尽，国外的又太慢会被墙，不然我也不会专门在coding放个整站镜像了。所以目前的计划是所有评论暂时关闭，如果有什么想说的，欢迎发email给我交流，或者在github上留言也OK。虽然这么长时间并没有什么人留言，但还是感谢每一个关注的人。谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚发现多说不正常，去官网看，才发现多说已经要关了……</p>
<blockquote>
<p>重要通知: 多说即将关闭<br>多说网 发表于 3月21日<br>因公司业务调整，非常遗憾的向大家宣布多说项目即将关闭。 我们将于2017年6月1日正式关停服务，在此之前您可以通]]>
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.github.io/categories/Life-Other/"/>
    
  </entry>
  
</feed>
