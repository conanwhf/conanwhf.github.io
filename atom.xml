<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[iOS开发和七七八八]]></title>
  <subtitle><![CDATA[Conan学习笔记]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://conanwhf.coding.me/"/>
  <updated>2016-08-26T05:13:54.000Z</updated>
  <id>http://conanwhf.coding.me/</id>
  
  <author>
    <name><![CDATA[Conan Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[树莓派RaspberryPi系统备份Image的制作]]></title>
    <link href="http://conanwhf.coding.me/2016/08/25/rpi-cloneimg/"/>
    <id>http://conanwhf.coding.me/2016/08/25/rpi-cloneimg/</id>
    <published>2016-08-25T02:02:26.000Z</published>
    <updated>2016-08-26T05:13:54.000Z</updated>
    <content type="html"><![CDATA[<p>在树莓派上做开发，难免会弄出各种版本的系统，加上有时候还需要拿给客户自己烧录或者demo，总是要clone一下TF卡，做系统做到烦躁。于是想想有没有什么办法能做跟官方release一样的烧录img出来，基本要求就是全系统克隆，但做出的img跟卡的容量无关，只跟系统占用的存储大小有关。</p>
<h2 id="u7B80_u5355_u5168_u5361_u5907_u4EFD"><a href="#u7B80_u5355_u5168_u5361_u5907_u4EFD" class="headerlink" title="简单全卡备份"></a>简单全卡备份</h2><p>其实如果只是简单备份，可以直接将TF卡插入Linux电脑，用dd命令来备份和恢复(设备号不固定这里只是例子，还是用fdisk -l先查看一下比较保险)：</p>
<pre><code># Backup the system to img file in Linux
dd if=/dev/mmcblk0 of=raspberrypi-bak.img bs=1M
# A little difference if Mac
dd if=/dev/rdisk2 of=raspberrypi-bak.img bs=1M
#
# Restore system from img
dd if=raspberrypi-bak.img bs=1M of=/dev/mmcblk0
# Or in Mac
dd if=raspberrypi-bak.img bs=1M of=/dev/rdisk2
</code></pre><p>不过这样做，16G的卡哪怕你只用了1G，整个备份文件也有16G，占用空间耗时间是小事，想想拿这么大文件给客户不方便，也显得太不专业了。<br>在网上搜了一下，已经有朋友先行做过类似的事情：<a href="http://www.fendou.info/raspberry-pi-sd-card-backup-and-recovery/" title="树莓派 Raspberry Pi SD卡系统备份与还原" target="_blank" rel="external">树莓派 Raspberry Pi SD卡系统备份与还原</a>，看了一下按照他的步骤实践了一遍，但出现了一些问题，折腾了很久最终才解决。</p>
<h2 id="RaspberryPi_u7684_u6587_u4EF6_u7CFB_u7EDF"><a href="#RaspberryPi_u7684_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="RaspberryPi的文件系统"></a>RaspberryPi的文件系统</h2><p>首先介绍一下RaspberryPi的文件系统。树莓派的官方系统是基于Debian的，主要是两个分区：<strong>启动分区boot和根分区</strong>。boot分区为fat32格式，挂载在/boot，存放一些系统启动需要的基本文件，包括内核、驱动、firmware、启动脚本等；根分区文件系统是ext4格式，挂载于/，存放一些安装的软件和库文件、系统配置、用户数据等等；另外当系统启动时会自动生成和挂载一些必要的其他文件夹，包括temfs、sysfs、proc、debugfs、configfs等（使用mount可以看到他们），这些都是虚拟文件系统，由操作系统自动管理，备份时不需要关注。日常使用时，修改的文件包括安装的软件都是在根分区中，而如果自行编译内核，需要更新的文件都在/boot中。<br>所以备份一个系统，实际上是要备份这两个分区，官方发布的烧录镜像，也是包含了这样的两个分区，并保证通过dd的操作，能将其完整写入目标TF卡。首次烧录完毕后，不论你的TF卡容量为多少，启动后的boot和/分区大小都是固定的，然后可以使用<code>raspi-config</code>来扩展根分区的大小，boot分区不变，来达到使用所有卡内容量的目的。<br>相对应的备份步骤，大致为：创建img，把img当作一个磁盘分区和格式化，mount各个分区，将文件备份至对应的分区中，umount分区结束备份。</p>
<h2 id="u76EE_u6807_u5907_u4EFD_u6587_u4EF6_u7684_u521B_u5EFA_u548C_u5206_u533A"><a href="#u76EE_u6807_u5907_u4EFD_u6587_u4EF6_u7684_u521B_u5EFA_u548C_u5206_u533A" class="headerlink" title="目标备份文件的创建和分区"></a>目标备份文件的创建和分区</h2><p>既然是备份到文件，那么首先需要创建一个备份文件，并且把这个文件看作一个虚拟设备，对其进行分区。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/08/25/rpi-cloneimg/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/08/25/rpi-cloneimg/'>树莓派RaspberryPi系统备份Image的制作</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
需要用到的工具有<em>parted, kpartx, dosfstools, rsync</em>，使用apt-get安装：</p>
<pre><code>sudo apt-get -y install rsync dosfstools parted kpartx
</code></pre><h3 id="u521B_u5EFA_u65B0_u7684_u6587_u4EF6"><a href="#u521B_u5EFA_u65B0_u7684_u6587_u4EF6" class="headerlink" title="创建新的文件"></a>创建新的文件</h3><p>我们用<code>dd</code>命令来创建一个新的img，img的大小和当前RaspberryPi已使用的存储空间有关。使用<code>df -P</code>来查看磁盘空间状态（以1K为单位），会看到如下的信息：<br><img src="http://whf.d.pr/1awb8+" alt=""><br>其中红框的部分就是我们需要关注的，将它们对应的Used数目取出，计算得到需要创建的img大小：<br>    img=rpibackup.img</p>
<pre><code>#sudo rm $img
bootsz=df -P | grep /boot | awk &apos;{print $2}&apos;
rootsz=df -P | grep /dev/root | awk &apos;{print $3}&apos;
totalsz=echo $bootsz $rootsz | awk &apos;{print int(($1+$2)*1.3)}&apos;
sudo dd if=/dev/zero of=$img bs=1K count=$totalsz
</code></pre><p>这里的totalsz是基于两个分区使用总和的1.3倍，一方面是分区表、格式化等操作造成的空间损失，另一方面是系统对剩余空间的要求。我曾经尝试过使用1.1，然而系统启动后在终端大部分命令都报错，说空间不足。</p>
<h3 id="u5C06_u6587_u4EF6_u5206_u533A"><a href="#u5C06_u6587_u4EF6_u5206_u533A" class="headerlink" title="将文件分区"></a>将文件分区</h3><p>工具parted可以用来把一个img文件当作一个磁盘来分区。使用<code>fdisk -l</code>能够看到系统中各个磁盘分区的情况，在我的树莓派上系统TF卡的分区情况如下：<br><img src="http://whf.d.pr/1dR76+" alt=""><br>我们把boot分区设计为跟原分区大小一样，root分区则是扩展到img文件的末尾。对应的脚本：</p>
<pre><code>bootstart=sudo fdisk -l /dev/mmcblk0 | grep mmcblk0p1 | awk &apos;{print $2}&apos;
bootend=sudo fdisk -l /dev/mmcblk0 | grep mmcblk0p1 | awk &apos;{print $3}&apos;
rootstart=sudo fdisk -l /dev/mmcblk0 | grep mmcblk0p2 | awk &apos;{print $2}&apos;
echo &quot;boot: $bootstart &gt;&gt;&gt; $bootend, root: $rootstart &gt;&gt;&gt; end&quot;
rootend=sudo fdisk -l /dev/mmcblk0 | grep mmcblk0p2 | awk &apos;{print $3}&apos;
sudo parted $img --script -- mklabel msdos
sudo parted $img --script -- mkpart primary fat32 ${bootstart}s ${bootend}s
sudo parted $img --script -- mkpart primary ext4 ${rootstart}s -1
</code></pre><h3 id="u5206_u522B_u683C_u5F0F_u5316fat32_u548Cext4_u5206_u533A"><a href="#u5206_u522B_u683C_u5F0F_u5316fat32_u548Cext4_u5206_u533A" class="headerlink" title="分别格式化fat32和ext4分区"></a>分别格式化fat32和ext4分区</h3><p>然后对分区分别进行格式化，我们可以通过loop来建立虚拟的磁盘挂载点，进行后续的操作：</p>
<pre><code>loopdevice=sudo losetup -f --show $img
device=/dev/mapper/sudo kpartx -va $loopdevice | sed -E &apos;s/.*(loop[0-9])p.*/\1/g&apos; | head -1
sleep 5
sudo mkfs.vfat ${device}p1 -n boot
sudo mkfs.ext4 ${device}p2
</code></pre><p>在中间的这个sleep是我在实践中发现，创建loop的设备节点需要一些时间，如果手动在终端贴命令则没有问题，而若是用脚本执行，则在format时节点还没有创建好，从而造成格式化失败。</p>
<h2 id="u5907_u4EFDBoot_u5206_u533A"><a href="#u5907_u4EFDBoot_u5206_u533A" class="headerlink" title="备份Boot分区"></a>备份Boot分区</h2><p>Boot分区是Fat32格式且数据不多，直接mount然后copy数据即可，注意权限问题。</p>
<pre><code>mountb=$usbmount/backup_boot/
mkdir -p $mountb
sudo mount -t vfat ${device}p1 $mountb
sudo cp -rfp /boot/* $mountb
sync 
sudo umount $mountb
</code></pre><h2 id="u5907_u4EFD_u6839_uFF08root_uFF09_u5206_u533A"><a href="#u5907_u4EFD_u6839_uFF08root_uFF09_u5206_u533A" class="headerlink" title="备份根（root）分区"></a>备份根（root）分区</h2><p>根分区的备份是我折腾了很久的部分。因为它文件众多，不止一个文件夹，而且在系统运行时有一些文件、文件夹是临时生成或者mount的，不能全部直接copy。这就需要有一种方法能区分真正写在磁盘上的文件并将其备份。</p>
<h3 id="u5931_u8D25_u7684_u7ECF_u9A8C_uFF1Adump_26amp_3Brestore"><a href="#u5931_u8D25_u7684_u7ECF_u9A8C_uFF1Adump_26amp_3Brestore" class="headerlink" title="失败的经验：dump&amp;restore"></a>失败的经验：dump&amp;restore</h3><p>在开头提到的道友那篇文章里，是采用了针对ext4备份和恢复的工具dump和restore。</p>
<blockquote>
<p>sudo mount -t ext4 $partRoot /media/<br>cd /media<br>sudo dump -0uaf - / |  sudo restore -rf -<br>cd; sudo umount /media</p>
</blockquote>
<p>但在关键的步骤出现了<strong> Broken pipe</strong>错误，经过重复测试多次，虽然每次报错的文件和inode不一样，但每次都无法顺利完成。这个问题在原博的评论中也有人遇到了：</p>
<blockquote>
<p>restore: ./lost+found: File exists<br>./tmp/rstdir1445584846: (inode 159534) not found on tape<br>./tmp/rstmode1445584846: (inode 161527) not found on tape<br>DUMP: Broken pipe<br>DUMP: The ENTIRE dump is aborted.<br>………………<br>针对这个问题我做了一些测试。首先是把<code>sudo dump -0uaf - / | sudo restore -rf -</code>分开，取消管道，先dump到一个文件再restore。发现dump总是成功的，而问题出在restore上，所以就broken pipe了。开始怀疑是restore的时候权限有问题，后来把dump出来的文件拿到PC上做restore，也同样是失败。这样就很有可能是dump的文件有问题，仔细看看每次出错的文件都是隐藏或者临时文件，怀疑跟这个有关，但找了一大圈dump相关的参数尝试，依然是没有解决。</p>
</blockquote>
<h3 id="u4F7F_u7528rsync_u5907_u4EFD"><a href="#u4F7F_u7528rsync_u5907_u4EFD" class="headerlink" title="使用rsync备份"></a>使用rsync备份</h3><p>由于每次测试dump和restore花的时间很长，项目又比较急，我实在是不能再耽搁下去了，于是决定放弃这种方式。想了一下，曾经用过<a href="https://github.com/billw2/rpi-clone" title="rpi-clone" target="_blank" rel="external">rpi-clone</a>来做卡与卡之间的备份，那么备份成文件也应该是一样的。我于是去看了下它的源码，把根文件系统备份相关的部分提出来就能直接用起来了。这里用的是备份工具rsync，其本质上是基于文件系统之上的的直接拷贝，因为没有用到增量备份，所以跟cp其实是一回事。只是rsync能很好的保留各种权限、时间戳、软链接和文件信息，避免了一些用cp的问题。保险起见，我依然沿用了它。<br>首先还是mount一下：</p>
<pre><code>mountr=$usbmount/backup_root/
mkdir -p $mountr
sudo mount -t ext4 ${device}p2 $mountr
</code></pre><p>然后要对存在swap分区的情况进行特殊处理：</p>
<pre><code>if [ -f /etc/dphys-swapfile ]; then
        SWAPFILE=`cat /etc/dphys-swapfile | grep ^CONF_SWAPFILE | cut -f 2 -d=`
    if [ &quot;$SWAPFILE&quot; = &quot;&quot; ]; then
        SWAPFILE=/var/swap
    fi
    EXCLUDE_SWAPFILE=&quot;--exclude $SWAPFILE&quot;
fi
</code></pre><p>接着就是所有文件的备份，跳过某些临时、系统自动生成的文件和文件夹：</p>
<pre><code>sudo rsync --force -rltWDEgopt --delete --stats --progress\
    $EXCLUDE_SWAPFILE \
    --exclude &apos;.gvfs&apos; \
    --exclude &apos;/dev&apos; \
        --exclude &apos;/media&apos; \
    --exclude &apos;/mnt&apos; \
    --exclude &apos;/proc&apos; \
        --exclude &apos;/run&apos; \
    --exclude &apos;/sys&apos; \
    --exclude &apos;/tmp&apos; \
        --exclude &apos;lost\+found&apos; \
    --exclude &apos;$usbmount&apos; \
    // $mountr
</code></pre><p>完成后新建一些特殊文件夹，用来做系统启动时某些文件的自动挂载点，例如proc和mnt等等：</p>
<pre><code>for i in dev media mnt proc run sys boot; do
    if [ ! -d $mountr/$i ]; then
        sudo mkdir $mountr/$i
    fi
done
if [ ! -d $mountr/tmp ]; then
    sudo mkdir $mountr/tmp
    sudo chmod a+w $mountr/tmp
fi
</code></pre><p>到这里基本上就完成了，有一点小小的修改就是把网络配置文件删掉，以免换了新的网络环境启动系统无法自动配置：</p>
<pre><code>sudo rm -f $mountr/etc/udev/rules.d/70-persistent-net.rules
sync
</code></pre><p>最后umount，清理loop设备，结束备份：</p>
<pre><code>sudo umount $mountr
# umount loop device
sudo kpartx -d $loopdevice
sudo losetup -d $loopdevice
sudo umount $usbmount
rm -rf $mountb $mountr
</code></pre><h3 id="Mount_USB_device"><a href="#Mount_USB_device" class="headerlink" title="Mount USB device"></a>Mount USB device</h3><p>使用dump/restore的时候，有一个跳过特定文件的参数，在前文提到的教程中，作者是将img放到用户目录，并且跳过这个文件的。虽然使用rsync备份的时候，依然可以这么做，但考虑到通用性和调试的方便，我把文件直接备份在了外接的U盘上，以避免考虑各种“自己备份自己”可能带来的问题。顺便把相关的USB mount脚本和判断也贴一下供参考：</p>
<pre><code>usbmount=/mnt
mkdir -p $usbmount
if [ -z $1 ]; then
    echo &quot;no argument, assume the mount device is /dev/sda1 ? Y/N&quot;
    read key
    if [ &quot;$key&quot; = &quot;y&quot; -o &quot;$key&quot; = &quot;Y&quot; ]; then
        sudo mount -t vfat -o uid=1000 /dev/sda1 $usbmount
    else
        echo &quot;$0 [backup dest device name], e.g. $0 /dev/sda1&quot;
        exit 0
    fi
else
    sudo mount -t vfat -o uid=1000 $1 $usbmount
fi
if [ -z &quot;`grep $usbmount /etc/mtab`&quot; ]; then
    echo &quot;mount fail, exit now&quot;
    exit 0
fi 
</code></pre><p> 当然，如果你有兴趣，大可以自己改一改尝试直接备份在用户目录，只是我感觉依然是需要copy出来，意义不大。😏</p>
<h2 id="u6062_u590D_u5907_u4EFD"><a href="#u6062_u590D_u5907_u4EFD" class="headerlink" title="恢复备份"></a>恢复备份</h2><p>备份img做好了，恢复备份就无需多谈了。既然是用树莓派的小伙伴，自然有一百种方法将镜像烧录到卡上。实在不知道的，放官方链接：<a href="https://www.raspberrypi.org/documentation/installation/installing-images/README.md" title="Installing images" target="_blank" rel="external">Installing images</a>，或者看这篇：<a href="http://conanwhf.github.io/2016/01/12/rpi-start/" title="树莓派初始配置指南（2代B型）" target="_blank" rel="external">树莓派初始配置指南（2代B型）</a>。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>整理后完整的script我已经更新到GitHub:<a href="https://github.com/conanwhf/RaspberryPi-script/blob/master/rpi-backup.sh" target="_blank" rel="external">https://github.com/conanwhf/RaspberryPi-script/blob/master/rpi-backup.sh</a>，如果对你有所帮助，<strong>欢迎Star</strong>！😊有什么疑问和质疑，也欢迎砸过来！🤗<br>顺便提一下，写这篇文章的时候，我发现官方已经release了一个备份工具，<a href="https://github.com/raspberrypi/piclone" title="piclone" target="_blank" rel="external">piclone</a>，看上去是在两个TF卡之间备份，跟rpi-clone功能一样。我还没有测过，有兴趣的小伙伴可以试一下，看看源码，也许/的备份能有新的思路和方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在树莓派上做开发，难免会弄出各种版本的系统，加上有时候还需要拿给客户自己烧录或者demo，总是要clone一下TF卡，做系统做到烦躁。于是想想有没有什么办法能做跟官方release一样的烧录img出来，基本要求就是全系统克隆，但做出的img跟卡的容量无关，只跟系统占用的存储大小有关。</p>
<h2 id="u7B80_u5355_u5168_u5361_u5907_u4EFD"><a href="#u7B80_u5355_u5168_u5361_u5907_u4EFD" class="headerlink" title="简单全卡备份"></a>简单全卡备份</h2><p>其实如果只是简单备份，可以直接将TF卡插入Linux电脑，用dd命令来备份和恢复(设备号不固定这里只是例子，还是用fdisk -l先查看一下比较保险)：</p>
<pre><code># Backup the system to img file in Linux
dd if=/dev/mmcblk0 of=raspberrypi-bak.img bs=1M
# A little difference if Mac
dd if=/dev/rdisk2 of=raspberrypi-bak.img bs=1M
#
# Restore system from img
dd if=raspberrypi-bak.img bs=1M of=/dev/mmcblk0
# Or in Mac
dd if=raspberrypi-bak.img bs=1M of=/dev/rdisk2
</code></pre><p>不过这样做，16G的卡哪怕你只用了1G，整个备份文件也有16G，占用空间耗时间是小事，想想拿这么大文件给客户不方便，也显得太不专业了。<br>在网上搜了一下，已经有朋友先行做过类似的事情：<a href="http://www.fendou.info/raspberry-pi-sd-card-backup-and-recovery/" title="树莓派 Raspberry Pi SD卡系统备份与还原">树莓派 Raspberry Pi SD卡系统备份与还原</a>，看了一下按照他的步骤实践了一遍，但出现了一些问题，折腾了很久最终才解决。</p>
<h2 id="RaspberryPi_u7684_u6587_u4EF6_u7CFB_u7EDF"><a href="#RaspberryPi_u7684_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="RaspberryPi的文件系统"></a>RaspberryPi的文件系统</h2><p>首先介绍一下RaspberryPi的文件系统。树莓派的官方系统是基于Debian的，主要是两个分区：<strong>启动分区boot和根分区</strong>。boot分区为fat32格式，挂载在/boot，存放一些系统启动需要的基本文件，包括内核、驱动、firmware、启动脚本等；根分区文件系统是ext4格式，挂载于/，存放一些安装的软件和库文件、系统配置、用户数据等等；另外当系统启动时会自动生成和挂载一些必要的其他文件夹，包括temfs、sysfs、proc、debugfs、configfs等（使用mount可以看到他们），这些都是虚拟文件系统，由操作系统自动管理，备份时不需要关注。日常使用时，修改的文件包括安装的软件都是在根分区中，而如果自行编译内核，需要更新的文件都在/boot中。<br>所以备份一个系统，实际上是要备份这两个分区，官方发布的烧录镜像，也是包含了这样的两个分区，并保证通过dd的操作，能将其完整写入目标TF卡。首次烧录完毕后，不论你的TF卡容量为多少，启动后的boot和/分区大小都是固定的，然后可以使用<code>raspi-config</code>来扩展根分区的大小，boot分区不变，来达到使用所有卡内容量的目的。<br>相对应的备份步骤，大致为：创建img，把img当作一个磁盘分区和格式化，mount各个分区，将文件备份至对应的分区中，umount分区结束备份。</p>
<h2 id="u76EE_u6807_u5907_u4EFD_u6587_u4EF6_u7684_u521B_u5EFA_u548C_u5206_u533A"><a href="#u76EE_u6807_u5907_u4EFD_u6587_u4EF6_u7684_u521B_u5EFA_u548C_u5206_u533A" class="headerlink" title="目标备份文件的创建和分区"></a>目标备份文件的创建和分区</h2><p>既然是备份到文件，那么首先需要创建一个备份文件，并且把这个文件看作一个虚拟设备，对其进行分区。]]>
    
    </summary>
    
      <category term="Script" scheme="http://conanwhf.coding.me/tags/Script/"/>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/categories/RaspberryPi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Droplr的测试]]></title>
    <link href="http://conanwhf.coding.me/2016/08/20/DroplrTest/"/>
    <id>http://conanwhf.coding.me/2016/08/20/DroplrTest/</id>
    <published>2016-08-20T09:35:25.000Z</published>
    <updated>2016-08-21T17:49:12.000Z</updated>
    <content type="html"><![CDATA[<p>买了Droplr的永久会员，测试一下外链图片，如果OK就把七牛换了……国内的免费服务太让人没安全感！<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/08/20/DroplrTest/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/08/20/DroplrTest/'>Droplr的测试</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br><img src="http://whf.d.pr/18C89+" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>买了Droplr的永久会员，测试一下外链图片，如果OK就把七牛换了……国内的免费服务太让人没安全感！]]>
    
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2016-08]]></title>
    <link href="http://conanwhf.coding.me/2016/08/15/ReadingList2016-08/"/>
    <id>http://conanwhf.coding.me/2016/08/15/ReadingList2016-08/</id>
    <published>2016-08-15T09:36:54.000Z</published>
    <updated>2016-08-20T14:45:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li>催眠师手记</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选</li>
<li>知乎周刊2015年度300问-心理<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/08/15/ReadingList2016-08/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/08/15/ReadingList2016-08/'>读书清单 2016-08</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2></li>
<li>南海暗战</li>
</ol>
<h2 id="u4E2D_u4E9A_u4E70_u7684_u4E66_uFF0807-08_u6708_uFF09_37-73"><a href="#u4E2D_u4E9A_u4E70_u7684_u4E66_uFF0807-08_u6708_uFF09_37-73" class="headerlink" title="中亚买的书（07-08月）             37.73"></a>中亚买的书（07-08月）             <strong>37.73</strong></h2><ol>
<li>斯坦福极简经济学              <strong>1.00</strong></li>
<li>巴金文集（套装共19本）         <strong>9.99</strong></li>
<li>专业主义                     <strong>3.36</strong></li>
<li>高盛帝国(套装上下册):全球唯一一部全面讲述高盛百年屹立的企业传记    <strong>3.40</strong></li>
<li>精准拉伸 疼痛消除和损伤预防的针对性练习   <strong>9.99</strong></li>
<li>Linux内核设计的艺术：图解Linux操作系统架构设计与实现原理（第2版）  <strong>9.99</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这几个月都没写这个了，今天算是几个月的总结吧。其实也是几个月没读书了……说是读书总结，不如说是买书总结，因为最近都在忙项目，书买得不少却一直没怎么看，连运动都好几周没做，整个人快懒坏。但七月份有一天是结结实实捡了大漏，兴奋了我好几天，不记一下不甘心。:-)<br>那天刷微博，看到大锤转发说亚马逊发福利，一批书1元购，但不是所有人都有。马上去查了下自己的优惠券，啥也没有，挺失落的。到了晚上，又刷出来一条说有的话会收到短信，我再去看千年不用专收验证码的手机，果然有！开心打开链接，书的质量真是不错，有好几本都是我放在心愿单上等降价的。试着下了一本，0元？好奇怪……收到的短信说是1元啊……再试，还是0元。这……考虑到亚马逊历来的良心表现，即使这是个bug，也不会不认账的。我放心地把心仪的几本都买下来，全部0元。跑去看李大锤微博的评论，有说0元的，有说1元的，有说收到优惠券的……我有点蒙，但隐隐约约一种“要占大便宜”的感觉充斥了大脑，使我兴奋得不行。我再次打开优惠链接，确认之前真的没扣款，按价格从高到低排序，放心大胆地一条条点开购买起来！当然里面的书也有很一般的，我只点开有兴趣的看看评论，决定要不要，一开几十个tab，慢慢临幸过来，那感觉真是爽！整个过程虽然有点机械和无聊，但被强烈兴奋感所驱使的我，毫无懈怠感，不停地点击了一个多钟头，一直到过12点才全部完成。等喘口气才发现，不加判断点击购买的最后几本书，已经不是0元了，但是个很奇怪的数字，大约是2-3折的样子。<br>第二天我打开邮箱，亚马逊的购买记录180条……去看微博评论，原来真正的活动是部分用户发了张100元的优惠券，可以在书单中以1元的价格买书，也就是上限100本；而我却是0元买了180本……这时候再去看那些书单，价格也不是1元了，而是另外一个打了折的价格。也就是说，在12点之前，大概是有bug导致我可以0元无限购书，之后就恢复正常了……不犯懒是个多好的品质啊！幸亏我速度快清单都点完了，也幸亏我跳过了部分不喜欢的书，不然也点不完，哈哈哈！本来以为这个漏洞很多人都抓到了，后来看看微博评论、各大论坛的反馈，并没有什么大面积占到便宜的反馈，我心里更是开心了好几天啊！某人说现在知道我是真爱书了，买到了书能高兴这么久。而且这些书的质量确实都很高，评分绝大多数在4+，特别是很多历史书正和某人口味，这段时间一直在看，感觉一时半会是看不完了。:D</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li>催眠师手记</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选</li>
<li>知乎周刊2015年度300问-心理]]>
    
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.coding.me/tags/BookList/"/>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派RaspberryPi 3B的一些改变]]></title>
    <link href="http://conanwhf.coding.me/2016/08/12/rpi-3b/"/>
    <id>http://conanwhf.coding.me/2016/08/12/rpi-3b/</id>
    <published>2016-08-12T11:31:26.000Z</published>
    <updated>2016-08-25T10:31:53.000Z</updated>
    <content type="html"><![CDATA[<p>工作原因换上了最新的树莓派3B，使用了几天，虽然变化不大，但跟2B还是有一些区别的。在这里写下来供爱好者们参考。</p>
<ol>
<li>硬件上，基本上是可以通用的，接口跟2B保持一致，GPIO的排列也没有变过。值得注意的是3B自带了WIFI模块，所以你会看到开机就能有Wlan0的设备。</li>
<li>系统上，有一些改变可能是操作系统升级导致的，比如cmdline跟以前不同，但总的来说变化不大。官网的烧录img和github提供的kernel源码现在都已经提供了3B的支持，只是烧录系统就不讨论了，如果是自己编译kernel的话要注意<code>/boot/bcm2710-rpi-3-b.dtb</code>这个文件，这是系统支持3B的关键。内核的img名字还是<strong>kernel7.img</strong>没变，新的系统能同时支持3B和2B。是否把<strong>bcm2701-rpi-3-b.dtb</strong>拷贝到旧的系统中就能使其支持3B，我没有测试过，但我想应该不能成功，因为恐怕还需要更新一些index。</li>
<li>实际使用中，关于UART发现了一个很好玩的变化。以前串口的设备是<code>/dev/ttyAMA0</code>，但在3B上变成了<code>/dev/ttyS0</code>。确切地说，是3B的设备多出来一个<strong>ttyS0</strong>，并且使用ttyAMA0无法传输数据，必须使用ttyS0。前面说了新的系统可以同时兼容两种板子，我用同样的软件在2B和3B上都试了一下，2B依然只有ttyAMA0，所以可以肯定这不是软件升级的区别，具体原因就不知到了。<br>目前只看到这些不同，用起来也没什么区别的样子，可能好的地方就是可以省出一个USB口吧。😀</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>工作原因换上了最新的树莓派3B，使用了几天，虽然变化不大，但跟2B还是有一些区别的。在这里写下来供爱好者们参考。</p>
<ol>
<li>硬件上，基本上是可以通用的，接口跟2B保持一致，GPIO的排列也没有变过。值得注意的是3B自带了WIFI模块，所以你会看到开机就能有W]]>
    </summary>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/categories/RaspberryPi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年06月]]></title>
    <link href="http://conanwhf.coding.me/2016/07/01/Tips201606/"/>
    <id>http://conanwhf.coding.me/2016/07/01/Tips201606/</id>
    <published>2016-07-01T09:25:39.000Z</published>
    <updated>2016-07-06T14:49:41.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>iOS获取通知需要注意以：iOS 设备收到一条推送（APNs），用户点击推送通知打开应用时，应用程序根据状态不同进行处理需在 AppDelegate 中的以下两个方法中添加代码以获取apn内容<ol>
<li>如果 App 状态为未运行，此函数将被调用，如果launchOptions包含UIApplicationLaunchOptionsRemoteNotificationKey表示用户点击apn 通知导致app被启动运行；如果不含有对应键值则表示 App 不是因点击apn而被启动，可能为直接点击icon被启动或其他。<br>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions;<br>// apn 内容获取：<br>NSDictionary *remoteNotification = [launchOptions objectForKey: UIApplicationLaunchOptionsRemoteNotificationKey]</li>
</ol>
</li>
</ul>
<ol>
<li>基于iOS 6 及以下的系统版本，如果 App状态为正在前台或者点击通知栏的通知消息，那么此函数将被调用，并且可通过AppDelegate的applicationState是否为UIApplicationStateActive判断程序是否在前台运行。此种情况在此函数中处理：<br> (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo; // apn内容为userInfo</li>
<li>基于iOS 7 及以上的系统版本，如果是使用 iOS 7 的 Remote Notification 特性那么处理函数需要使用<br> (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler; // apn内容为userInfo</li>
</ol>
<ul>
<li>触摸事件withEvent:的方法处理流程:首先会在当前视图view上调用pointInside:withEvent:方法来判断触摸事件是否存在当前view中，如果返回NO，则说明触摸事件不在该view范围中，hitText:withEvent:方法返回nil；如果返回YES，则说明触摸在该view中，则向该view的subViews发送htiText:withEvent:消息，所有subviews的数组遍历顺序是从后往前，直至遍历到pointInside:withEvent:返回值为非空或者遍历完所有subview结束。如果遍历有非空对象,则hitTextField:withEvent:返回该对象结束；如果遍历完没有非空对象，则返回自己（self）。</li>
<li>响应者原理：首先会在触摸view上调用inital view方法，看能否处理此事件，如果不能则会将事件传递给其上级视图（inital view的superView）；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到window，如果window还是不能处理此事件则继续交给application（UIApplication单例对象）处理，如果最后application还是不能处理此事件则将其丢弃。</li>
<li>UITabBarController的subview 共有两个，一个叫 UITabBar，就是底下的那个 Bar；另一个叫UITranstionview，就是 Bar 上面的视图。把UITabBar的 y 向下移49个单位，把UITranstionview 的 hight 加长 49 个单位，也能实现隐藏UITabBar的效果。</li>
<li>UITextView开始编辑时，文字没有左上角对齐解决办法：其一，没有给textview对齐方式；其二，没有将BOOL类型的“automaticallyAdjustsScrollViewInsets”属性置为yes</li>
</ul>
<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/07/01/Tips201606/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/07/01/Tips201606/'>开发Tips收集-2016年06月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>iOS获取通知需要注意以：iOS 设备收到一条推送（APNs），用户点击推送通知打开应用时，应用程序根据状态不同进行处理需在 AppDelegate 中的以下两个方法中添加代码以获取apn内容<ol>
<li>如果 App 状态为未运行，此函数将被调用，如果launchOptions包含UIApplicationLaunchOptionsRemoteNotificationKey表示用户点击apn 通知导致app被启动运行；如果不含有对应键值则表示 App 不是因点击apn而被启动，可能为直接点击icon被启动或其他。<br>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions;<br>// apn 内容获取：<br>NSDictionary *remoteNotification = [launchOptions objectForKey: UIApplicationLaunchOptionsRemoteNotificationKey]</li>
</ol>
</li>
</ul>
<ol>
<li>基于iOS 6 及以下的系统版本，如果 App状态为正在前台或者点击通知栏的通知消息，那么此函数将被调用，并且可通过AppDelegate的applicationState是否为UIApplicationStateActive判断程序是否在前台运行。此种情况在此函数中处理：<br> (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo; // apn内容为userInfo</li>
<li>基于iOS 7 及以上的系统版本，如果是使用 iOS 7 的 Remote Notification 特性那么处理函数需要使用<br> (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler; // apn内容为userInfo</li>
</ol>
<ul>
<li>触摸事件withEvent:的方法处理流程:首先会在当前视图view上调用pointInside:withEvent:方法来判断触摸事件是否存在当前view中，如果返回NO，则说明触摸事件不在该view范围中，hitText:withEvent:方法返回nil；如果返回YES，则说明触摸在该view中，则向该view的subViews发送htiText:withEvent:消息，所有subviews的数组遍历顺序是从后往前，直至遍历到pointInside:withEvent:返回值为非空或者遍历完所有subview结束。如果遍历有非空对象,则hitTextField:withEvent:返回该对象结束；如果遍历完没有非空对象，则返回自己（self）。</li>
<li>响应者原理：首先会在触摸view上调用inital view方法，看能否处理此事件，如果不能则会将事件传递给其上级视图（inital view的superView）；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到window，如果window还是不能处理此事件则继续交给application（UIApplication单例对象）处理，如果最后application还是不能处理此事件则将其丢弃。</li>
<li>UITabBarController的subview 共有两个，一个叫 UITabBar，就是底下的那个 Bar；另一个叫UITranstionview，就是 Bar 上面的视图。把UITabBar的 y 向下移49个单位，把UITranstionview 的 hight 加长 49 个单位，也能实现隐藏UITabBar的效果。</li>
<li>UITextView开始编辑时，文字没有左上角对齐解决办法：其一，没有给textview对齐方式；其二，没有将BOOL类型的“automaticallyAdjustsScrollViewInsets”属性置为yes</li>
</ul>]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年05月]]></title>
    <link href="http://conanwhf.coding.me/2016/05/31/Tips201605/"/>
    <id>http://conanwhf.coding.me/2016/05/31/Tips201605/</id>
    <published>2016-05-31T09:25:39.000Z</published>
    <updated>2016-05-31T14:06:13.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIImage两种初始化方式的区别：<br>　　使用<strong>imageNamed</strong>：第一次读取的时候，先把这个图片放到缓存里，下次再使用到这个同名图片的时候直接从缓存中读取；优点：方便快捷，只有第一次使用的时候稍慢，接下来再使用就会稍微快点；缺点：如果在当前工程中只使用一次会浪费内存。（这个内存在程序关闭的时候才释放）<br>　　使用<strong>initWithContentsOfFile</strong>：每次都会根据路径去读取，不会占用内存，如果图片在当前工程中只使用一次，应该选择这个方法</li>
<li>UIView和CALayer的区别与联系）<ol>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li>
<li>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display</li>
<li>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</li>
<li>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</li>
<li>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</li>
</ol>
</li>
<li>在使用 ImagesQA.xcassets 时需要注意：将图片直接拖入image到ImagesQA.xcassets中时，图片的名字会保留。这个时候如果图片的名字过长，那么这个名字会存入到ImagesQA.xcassets中，名字过长会引起SourceTree判断异常。</li>
<li>UIScrollView添加了一个很好用的属性keyboardDismissMode，这样可以让键盘在滚动时自动收起。这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/05/31/Tips201605/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/05/31/Tips201605/'>开发Tips收集-2016年05月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<ol>
<li>UIScrollViewKeyboardDismissModeNone,</li>
<li>UIScrollViewKeyboardDismissModeOnDrag,      // dismisses the keyboard when a drag begins</li>
<li>UIScrollViewKeyboardDismissModeInteractive, // the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss</li>
</ol>
</li>
<li>iOS加载启动图的时候隐藏statusbar只需要在info.plist中加入<strong>Status bar is initially hidden</strong>，设置为YES就好</li>
<li>NSDate 在保存数据，传输数据中，一般最好使用UTC时间。在显示到界面给用户看的时候，需要转换为本地时间。</li>
<li>UITableViewCell中，对cell设置<strong>indentationLevel</strong>的值，可以将cell 分级别。还有 CGFloat <strong>indentationWidth</strong>属性，设置缩进的宽度。总缩进的宽度 = indentationLevel * indentationWidth</li>
<li>static的使用：<ol>
<li>修饰局部变量,修改的是生命周期，在整个程序运行过程中,只初始化一次,而且只有一份内存,并没有改变作用域</li>
<li>修饰全局变量,修改的是作用域。没有被static修饰的全局变量,项目中的任何文件,可以访问；static修饰的全局变量,只在当前文件中访问</li>
</ol>
</li>
<li>isMemberOfClass 和 isKindOfClass：两者都能检测一个对象是不是某个类的成员；isKindOfClass不仅能确定一个对象是不是某个类的成员,也能确定一个对象是否是派生自该类的类的成员,而isMemberOfClass只能做到前者.</li>
<li>TCP 和UDP 的区别与联系：TCP 为传输控制层协议,为面向连接,可靠的,点到点的通信；UDP 为用户数据报协议,非连接的不可靠的点到多点的通信；TCP 侧重可靠传输,UDP 侧重快速传输</li>
<li>读写小文件是 iPhone 的一大弱点。16MB 的文件测试与 Mac 的测试结果差不多，但是 16 字节的文件测试 iPhone 花了 Mac 10 倍的时间。相比 Mac，iPhone 的存储设备吞吐量很高，但是有一些额外的延迟。</li>
<li>iOS的应用都是通过bundle进行封装的，对应的bundle类型是Application类型，平时我们通过XCode编译出来的Target（即我们开发的应用），其实就是一个Application类型bundle，即一个文件夹！但是Finder会把这个bundle当做一个文件显示给我们，其实是因为这个bundle自身也是一个package，而Mac系统会把所有的package当做一个文件来对待，显示给用户，从而防止用户误操作导致程序文件损坏或丢失。</li>
<li>NSURLConnettion是 Core Foundation/CFNetwork框架 API 之上的一个抽象. NSURLConnettion是用来指代 Foundation 框架中的一系列组件: NSURLRequest,NSURLResponse,NSURLProtocol,NSURLCache,NSHTTPCookieStorage,NSURLCredentialStorage 以及同名类 NSURLConnection.</li>
<li>NSURLSession 不仅仅包括同名的 NSURLSession, 还包括NSURLRequest 和 NSURLCache. 同时将NSURLConnection 对应为NSURLSession,NSURLSessionFiguration 以及NSURLSession 的三个子类,即NSURLSessionTask,NSURLSessionUpLoadTask 和 NSULSessionDownLoadTask.</li>
<li>和 NSURLConnection 相比, NSURLSession 最大的改变可以配置每一个缓存的session 缓存, cookie 值,协议以及证书策略甚至夸程序共享这些信息.这保证了程序和网络框架之间的相互独立.每一个 NSURLSession 有一个 NSURLSessionConfiguration 来进行初始化, NSURLSessionConfiguration指定了策略,以及在移动设备上增强性能的选项.NSURLSession 的另一个特点就是 session Task, 用来处理的上传和下载.和 NSURLConnection 最大的不同之处在于,所有的 task 共享其创造者 NSURLSession.</li>
<li>NSURLSession即有 session 的代理方法又有 Task 的代理方法.session 的代理方法用来处理连接层的问题(服务器的信任,客户端证书的评估等),Task 的代理方法用来处理鉴权查询和以网络请求有关的问题.</li>
<li>AVAudioPlayer包含在 AVFoundation框架中，所以开发的时候首先导入音频的框架AVFoundation.framework。注意：引入头文件 #import \<avfoundation avfoundation.h\="">。<pre><code>AVAudioPlayer的初始化的时候需要给一个播放文件：AVAudioPlayer  *avAudioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:文件路径 error:nil];
</code></pre></avfoundation></li>
<li>要修改app名字的时候最好不要修改product，可以在info.plist中修改Bundle display name.</li>
<li>当UIWebView播放视频时，可以看到view hierarchy里有FigPluginView的身影。这个类来自于QuickTime Plugin，plugin的路径为：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.1.sdk/System/Library/Internet Plug-Ins/QuickTime Plugin.webplugin，这是个文件夹，里面还有链接库以及文件和图片资源。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIImage两种初始化方式的区别：<br>　　使用<strong>imageNamed</strong>：第一次读取的时候，先把这个图片放到缓存里，下次再使用到这个同名图片的时候直接从缓存中读取；优点：方便快捷，只有第一次使用的时候稍慢，接下来再使用就会稍微快点；缺点：如果在当前工程中只使用一次会浪费内存。（这个内存在程序关闭的时候才释放）<br>　　使用<strong>initWithContentsOfFile</strong>：每次都会根据路径去读取，不会占用内存，如果图片在当前工程中只使用一次，应该选择这个方法</li>
<li>UIView和CALayer的区别与联系）<ol>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li>
<li>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display</li>
<li>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</li>
<li>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</li>
<li>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</li>
</ol>
</li>
<li>在使用 ImagesQA.xcassets 时需要注意：将图片直接拖入image到ImagesQA.xcassets中时，图片的名字会保留。这个时候如果图片的名字过长，那么这个名字会存入到ImagesQA.xcassets中，名字过长会引起SourceTree判断异常。</li>
<li>UIScrollView添加了一个很好用的属性keyboardDismissMode，这样可以让键盘在滚动时自动收起。这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年04月]]></title>
    <link href="http://conanwhf.coding.me/2016/04/30/Tips201604/"/>
    <id>http://conanwhf.coding.me/2016/04/30/Tips201604/</id>
    <published>2016-04-30T09:25:39.000Z</published>
    <updated>2016-05-03T15:05:29.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>当手势和touchmoved同时加在uiview上面的时候将会优先的识别手势。滑动手势的识别是需要时间的，当手势在被识别出来以前，touchbegan 依旧会被调用。如果你希望在你的手势被识别的过程中touchbegan不被调用，那么你需要调用delaysTouchesBegan。</li>
<li>修改状态栏字体颜色:只能设置两种颜色，黑色和白色，系统默认黑色。设置为白色方法：<ol>
<li>在plist里面添加Status bar style，值为UIStatusBarStyleLightContent（白色）或UIStatusBarStyleDefault（黑 色）</li>
<li>在Info.plist中设置UIViewControllerBasedStatusBarAppearance 为NO</li>
</ol>
</li>
<li>改善APP的流畅度：<ol>
<li>尽量不要实现drawRect（每次调用该方法时，都要为backing store分配内存，非常消耗CPU）</li>
<li>避免在drawRect：中进行耗费大量CPU资源的工作</li>
<li>尽量少调用setNeedsDisplay:（视图内容变化时才调用）</li>
<li>考虑使用setNeedDisplayInRect: , 传入drawRect:的rect越小，stoke，fill的时间越少, 即使drawRect:是根据视图边界绘制的）</li>
<li>充分利用GPU的资源，直接设置layer的border，shadow，corner，gradient等属性, GPU将会处理这些属性（相反如果GPU紧张，CPU空闲，应由CPU处理，可在drawRect：中实现）<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/04/30/Tips201604/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/04/30/Tips201604/'>开发Tips收集-2016年04月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</li>
<li>如果绘制很多东西到一个视图时，可尝试开启drawsAsynchronusly，那么GPU会将视图内容绘制到backing store中，但是开启后，内存会增加，因此需要评估开启前后性能的变化，谨慎使用。</li>
</ol>
</li>
<li>推送，必须通过iOS Developer Program Portal获得SSL证书。每个证书限用于一个程序，使用程序的bundle ID作为标识。证书有两种用途的：一种是针对sandbox（用于开发和测试），另外一种针对发布产品。<ol>
<li><strong>sandbox推送是在测试环境时候做的推送</strong>需要：1开发证书2ssl证书3验证性文件。在申请ssl证书的时候需要注意bundle ID的配套，并且不能含有＊等字号。这三个申请下来就可以做推送了。因为我是用的个推，所以在推送的时候需要把申请的ssl证书在钥匙串里面导出为p12文件，然后上传到个推上去，个推会自动检测是开发证书还是生产证书。接下来就可以做推送了。</li>
<li><strong>生产环境推送</strong>需要：1生产证书app store and ad hoc 2生产环境ssl证书3验证性文件。步骤和sandbox类似。记住一定要在codesigning这里配置好。也许有人问，如果想要测试一下生产环境的推送怎么办，好办！只要你利用申请好生产证书app store and ad hoc打一个测试包装到手机里，既可以进行正式环境的测试了。</li>
</ol>
</li>
<li>应用程序的状态：<br>  <strong>Not running</strong>未运行：程序没启动。<br>  <strong>Inactive</strong>未激活：程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。<br>  <strong>Active</strong>激活：程序在前台运行而且接收到了事件。这也是前台的一个正常的模式。<br>  <strong>Backgroud</strong>后台：程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态。<br>  <strong>Suspended</strong>挂起：程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</li>
<li>UIScrollView有个keyboardDismissMode属性，设置成UIScrollViewKeyboardDismissModeOnDrag就可以在拖拽ScrollView的时候自动缩起键盘</li>
<li>iOS开发需要的图片<ol>
<li>产品设计图:可以以6的长宽比 750*1134来设计。这些图片用于描述app是什么样子的，这是app开发人员的开发参考。</li>
<li>产品切图:将设计师将设计稿切成可以用来开发的图。内部设计细节：A. 所有能点击的图片不得小于44px（Retina需要88px）B. 单独存在的部件必须是双数尺寸 C. 两倍图以@2x作为命名后缀</li>
<li>图标icon: 需要四种尺寸：58*58、80*80、120*120、180*180</li>
<li>启动图LaunchImage: 需要四种尺寸：3.5英寸（640*960），4英寸（640*1136），4.7英寸（750*1134），5.5英寸（1242*2208）</li>
<li>引导图: 用户第一次使用app或者app更新之后展示新特性的图</li>
<li>App Store上架图: 用于在App Store上面 介绍app的，需要四种尺寸：3.5英寸（640*960），4英寸（640*1136），4.7英寸（750*1134），5.5英寸（1242*2208）</li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>当手势和touchmoved同时加在uiview上面的时候将会优先的识别手势。滑动手势的识别是需要时间的，当手势在被识别出来以前，touchbegan 依旧会被调用。如果你希望在你的手势被识别的过程中touchbegan不被调用，那么你需要调用delaysTouchesBegan。</li>
<li>修改状态栏字体颜色:只能设置两种颜色，黑色和白色，系统默认黑色。设置为白色方法：<ol>
<li>在plist里面添加Status bar style，值为UIStatusBarStyleLightContent（白色）或UIStatusBarStyleDefault（黑 色）</li>
<li>在Info.plist中设置UIViewControllerBasedStatusBarAppearance 为NO</li>
</ol>
</li>
<li>改善APP的流畅度：<ol>
<li>尽量不要实现drawRect（每次调用该方法时，都要为backing store分配内存，非常消耗CPU）</li>
<li>避免在drawRect：中进行耗费大量CPU资源的工作</li>
<li>尽量少调用setNeedsDisplay:（视图内容变化时才调用）</li>
<li>考虑使用setNeedDisplayInRect: , 传入drawRect:的rect越小，stoke，fill的时间越少, 即使drawRect:是根据视图边界绘制的）</li>
<li>充分利用GPU的资源，直接设置layer的border，shadow，corner，gradient等属性, GPU将会处理这些属性（相反如果GPU紧张，CPU空闲，应由CPU处理，可在drawRect：中实现）]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年03月]]></title>
    <link href="http://conanwhf.coding.me/2016/03/31/Tips201603/"/>
    <id>http://conanwhf.coding.me/2016/03/31/Tips201603/</id>
    <published>2016-03-31T09:25:39.000Z</published>
    <updated>2016-03-31T10:12:58.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIProgressView 的 subviews 是两个 UIImageView，第一个是 TrackTintColor 层（轨道），第二个是 Progress Tint Color 层（进度）</li>
<li>如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 <a href="/">NSAttributedString boundingRectWithSize:options:context:</a> 来计算文本宽高，用 -<a href="/">NSAttributedString drawWithRect:options:context:</a> 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程</li>
<li>为了帮助你发现你的代码的问题，你可以使用Xcode来分析你的代码，帮助你找到出现问题的地方。注意，Xcode分析项目，它会指出每一个潜在的可能出现的问题的地方。从Xcode的 Product菜单选择 Analyze或按 Shift-Command-B.Xcode的将需要片刻的时间，但是当它完成的时候你会在左边的 Issue Navigator看到问题列表。由Analyze发现的问题用蓝色高亮显示</li>
<li>多视图控制器跳转方法<ol>
<li>Modal：<br> 打开：presentViewController<br> 关闭：dismissViewController</li>
<li>Push:需搭配NavigationController使用，采用压栈和出栈的方式<br> 打开：pushViewController<br> 关闭：popViewController</li>
<li>Segue：以上两种方式都可以，如果在打开目标控制器前需要额外处理，可使用perfromSegueWithIdentifier方法。Identifier在storyboard里设置。</li>
</ol>
</li>
<li>设置UIImage的渲染模式：你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/03/31/Tips201603/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/03/31/Tips201603/'>开发Tips收集-2016年03月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<ol>
<li>UIImageRenderingModeAutomatic  // 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。  </li>
<li>UIImageRenderingModeAlwaysOriginal   // 始终绘制图片原始状态，不使用Tint Color。  </li>
<li>UIImageRenderingModeAlwaysTemplate   // 始终根据Tint Color绘制图片，忽略图片的颜色信息。  </li>
</ol>
</li>
<li>引入了Foundation以后，数组会映射为<a href="/">AnyObject</a>,而值类型会映射了对应的Foundation类型（比如NSString，NSNumber等），也就是AnyObject了</li>
<li>在lldb中一键打开模拟器sandbox路径：<br>  打开/.lldbinit，在里面加入一行：<br>  <code>command alias sb script from subprocess import call; call([&quot;open&quot;, &#39;{0:s}&#39;.format(lldb.frame.EvaluateExpression(&quot;NSHomeDirectory()&quot;)).split(&quot;\&quot;&quot;)[1]]);</code><br>  然后中断时，在lldb里打sb回车，就能打开模拟器当前运行的app的沙箱路径了</li>
<li>UINavigationController导航控制器，是多个界面间跳转的重要元素，可以理解为它存储着多个viewController，它的存储结构是栈，栈的特点是先进后出。</li>
<li>UINavigationController有几个常用的方法：<br>  1：<a href="/">UINavigationController initWithRootViewController：viewController </a> 是指将哪一个视图控制器设置为导航控制器的根视图控制器，即运行是第一次看到的界面。<br>  2：<a href="/">UINavigationController  pushViewController：viewController animated：BOOL</a> 是指将视图控制器送入堆栈，跳转到下一个视图控制器，即下一个界面。<br>  3：<a href="/">UINavigationController popViewControlleranimated：BOOL </a>是指将栈顶的试图控制器移出，即返回上一个界面。<br>  4：<a href="/">UINavigationController popToRootViewControlleranimated：BOOL </a>是指直接返回到根视图控制器，即返回第一个界面。<br>  5：<a href="/">UINavigationController popViewController：viewController  animated：BOOL </a> 跳转到对应的视图控制器，即相应界面。<br>  UINavigationController有一个属性，viewcontrollers，它是一个数组，所有视图控制器都被包含在其中，试图控制器在其中的位置跟UINavigationController的顺序一样。可以通过<a href="/">array objectAtIdenx:index</a>得到相应的视图控制器。</li>
<li>在使用单例模式时一般使用allocWithZone，因为alloc最终还是会调用allocWithZone进行分配空间</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIProgressView 的 subviews 是两个 UIImageView，第一个是 TrackTintColor 层（轨道），第二个是 Progress Tint Color 层（进度）</li>
<li>如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 <a href="/">NSAttributedString boundingRectWithSize:options:context:</a> 来计算文本宽高，用 -<a href="/">NSAttributedString drawWithRect:options:context:</a> 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程</li>
<li>为了帮助你发现你的代码的问题，你可以使用Xcode来分析你的代码，帮助你找到出现问题的地方。注意，Xcode分析项目，它会指出每一个潜在的可能出现的问题的地方。从Xcode的 Product菜单选择 Analyze或按 Shift-Command-B.Xcode的将需要片刻的时间，但是当它完成的时候你会在左边的 Issue Navigator看到问题列表。由Analyze发现的问题用蓝色高亮显示</li>
<li>多视图控制器跳转方法<ol>
<li>Modal：<br> 打开：presentViewController<br> 关闭：dismissViewController</li>
<li>Push:需搭配NavigationController使用，采用压栈和出栈的方式<br> 打开：pushViewController<br> 关闭：popViewController</li>
<li>Segue：以上两种方式都可以，如果在打开目标控制器前需要额外处理，可使用perfromSegueWithIdentifier方法。Identifier在storyboard里设置。</li>
</ol>
</li>
<li>设置UIImage的渲染模式：你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[域名更新]]></title>
    <link href="http://conanwhf.coding.me/2016/03/02/addressUpdate/"/>
    <id>http://conanwhf.coding.me/2016/03/02/addressUpdate/</id>
    <published>2016-03-02T09:35:25.000Z</published>
    <updated>2016-03-02T10:24:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u9996_u5148_uFF0C_http_3A//conanwhf-github-io__u8FD8_u662F_u53EF_u7528_u4E3B_u529B_u54C8_uFF01"><a href="#u9996_u5148_uFF0C_http_3A//conanwhf-github-io__u8FD8_u662F_u53EF_u7528_u4E3B_u529B_u54C8_uFF01" class="headerlink" title="首先， http://conanwhf.github.io 还是可用主力哈！"></a>首先，<a href="http://conanwhf.github.io" target="_blank" rel="external"> http://conanwhf.github.io</a> 还是可用主力哈！</h2><p>主要是怕哪天GFW发威上不了了，所以在国内服务商放个镜像而已。</p>
<h2 id="u5899_u5185_u65B0_u57DF_u540D_uFF1Ahttp_3A//conanwhf-coding-me/"><a href="#u5899_u5185_u65B0_u57DF_u540D_uFF1Ahttp_3A//conanwhf-coding-me/" class="headerlink" title="墙内新域名：http://conanwhf.coding.me/"></a>墙内新域名：<a href="http://conanwhf.coding.me/">http://conanwhf.coding.me/</a></h2><p>旧的gitcafe那个，就不用了</p>
<p>周末爬山下海的，肌肉酸痛还没解除，就看到GitCafe要关闭，整个迁移到Coding去了，晕！连封邮件也没发给我，突然就说什么要全部迁移删除，然后一看时间，最后期限5月份，但是从今天开始就全部只读了……😡我真是服了国内的这些服务商，不靠谱到了一个境界。还能怎么办呢？迁移呗！本来因为是中文博客，我的各种相关配置和网络服务都注册的是GitCafe的域名，这次也都要检查一遍、修改更换，麻烦死了。以后还是准备回归GitHub为主吧！<br>另外，因为gitcafe已经全面只读了，我连提交个域名更新说明的机会都没，真是@#$$(%#^%^)$$%^%$#$%😤😱<br>长长的年过完了，紧接着又巴厘岛玩了几天，以至于留下了太多功课没有做完。家里两位老人天天拉着我聊天修电脑，再加上新接了个项目，搞OpenCV和C++搞得连轴转，更没时间管iOS的东西了。想想每天也没做什么，过个年，跑跑步，吃三顿饭，刷刷新闻社交，帮公婆处理点杂事，研究旅游的各种事情，最后出去玩一趟，怎么哗哗哗一个月就过去了？！搞得我好焦虑，害怕项目进度赶不完。怎么办！！！</p>
<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/03/02/addressUpdate/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/03/02/addressUpdate/'>域名更新</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u9996_u5148_uFF0C_http_3A//conanwhf-github-io__u8FD8_u662F_u53EF_u7528_u4E3B_u529B_u54C8_uFF01"><a href="#u9996_u5148_uFF0C_http_3A//conanwhf-github-io__u8FD8_u662F_u53EF_u7528_u4E3B_u529B_u54C8_uFF01" class="headerlink" title="首先， http://conanwhf.github.io 还是可用主力哈！"></a>首先，<a href="http://conanwhf.github.io"> http://conanwhf.github.io</a> 还是可用主力哈！</h2><p>主要是怕哪天GFW发威上不了了，所以在国内服务商放个镜像而已。</p>
<h2 id="u5899_u5185_u65B0_u57DF_u540D_uFF1Ahttp_3A//conanwhf-coding-me/"><a href="#u5899_u5185_u65B0_u57DF_u540D_uFF1Ahttp_3A//conanwhf-coding-me/" class="headerlink" title="墙内新域名：http://conanwhf.coding.me/"></a>墙内新域名：<a href="http://conanwhf.coding.me/">http://conanwhf.coding.me/</a></h2><p>旧的gitcafe那个，就不用了</p>
<p>周末爬山下海的，肌肉酸痛还没解除，就看到GitCafe要关闭，整个迁移到Coding去了，晕！连封邮件也没发给我，突然就说什么要全部迁移删除，然后一看时间，最后期限5月份，但是从今天开始就全部只读了……😡我真是服了国内的这些服务商，不靠谱到了一个境界。还能怎么办呢？迁移呗！本来因为是中文博客，我的各种相关配置和网络服务都注册的是GitCafe的域名，这次也都要检查一遍、修改更换，麻烦死了。以后还是准备回归GitHub为主吧！<br>另外，因为gitcafe已经全面只读了，我连提交个域名更新说明的机会都没，真是@#$$(%#^%^)$$%^%$#$%😤😱<br>长长的年过完了，紧接着又巴厘岛玩了几天，以至于留下了太多功课没有做完。家里两位老人天天拉着我聊天修电脑，再加上新接了个项目，搞OpenCV和C++搞得连轴转，更没时间管iOS的东西了。想想每天也没做什么，过个年，跑跑步，吃三顿饭，刷刷新闻社交，帮公婆处理点杂事，研究旅游的各种事情，最后出去玩一趟，怎么哗哗哗一个月就过去了？！搞得我好焦虑，害怕项目进度赶不完。怎么办！！！</p>]]>
    
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年02月]]></title>
    <link href="http://conanwhf.coding.me/2016/03/01/Tips201602/"/>
    <id>http://conanwhf.coding.me/2016/03/01/Tips201602/</id>
    <published>2016-03-01T09:25:39.000Z</published>
    <updated>2016-03-02T09:12:49.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIView 的translatesAutoresizingMaskIntoConstraints属性为true时，设置 frame 会自动转化为约束，修改 frame 时也会自动调整约束。这时候就不要再手动添加约束了，你再添加约束往往会造成冲突</li>
<li>使用XCODE交付应用，常见的返回错误：<ol>
<li>ERROR：–90096 ：原因是：启动图的问题；解决 ：添加一张名字是 Default-568h@2x.png 的启动图；</li>
<li>ERROR：–90535 ：原因是：导入的第三方的问题；解决 ：删除第三方包中的info.plist里的Executable file 这一行</li>
</ol>
</li>
<li>ios下每个app可用的内存是被限制的，如果一个app使用的内存超过了这个阀值，则系统会向该app发送Memory Warning消息。收到消息后，app必须尽可能多的释放一些不必要的内存，否则OS会关闭app。</li>
<li>数组的contains方法需要用到==操作符，所以当数组的内容为自定义类型，且需要使用contains方法是，需要自定义的类实现Equatable协议即可</li>
<li>Swift 的枚举类型，如果指定了原始值的类型（Int， String等），就会有默认值的存在。如果不指定原始值类型，编译器就不会分配默认值。<ol>
<li>当枚举类型的原始值类型指定为 Int 时，这个时候，就和其他语言的枚举的默认值分配一样，从0开始</li>
<li>如果指定了一个枚举值的原始值，后面接下来的枚举值的原始值会自动 +1</li>
<li>原始值类型为字符串的时候，默认的值就是和枚举值的字符串一样</li>
<li>没有设置原始值的，就使用默认值</li>
</ol>
</li>
<li>开发中经常会遇到控件不接收用户交互了，可以从以下几个方面检查：<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/03/01/Tips201602/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/03/01/Tips201602/'>开发Tips收集-2016年02月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<ol>
<li>enable = NO 就不可以被点击 ->也会让按钮显示禁用状态</li>
<li>设置了控件的 userInterActionEnabel = NO</li>
<li>hidden属性为YES</li>
<li>控件的alpha \&lt; = 0.01</li>
<li>如果一个父控件与用户的交互设置为NO ,那么它子控件将获取不到交互事件</li>
<li>如果子视图超出父视图范围,超出范围的部分也不能接收用户交互</li>
</ol>
</li>
<li>UIApplication 中 statusBarOrientation 属性在ios 9 中已经不能用了 项目中需要横屏的页面直接隐藏了状态栏</li>
<li>自定义一个cell继承自UITableViewCell，然后重载它的以下两个方法:<ul>
<li>(void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;</li>
<li>(void)setSelected:(BOOL)selected animated:(BOOL)animated;<br>发现当我们点击cell的时候，其实是先设置cell的高亮状态为YES，然后松手的时候再将cell的高亮状态设置为NO，接着才是设置cell的选中状态为YES，最后才会去调用didSelectRowAtIndexPath:方法。<br>由此可见：cell的高亮状态是不能持久的，即tap的时候会变成高亮，松手的时候就会自动设置为非高亮状态。而cell的选中状态则是可以持久的，我们不去触发它改变状态，则选中状态就不会</li>
</ul>
</li>
<li>awakeFromNib和viewDidLoad的区别：<br>  <strong>awakeFromNib</strong>:当.nib文件被加载的时候，会发送一个awakeFromNib的消息到.nib文件中的每个对象，每个对象都可以定义自己的 awakeFromNib函数来响应这个消息，执行一些必要的操作。也就是说通过nib文件创建view对象是执行awakeFromNib 。<br>  <strong>viewDidLoad</strong>:当view对象被加载到内存是就会执行viewDidLoad，所以不管通过nib文件还是代码的方式创建对象都会执行viewDidLoad。</li>
<li>UIWebView要实现横向滑动，跟UIWebview的增高没有关系，你需要设定UIWebView的属性scrollView的contentsize.width大于UIWebView的frame.size.width.</li>
<li>到 Xcode 5.1， iOS SDK 7.1 后，TableView Cell clipsToBounds 属性默认都是NO，导致以前用的把cell的height设为0来隐藏某个cell的方法没用了。cell内容会叠起来。 解决方法就是手动把clipsToBounds改YES，或者Storyboard里Clip Subview打勾。</li>
<li>CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当的高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。</li>
<li>在IOS7以后 ViewController 开始使用全屏布局的，而且是默认的行为通常涉及到布局，就离不开这个属性 edgesForExtendedLayout，它是一个类型为UIExtendedEdge的属性，指定边缘要延伸的方向，它的默认值很自然地是UIRectEdgeAll，四周边缘均延伸，就是说，如果即使视图中上有navigationBar，下有tabBar，那么视图仍会延伸覆盖到四周的区域。一般为了不让tableView 不延伸到 navigationBar 下面，属性设置为 UIRectEdgeNone</li>
<li>当一个iOS应用被送到后台，它的主线程会被暂停。你用NSThread的detachNewThreadSelector:toTar get:withObject:类方法创建的线程也被挂起了。如果你想在后台完成一个长期任务，就必须调用UIApplication的beginBackgroundTaskWithExpirationHandler:实例方法，来向iOS借点时间。UIApplication的backgroundTimeRemaining属性包含了程序完成他的任务可以使用的秒数。如果在这个期限内，长期任务没有被完成，iOS将终止程序。每个对beginBackgroundTaskWithExpirationHandler:方法的调用，必须要相应的调用endBackgroundTask:方法（UIApplication的另一个实例方法）。</li>
<li>为了保持用户界面的响应，iOS系统包括一个看门狗机制。如果您的应用程序未能响应某些用户界面事件（启动、暂停、恢复、终止）的时间，该看门狗将杀死您的应用程序，并产生一个看门狗超时崩溃报告</li>
<li>setNeedsUpdateConstraints 确保在未来的某个阶段updateConstraintsIfNeeded这个方法会调用 updateConstraints.<br>  setNeedsLayout 确保在未来的某个阶段 layoutIfNeeded 这个方法会调用 layoutSubviews.<br>  直接调用setNeedsUpdateConstraints去更新约束是很奇怪的，因为只有在某些情况下你的某个约束失效了，你需要移除它，这时候才需要直接调用这个方法。</li>
<li>在制作动画前，需要弄清楚anchorPoint与position之间的关系，对最终将动画渲染在屏幕上的位置至关重要。<pre><code>1. position:CAReplicatorLayer的position决定了其在父视图中位置坐标。
2. anchorPoint：CAReplicatorLayer的anchorPoint决定了其position的位置。anchorPoint的默认值为(0.5, 0.5),此时CAReplicatorLayer在父视图中坐标位置对应其中心点的坐标。
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIView 的translatesAutoresizingMaskIntoConstraints属性为true时，设置 frame 会自动转化为约束，修改 frame 时也会自动调整约束。这时候就不要再手动添加约束了，你再添加约束往往会造成冲突</li>
<li>使用XCODE交付应用，常见的返回错误：<ol>
<li>ERROR：–90096 ：原因是：启动图的问题；解决 ：添加一张名字是 Default-568h@2x.png 的启动图；</li>
<li>ERROR：–90535 ：原因是：导入的第三方的问题；解决 ：删除第三方包中的info.plist里的Executable file 这一行</li>
</ol>
</li>
<li>ios下每个app可用的内存是被限制的，如果一个app使用的内存超过了这个阀值，则系统会向该app发送Memory Warning消息。收到消息后，app必须尽可能多的释放一些不必要的内存，否则OS会关闭app。</li>
<li>数组的contains方法需要用到==操作符，所以当数组的内容为自定义类型，且需要使用contains方法是，需要自定义的类实现Equatable协议即可</li>
<li>Swift 的枚举类型，如果指定了原始值的类型（Int， String等），就会有默认值的存在。如果不指定原始值类型，编译器就不会分配默认值。<ol>
<li>当枚举类型的原始值类型指定为 Int 时，这个时候，就和其他语言的枚举的默认值分配一样，从0开始</li>
<li>如果指定了一个枚举值的原始值，后面接下来的枚举值的原始值会自动 +1</li>
<li>原始值类型为字符串的时候，默认的值就是和枚举值的字符串一样</li>
<li>没有设置原始值的，就使用默认值</li>
</ol>
</li>
<li>开发中经常会遇到控件不接收用户交互了，可以从以下几个方面检查：]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[过年好！]]></title>
    <link href="http://conanwhf.coding.me/2016/02/06/ChineseNewYear2016/"/>
    <id>http://conanwhf.coding.me/2016/02/06/ChineseNewYear2016/</id>
    <published>2016-02-06T13:35:25.000Z</published>
    <updated>2016-02-06T16:11:47.000Z</updated>
    <content type="html"><![CDATA[<p>明天就除夕了，祝大家新年好！阖家团圆、幸福安康！<br>不过我对于过年还是没什么感觉，似乎就是一个普通周末。公婆也都来了，每天菜场、超市的，我却没进入状态，总想着我还有一堆bug和学习计划没完成呢！<br>前段时间不怎么顺，首先是去Apple申请了个独立开发者帐号，因为我新加坡和中国的各种信息混在一起，还有税单和银行的问题，跟Apple客服一直来往邮件，墨迹了好久。<br>然后是费劲周折提交了个新闻阅读器，审查了半个月说是版权问题，幸好一开始就只是抱着熟悉流程的期望值。话说对于新手来说，提交的坑实在是太多了……我对照着两个教程，硬生生上传了4个版本、cancel一次、才最终成功提交审核，个中曲折，原本打算上架后好好写一遍教程，现在只好写个“上架不成功踩雷指南”了。😂<br>最后，自己身体也似乎有点报警，现在每天起床后去健身房跑步30分钟（其实最多只能连续跑5分钟，几次间断加起来也不超过15分钟），坚持了两周，似乎有所改善。不由得感叹生命真的在于运动，对我这种万年宅来说必须要逼一逼自己，开始运动不能拖！<br>最后，之前提到的那个新闻阅读器，既然无法上架，那就开源吧。虽然我想对于我这样的新手而且是野路子自学的来说，写的code估计烂得不忍直视……纯手打代码，没用任何第三方库，因为是自用，所以会不定时更新，希望至少能帮到一点点比我更新手的新新手？不过APP所阅读的新闻源，是需要翻墙的……不啰嗦，地址：<a href="https://github.com/conanwhf/NewsReader" target="_blank" rel="external">https://github.com/conanwhf/NewsReader</a><br>另外顺便开源一下我的家庭环境检测系统，用于树莓派，前几天把各个sensor的code做成库整合了一下，过几天准备加屏幕驱动，教程有空再写吧。初学python，也是在瞎玩玩，给新手linux玩家多一个参考：<a href="https://github.com/conanwhf/Rpi-envMonitor" target="_blank" rel="external">https://github.com/conanwhf/Rpi-envMonitor</a></p>
<p>新年祝好！愿所有人平安健康，幸福安宁！愿台湾地震的灾民尽快获得安顿、不要在流离失所中过年！🙏</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>明天就除夕了，祝大家新年好！阖家团圆、幸福安康！<br>不过我对于过年还是没什么感觉，似乎就是一个普通周末。公婆也都来了，每天菜场、超市的，我却没进入状态，总想着我还有一堆bug和学习计划没完成呢！<br>前段时间不怎么顺，首先是去Apple申请了个独立开发者帐号，因为我新]]>
    </summary>
    
      <category term="NewYear" scheme="http://conanwhf.coding.me/tags/NewYear/"/>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年01月]]></title>
    <link href="http://conanwhf.coding.me/2016/01/31/Tips201601/"/>
    <id>http://conanwhf.coding.me/2016/01/31/Tips201601/</id>
    <published>2016-01-31T09:25:39.000Z</published>
    <updated>2016-01-31T09:35:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>你可以在 Gemfile 中指定 cocoapods gem 的使用版本。<br>  <code>source &#39;https://rubygems.org&#39;</code><br>  <code>gem &#39;cocoapods&#39;, &#39;0.39.0&#39;</code><br>  当你更新了 Gemfile 文件并且自动安装了正确版本的 gem 后，确保团队的每个成员都运行一次 <code>bundle install</code> 这条命令。此后，只需要运行 <code>bundle exec pod install</code> 这条命令来安装新的 CocoaPods——这将会确保通过你在的 Gemfile 中指定 cocoapods gem 的版本后，pods 仍可以被正确的安装。</li>
<li>instrument调试后，发现没被释放的全是imageIO，差不多就知道了，把读图的方式，从UIImage imageNamed:@”“,改成imageWithContentsOfFile，就可以了。问题原因：imageNamed读取图片的方法，会缓存在内存中，所以较大的图片，还是用<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/01/31/Tips201601/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/01/31/Tips201601/'>开发Tips收集-2016年01月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
 imageWithContentsOfFile。<br>  Tip1：.xcassets里的图片无法用imageWithContentsOfFile读取；<br>  Tip2：imageWithContentsOfFile读取图片需要加文件后缀名如png，jpg等； </li>
<li>不要将旋转视作设备的移动。相反将其视为视图控制器尺寸的改变，因为从用户的角度来看，这才是真实发生的操作。<ul>
<li>资源文件瘦身：<ol>
<li>减少图片和音频文件的大小</li>
<li>对于PNG图片，由于它内部保存了额外的分层和透明通道信息，统称为EXIF，所以它会比JPG图片大一些。App开发推荐使用PNG图片是因为XCode会在打包时压缩PNG图片的大小。</li>
<li>单色图片使用使用字体文件。关于字体文件的技术，也就是IconFont，网上有很多例子，同时适用于Andorid和iOS</li>
<li>使用.9图。之所周知.9图是Android的技术，能极大减小图片的体积，殊不知，iOS也有类似的实现方式。</li>
<li>动态下载表情包。把聊天时用到的表情图片，做成从服务器下载zip包的方式，而不是打包在App中。</li>
<li>清除不再使用的图片。</li>
</ol>
</li>
</ul>
</li>
<li>.a文件瘦身<ol>
<li>冗余的类和方法。</li>
<li>相似度极高的代码片段</li>
<li>使用代码生成UI，而不是使用Xib或Storyboard。经过测试，对于同一个页面，使用代码而导致的.a文件增加的体积，大于Xib的体积。</li>
<li>使用Hybird方案来代替iOS原生代码。</li>
<li>编译选项的优化。比如说Strip Link Product设为Yes啊，Make Strings Read-Only设为Yes啊，去掉异常支持啊，都能减少包的大小。此外，经常检查LinkMap文件，也是控制瘦身的一个办法。</li>
</ol>
</li>
<li>flatMap()与map()其实非常相似，map()的规则是T->U，而flatMap()的规则是T->U?，而且如果转换的结果是nil的话，flatMap()是不会将其添加到输出的array中的。 因此可以说flapMap()就好像你去使用map()，然后扁平化(faltten)地从结果中去除了那些nil的内容。</li>
<li>事件（比如，触摸事件（touch event））都使用响应链来传递。响应链由响应者对象（Responder Objects，苹果官方术语）构成。UIView 和 UIViewController 都是响应者对象。这就意味着， UIView 和 UIViewController 都继承自 UIResponder </li>
<li><strong>(void)prepareLayout</strong>; 第一次加载layout、刷新layout、以及- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;这个方法返回yes时，会调用。实现该方法后应该调用［super prepareLayout］保证初始化正确。该方法用来准备一些布局所需要的信息。该方法和init方法相似，但该方法可能会被调用多次，所以一些不固定的计算（比如该计算和collectionView的尺寸相关），最好放在这里，以保证collectionView发生变化时，自定义CollectionView能做出正确的反应</li>
<li>KVC 机制是由一个协议 NSKeyValueCoding 定义的。NSObject 帮我们实现了这个协议，所以 KVC 核心的逻辑都在 NSObject 中，我们继承 NSObject 才能让我们的类获得 KVC 的能力。另外，因为 Swift 中的 Optional 机制，所以 valueForKey 方法返回的是一个 Optional 值，我们还需要对返回值做一次解包处理，才能得到实际的属性值。</li>
<li>UINavigationController介绍<ol>
<li>UINavigationController是导航控制器，它通过栈的方式控制当前显示在屏幕上的是哪个控制器。</li>
<li>它可以通过压入(push)和弹出(pop)来改变控制器的层次。</li>
<li>自动提供返回(Back)按钮，以回到上一个压入的控制器，不需要额外编程</li>
<li>UINavigationController会提供控制器切换的动画效果</li>
<li>UINavgationController通过栈的形式管理多个UIViewController（即多个界面）</li>
<li>可以管理当前在导航条(navigationBar)上的导航按钮</li>
<li>UINavgationController为每个接受它管理的UIViewController自动添加UINavigationBar</li>
</ol>
</li>
<li>类似于画板这样画线条的需求直接用专有图层CAShapeLayer。CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。用CGPath来定义想要绘制的图形，CAShapeLayer会自动渲染。它可以完美替代我们的直接使用Core Graphics绘制layer，对比之下使用CAShapeLayer有以下优点：<ol>
<li>渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。</li>
<li>不会出现像素化。</li>
</ol>
</li>
<li>使用串行队列的优点：<ol>
<li>能确保对一个共享资源进行串行化的访问，避免了竞态条件；</li>
<li>任务的执行顺序是可预知的；你向一个串行队列提交任务时，它们被执行的顺序与它们被提交的顺序相同；</li>
<li>你可以创建任意数量的串行队列；</li>
</ol>
</li>
<li>父视图通过tag取得子视图(viewWithTag)的顺序是深度优先，也就是先查看自己的第一个子视图，然后查看第一个子视图的所有子视图的tag值，直到第一个子视图下的所有子视图搜索完，再搜索自己第二个子视图，直到找到为止。找不到就返回nil</li>
<li>继承定义了这个对象是什么，而特性则定义了这个对象能做什么<br>更棒的消息是：一个类可以部署很多特性，也就是可以同时做很多事情，这是只从单一父类继承而来的子类所不可企及的，因为他们一次只能做一件事情。</li>
<li>动画属性UIViewAnimationOptions说明<ol>
<li>常规动画属性设置（可以同时选择多个进行设置）<br>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。<br>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。<br>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。<br>UIViewAnimationOptionRepeat：重复运行动画。<br>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。<br>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。<br>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。<br>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。<br>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</li>
<li>动画速度控制（可从其中选择一个设置）<br>UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。<br>UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。<br>UIViewAnimationOptionCurveEaseOut：动画逐渐加速。<br>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</li>
<li>转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）<br>UIViewAnimationOptionTransitionNone：没有转场动画效果。<br>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。<br>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。<br>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。<br>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。<br>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</li>
</ol>
</li>
<li>每当在UICollectionView显示它的subview之前调用scrollToItemAtIndexPath:atScrollPosition:Animated方法，UIKit就会报错。所以要解决它，就应该在viewController中，在你能确认CollectionView完全计算出其subview布局的地方去调用这个方法。比如在viewDidLayoutSubviews里调用就没有问题。</li>
<li>设置缓存只需要：<strong>如果你已经使用 了 GET 请求，iOS 系统 SDK 已经帮你做好了缓存</strong>。你需要的仅仅是设置下内存缓存大小、磁盘缓存大小、以及缓存路径。甚至这两行代码不设置也是可以的，会有一个默认值。代码如下：<br>NSURLCache <em>urlCache = [[NSURLCache alloc] initWithMemoryCapacity:4 </em> 1024 <em> 1024 diskCapacity:20 </em> 1024 * 1024 diskPath:nil];<br>[NSURLCache setSharedURLCache:urlCache];</li>
<li>在 LLDB 中输入 <code>fr v -R foo</code>，可以查看 foo 这个变量的内存构成。</li>
<li>倘若一个标记为 lazy 的属性同时被多个线程修改时，且该属性还未进行初始化操作，那么将无法保证该属性仅被初始化一次。</li>
<li>页面跳转必须在viewDidLoad和viewDidAppear之后才能进行</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>你可以在 Gemfile 中指定 cocoapods gem 的使用版本。<br>  <code>source &#39;https://rubygems.org&#39;</code><br>  <code>gem &#39;cocoapods&#39;, &#39;0.39.0&#39;</code><br>  当你更新了 Gemfile 文件并且自动安装了正确版本的 gem 后，确保团队的每个成员都运行一次 <code>bundle install</code> 这条命令。此后，只需要运行 <code>bundle exec pod install</code> 这条命令来安装新的 CocoaPods——这将会确保通过你在的 Gemfile 中指定 cocoapods gem 的版本后，pods 仍可以被正确的安装。</li>
<li>instrument调试后，发现没被释放的全是imageIO，差不多就知道了，把读图的方式，从UIImage imageNamed:@”“,改成imageWithContentsOfFile，就可以了。问题原因：imageNamed读取图片的方法，会缓存在内存中，所以较大的图片，还是用]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在树莓派RaspberryPi上几种简单协议的实现]]></title>
    <link href="http://conanwhf.coding.me/2016/01/30/rpi-protocol/"/>
    <id>http://conanwhf.coding.me/2016/01/30/rpi-protocol/</id>
    <published>2016-01-30T09:31:26.000Z</published>
    <updated>2016-08-26T05:05:24.000Z</updated>
    <content type="html"><![CDATA[<p>对自己的拖延症也真是恨铁不成钢，这又是一篇拖延得快要放弃的文章。快过年了，怎么也不能拖到年后，打起精神，清空列表！</p>
<p>想要自己打造一个小小家庭环境监控系统，各种Sensor不可或缺。看了下大部分人在树莓派上都用Python, 我也来凑个热闹。Python果然是一种很容易入门的语言，我只是稍微查了下资料，半天时间，就搞定了好几个Sensor，当然只是最简单的拿数据什么的，但相比之下，虽然自己对于用C写这些协议很熟，碰到问题我也宁可去看看Python的语法也不愿意换C……Python的优势倒不全是语法简洁，最重要的是有巨量的开发库可以用。像这些简单的协议，全是把库装好，直接拿来用就可以了，看看代码量，简直让人不忍再直视C的代码。对于不用追求速度的玩票项目，相当适合。<br>这一篇先介绍几种最常用的基本协议的实现，老规矩，先上源码<a href="https://github.com/conanwhf/RaspberryPi-script" target="_blank" rel="external">传送门</a><br><a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/01/30/rpi-protocol/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/01/30/rpi-protocol/'>在树莓派RaspberryPi上几种简单协议的实现</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>GPIO口很简单，要不输入，要不输出。先装一下开发库：<br><code>sudo apt-get install python-rpi.gpio</code><br>然后在代码里面引用：</p>
<pre><code>import time
import RPi.GPIO as GPIO
# 定义引脚
gpio_pin=17
print(&quot;start gpio test for pin=bcm%d&quot; %pin)
GPIO.setmode(GPIO.BCM)
# 设为Input，读取GPIO
GPIO.setup(pin, GPIO.IN)
value = GPIO.input(pin)
print(&quot;before set, pin=%d&quot; %value)
# 改变GPIO输出
GPIO.setup(pin, GPIO.OUT)
GPIO.output(pin, value)
print(&quot;now pin=%d&quot; %GPIO.input(pin))
GPIO.cleanup()
</code></pre><p>这里只是一个Demo，实际应用中不大有能让你随便拉高拉低还能保持住你设置的情况。一般像灯啊之类的，就是你拉高它就亮拉低它就黑；要不就是一些输入设备类似按键，或者更复杂的有Timing的输入。这里要注意两点：</p>
<ol>
<li>setmode用的是BCM模式，所用的Pin也要跟引脚图上相对应的BCM号码相同。你也可以设成物理管脚号，用<code>setmode(GPIO.BOARD)</code>。</li>
<li>input/output模式是相对于host也就是树莓派来说的接收数据/状态的时候是input，输出状态的时候是output</li>
</ol>
<h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h2><p>I2C是可以一条总线接n个设备的，只要设备的I2C地址不冲突，你尽可以用面包板扩展一下，接上好几个。首先依然是添加开发库，注意这个库貌似只在python2里用，如果我换python3就会报错找不到，可能我不太熟吧……<br><code>sudo apt-get -y install python-smbus</code><br>然后接好硬件，如果你需要确认一下硬件，可以用i2c的工具看看：</p>
<pre><code>sudo apt-get -y install i2c-tools
sudo i2cdetect -y 1
</code></pre><p>参数1是指设备i2c-1，在rpi2上默认就是1，i2c0预留给E2PROM用了，没去折腾打开它。如果你看到一个类似下面的结果，说明硬件已经OK了。<br><img src="http://whf.d.pr/dVNW+" alt=""><br>上面的图表示有两个I2C设备接在总线上，它们的地址分别是0x48和0x77。如果你没看见有设备，检查硬件连接，还有记得在系统的config里面打开i2c。<br>然后依然是sample code：</p>
<pre><code>import time
import smbus

addr=0x48
cmd=0xAB
# 打开 /dviev/i2c-1  
bus = smbus.SMBus(1)
# 读写数据，case 1
data = bus.read_byte(addr)
bus.write_byte(addr, data+1)
# 读写数据，case 2
data = bus.read_byte_data(addr, cmd)
bus.write_byte_data(addr, cmd, data+1)
</code></pre><p> 大部分I2C设备的读写，除了需要i2c device地址以外，还要有一些固定cmd，所以读写接口是有两种，具体要看设备spec里面的要求，大同小异。</p>
<h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>串口UART通信主要有两种，一种是用来调试的命令行，一种是sensor的数据接口。总觉得串口调试是很久远的事情了，特别是在树莓派上，基本上都是网络ssh吧。看了些其他的例程，都是做串口调试，其实如果只是拿个数据没那么复杂。<br>首先当然还是装酷(库)：<br><code>sudo apt-get -y install python-serial</code><br>然后多做一步：树莓派默认的console是UART输出的，改掉（记得用sudo改）。<br>  打开<strong>/boot/cmdline.txt</strong>，里面的内容”dwc_otg.lpm_enable=0 <strong>console=ttyAMA0,115200</strong> console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline<br>fsck.repair=yes rootwait”，粗体字部分删掉，因为ttyAMA0就是我们要使用的设备。<br>在部分别的文章中见过还需要改一个地方，可能是上一代rpi用的，如果你的系统是最新的，不需要做。<br>测试代码部分：</p>
<pre><code>import serial
import time

def showdata(arg):
    result = &apos;&apos;
    for i in arg:
        st = &apos;%02X&apos;%ord(i)
        result += st+&apos; &apos;
    print(result)

ser = serial.Serial(&apos;/dev/ttyAMA0&apos;, 9600, timeout=1)
# 获得接收缓冲区字符
#count = ser.inWaiting()
# 读取内容
data = ser.read(5)
showdata(data)
# 清空接收缓冲区
#ser.flushInput()
ser.close()
</code></pre><p> 上面的code中，函数showdata()是我自己加的用来打印读取到的16进制数据的。因为我接的设备是一个sensor而不是字符设备，所以需要转换一下。同样的，被注释掉的inWaiting()和flushInput()函数，是给字符输入输出设备用的，我也没测过，在我的机子上，因为sensor会不停地报数据，简单的read就行了。<br>另外硬件连接方面很重要的一点：</p>
<blockquote>
<p><strong>树莓派的TX要连接从设备的RX，树莓派的RX要连接从设备的TX!!!</strong></p>
</blockquote>
<p>不要搞反了，不然是出不来数据的！</p>
<h2 id="SPI-_u6682_u65F6_u6CA1_u6709"><a href="#SPI-_u6682_u65F6_u6CA1_u6709" class="headerlink" title="SPI-暂时没有"></a>SPI-暂时没有</h2><p>本来是买了个SPI的屏幕，谁知快递出问题没送到，好不容易收到了找卖家要资料也总是忘掉，所以只好欠奉了。快过年了，估计得过些日子再说吧！<br>话说，家里的NAS系统升级以后，居然admin也不是root权限了，好多隐藏的文件夹都打不开。我的BitSync出了点问题，想去看看配置文件，也是束手无策。看来Qnap是不打算给人玩了，认认真真做商业机。幸好有树莓派，以后玩点乱七八糟的东西，就只能靠它了。<br>另：我Github上的源码中，有几个传感器的demo，包括bmp180,dht11,pcf8591等，需要的话随意取用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对自己的拖延症也真是恨铁不成钢，这又是一篇拖延得快要放弃的文章。快过年了，怎么也不能拖到年后，打起精神，清空列表！</p>
<p>想要自己打造一个小小家庭环境监控系统，各种Sensor不可或缺。看了下大部分人在树莓派上都用Python, 我也来凑个热闹。Python果然是一种很容易入门的语言，我只是稍微查了下资料，半天时间，就搞定了好几个Sensor，当然只是最简单的拿数据什么的，但相比之下，虽然自己对于用C写这些协议很熟，碰到问题我也宁可去看看Python的语法也不愿意换C……Python的优势倒不全是语法简洁，最重要的是有巨量的开发库可以用。像这些简单的协议，全是把库装好，直接拿来用就可以了，看看代码量，简直让人不忍再直视C的代码。对于不用追求速度的玩票项目，相当适合。<br>这一篇先介绍几种最常用的基本协议的实现，老规矩，先上源码<a href="https://github.com/conanwhf/RaspberryPi-script">传送门</a><br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://conanwhf.coding.me/tags/Python/"/>
    
      <category term="Script" scheme="http://conanwhf.coding.me/tags/Script/"/>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/categories/RaspberryPi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微波炉的悲剧]]></title>
    <link href="http://conanwhf.coding.me/2016/01/22/microwave/"/>
    <id>http://conanwhf.coding.me/2016/01/22/microwave/</id>
    <published>2016-01-22T09:35:25.000Z</published>
    <updated>2016-01-22T09:56:03.000Z</updated>
    <content type="html"><![CDATA[<p>早上起床，从冰箱里拿了蛋糕出来，放微波炉转10秒，然后洗漱去了……等我一切停当出来一看，妈呀……我设的不是10秒是10分钟！！！😱 😱 😱 😱 😱一开微波炉，蛋糕烧成碳就不说了，那个呛！别提了！！！<br>开抽油烟机、开风扇、上网搜解救方法（各种橘子皮茶叶醋什么的）、总算感觉好点了。但是、这只是适应环境了的幻觉！午休后从房间出来，一屋子的烟味呛得我……😂 😂 😂 😂 😂无语，外面还下着雨，不能开窗通风，现在全屋开着空调净化器抽风机打字中……🤑 🤑 🤑 🤑 🤑 🤑</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>早上起床，从冰箱里拿了蛋糕出来，放微波炉转10秒，然后洗漱去了……等我一切停当出来一看，妈呀……我设的不是10秒是10分钟！！！😱 😱 😱 😱 😱一开微波炉，蛋糕烧成碳就不说了，那个呛！别提了！！！<br>开抽油烟机、开风扇、上网搜解救方法（各种橘子皮茶叶醋什么的]]>
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从打造新闻app学到的(8)：自定义TableViewCell]]></title>
    <link href="http://conanwhf.coding.me/2016/01/21/newsreader-8/"/>
    <id>http://conanwhf.coding.me/2016/01/21/newsreader-8/</id>
    <published>2016-01-21T09:32:45.000Z</published>
    <updated>2016-08-21T17:57:28.000Z</updated>
    <content type="html"><![CDATA[<p>新闻App通常是有个新闻的列表，这个列表一般都用TableView来做，每个Cell显示一条新闻，如下图：<br><img src="http://whf.d.pr/146XT+" alt=""><br>在我做的时候，开始Cell是直接从控件库拖到StoryBoard里面，配置了一点东西就OK了：当Cell的Style设成subtilte时，标题、副标题、以及图像都是可用的，在<strong>cellForRowAtIndexPath</strong>里直接配置就行了：<br><img src="http://whf.d.pr/K486+" alt=""><br>但这样做了之后出现一个问题：新闻配图是从网络获取的，长宽比和大小并不固定。在这种做法中，图像是以高度而不是宽度统一对齐的，也就是经过缩放后变成统一的高度适配当前Cell，再显示出来。这样一来，每个Cell里的图像宽度就参差不齐，很难看。我尝试了很久也没能解决这个问题，看起来无论怎么对Cell.image进行配置，也是无效的。折中的办法是事先修改图像的长宽比，但这不是我想要的效果。于是，只好尝试TableViewCell的自定义了。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/01/21/newsreader-8/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/01/21/newsreader-8/'>从打造新闻app学到的(8)：自定义TableViewCell</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>不光是TableViewCell，所有控件的自定义都是如出一辙的套路：先继承一个控件的类，再在StoryBoard里面把对应的Custom Class修改成自己继承的那个类，就可以随意修改了。在这里，先把Style设回custom，把Title, image这些在自己的初始化函数里生成：</p>
<pre><code>class ListTableViewCell: UITableViewCell {

    var img:UIImageView!
    var title:UILabel!
    var info:UILabel!

    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)  
        let temp = self.layout()//我自己写的函数，忽略
        title = UILabel(frame: temp.1)
        info = UILabel(frame: temp.2)
        img = UIImageView(frame: temp.0)
        self.addSubview(title)
        self.addSubview(info)
        self.addSubview(img)
    }

    required init(coder aDecoder: NSCoder){
        super.init(coder: aDecoder)!
    }
}
</code></pre><p>同时，在cellForRowAtIndexPath中添加初始化：</p>
<pre><code>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; ListTableViewCell {
        var cell = tableView.dequeueReusableCellWithIdentifier(&quot;newsList&quot;, forIndexPath: indexPath) as? ListTableViewCell
        if cell==nil {
            cell = ListTableViewCell(style: .Default, reuseIdentifier: &quot;newsList&quot;)
        }
//TODO: something config            
        return cell!
    }
</code></pre><p>接下来问题来了：初始化的时候，根本跑不到我自己定义的初始化函数里去！在cell==nil的判断里，cell每次都已经存在，而不是初始生成一些，之后再重用的模式。我查了很多资料，怎么看也没什么问题，别人都是这么写的。上stackoverflow找，有类似问题的人也很少，有个回答说如果这样写，是不应该会有问题的，除非是别的什么地方出错了。我抓狂了很久，突然想到了一个地方—之前在StoryBoard里面配置的ID(上图我已经标出来了)！果然，把这里去掉之后，终于可以Call到自定义的初始化函数了。所以，<strong>如果在StoryBoard里设置了Cell id，则系统会自动处理TableViewCell的初始化和重用，不会调用自定义部分</strong>。<br>这个问题解决后，又出现了两个小问题，一是Cell触发的转场不起作用了，二是在StoryBoard里面Config的Cell高度也失效了。综合上面的问题，应该是在StoryBoard里面取消定义Cell ID之后，系统找不到对应的Cell了，也就无法把config和Cell联系起来。高度定义只要自己在代码中重新写一下就好，转场嘛，在didSelectRowAtIndexPath中手动调用也是一样的：</p>
<pre><code>func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) -&gt; NSIndexPath?    {
    self.performSegueWithIdentifier(&quot;ShowPost&quot;, sender: self)
    return indexPath
}
</code></pre><p>这两周基本上在荒废，这篇文章离写代码的时间也是拖了有半个月，有些细节都快忘了，每天没做什么正事，有点浑浑噩噩的感觉……拖延症加重了？要振作一点！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>新闻App通常是有个新闻的列表，这个列表一般都用TableView来做，每个Cell显示一条新闻，如下图：<br><img src="http://whf.d.pr/146XT+" alt=""><br>在我做的时候，开始Cell是直接从控件库拖到StoryBoard里面，配置了一点东西就OK了：当Cell的Style设成subtilte时，标题、副标题、以及图像都是可用的，在<strong>cellForRowAtIndexPath</strong>里直接配置就行了：<br><img src="http://whf.d.pr/K486+" alt=""><br>但这样做了之后出现一个问题：新闻配图是从网络获取的，长宽比和大小并不固定。在这种做法中，图像是以高度而不是宽度统一对齐的，也就是经过缩放后变成统一的高度适配当前Cell，再显示出来。这样一来，每个Cell里的图像宽度就参差不齐，很难看。我尝试了很久也没能解决这个问题，看起来无论怎么对Cell.image进行配置，也是无效的。折中的办法是事先修改图像的长宽比，但这不是我想要的效果。于是，只好尝试TableViewCell的自定义了。]]>
    
    </summary>
    
      <category term="StoryBoard" scheme="http://conanwhf.coding.me/tags/StoryBoard/"/>
    
      <category term="TableView" scheme="http://conanwhf.coding.me/tags/TableView/"/>
    
      <category term="CocoaTouch" scheme="http://conanwhf.coding.me/categories/CocoaTouch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用.transform旋转带来的坑]]></title>
    <link href="http://conanwhf.coding.me/2016/01/16/Transform/"/>
    <id>http://conanwhf.coding.me/2016/01/16/Transform/</id>
    <published>2016-01-16T09:32:45.000Z</published>
    <updated>2016-08-26T05:03:49.000Z</updated>
    <content type="html"><![CDATA[<p>这礼拜都在玩树莓派，Xcode都几乎没打开过，该收收心了。OmniFocus里攒了一堆已过期的待办，feedly也有好多未读，都又到周末了，先把上个礼拜留下来的几个准备写的Topic写了吧。<br>关于UIView的旋转，踩了一个小坑，看了看也没人说过。大家都知道使用.transform可以做旋转，用起来也很简单。在我的UIView Demo中（见上周Blog<a href="http://conanwhf.github.io/2016/01/03/UISlider/" title="UIController中Slider监听回调具体实现的分离" target="_blank" rel="external">UIController中Slider监听回调具体实现的分离</a>），我也添加了旋转的功能，开始是在handler中这么写的(back是一个UIView)：</p>
<pre><code>let x = (Float(ctl.show.frame.width) - conf[0] )/2
let y = (Float(ctl.show.frame.height) - conf[1] )/2
back.frame.size = CGSize(width: CGFloat(conf[0], height: CGFloat(conf[1])
back.frame.origin = CGPoint(x: Int(x), y: Int(y))
back.transform = CGAffineTransformMakeRotation( CGFloat(Double(conf[7] * M_PI  / 180.0))
</code></pre><p>前面几句修改大小和位置，最后一句做旋转。没添加旋转之前缩放和位移都是对的，添加了旋转之后效果却不是我想象的那样以图形中心为圆心转动，而是这样有时候会自己拉扁的：<br><img src="http://whf.d.pr/CNsl+" alt=""></p>
<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/01/16/Transform/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/01/16/Transform/'>使用.transform旋转带来的坑</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

<p>添加了打印信息以后发现，经过旋转的View.frame，不管是size还是position都变掉了，并且完全不是按照希望的样子变化的。不论我把旋转放在整个片段的哪里，都不对，frame的size总是不受控制。后来只好把scaling的部分改成了CGAffineTransformScale()。去看了看transform系列的文档，它其实是一类矩阵变换方式，旋转、缩放、平移只是其中的一些常用算法，系统给出了这些功能的API。如果你数学够好，其实也是可以自己设置这种变换的映射方式，最后转换后的View，其frame size是包含目标图形的一个最小矩形。而我猜，我碰到的问题，是因为系统对于旋转的处理有点特殊，因为scaling时拿到的参数不正确（当时的frame还没有画成缩放后的样子）导致。<br>于是我将UIView的变化都改为用CGAffineTransform系列函数进行，又发现对transform的操作先后顺序会影响最终的效果。出于兴趣我在playground里面做了点测试，先申请了一个100*300的矩形，然后做了两个transform的参数分别表示旋转90度和缩放至200*200（长宽缩放比例为1:2和1:0.667）：</p>
<pre><code>let demo = UIView(frame:CGRectMake(0.0, 0.0, 100.0,  300.0))
//缩放参数
let sx =  200 / demo.frame.width
let sy =  200 / demo.frame.height
let transf_scale = CGAffineTransformMakeScale(sx, sy)
//旋转参数
let transf_rotate = CGAffineTransformMakeRotation(CGFloat(Double(90) * M_PI  / 180.0))
</code></pre><p>对这个View分别进行缩放和旋转操作，理想的情况是变成一个200*200的正方形。四个测试Case分别如下：两个先缩放再旋转，两个先旋转再缩放，后两个用的是CGAffineTransformConcat()函数直接跑。</p>
<pre><code>//case 1, rotate(scale, x)
demo.transform = CGAffineTransformRotate(transf_scale, CGFloat(Double(90) * M_PI  / 180.0))
demo.frame.size     //600*67

//case 2, scale(rotate, x)
demo.transform = CGAffineTransformScale(transf_rotate, sx, sy)
demo.frame.size     //200*200

//case 3, scale+rotate
demo.transform = CGAffineTransformConcat(transf_scale, transf_rotate)
demo.frame.size     //200*200

//case 4, rotate+scale
demo.transform = CGAffineTransformConcat(transf_rotate, transf_scale)
demo.frame.size     //600*67
</code></pre><p>有兴趣的可以把这一段code放到playground里面自己跑跑，看看会是什么结果。case2 &amp; case3，结果如我们所想象的那样，是个200*200的正方形；而case1 &amp; case4，却变成了600*66.7的长条矩形。看起来正如下图的几种情况：<br><img src="http://whf.d.pr/1dzlq+" alt=""><br>图中，暗红色部分是先做缩放再做旋转，有了正确的结果，对应scale(rotate, x) &amp; scale+rotate；银色部分则是先旋转再缩放，成了错误的样子，对应rotate+scale &amp; rotate(scale, x)。原来这是有顺序要求的。那么问题又来了：CGAffineTransformXXX(t, args)系列的函数，感觉上应该是对t用新的参数做叠加，为什么结果却是反的呢？于是我去查了它们的头文件，看到是这么定义的：</p>
<blockquote>
<p>  /* Scale t’ by (sx, sy)’ and return the result:<br>  t’ = [ sx 0 0 sy 0 0 ] * t */<br>  @available(iOS 2.0, *)<br>  public func CGAffineTransformScale(t: CGAffineTransform, _ sx: CGFloat, _ sy: CGFloat) -> CGAffineTransform</p>
<p>  /* Rotate t’ by angle’ radians and return the result:<br>  t’ =  [ cos(angle) sin(angle) -sin(angle) cos(angle) 0 0 ] * t */<br>  @available(iOS 2.0, *)<br>  public func CGAffineTransformRotate(t: CGAffineTransform, _ angle: CGFloat) -> CGAffineTransform</p>
<p>  /* Concatenate t2’ to t1’ and return the result:<br>  t’ = t1 * t2 */<br>  @available(iOS 2.0, *)<br>  public func CGAffineTransformConcat(t1: CGAffineTransform, _ t2: CGAffineTransform) -> CGAffineTransform</p>
</blockquote>
<p>于是真相大白：原来，<strong>CGAffineTransformScale(t1, args)= t-scale*t1，而CGAffineTransformConcat(t1, t2)= t1 *t2，它们的顺序是反的</strong>。这个坑有点绕得人人晕晕的😳<br>最后，综上所述，对于transform的使用，我总结了以下几点：</p>
<ol>
<li>transform参数，事实上是一些形变映射矩阵的叠加。</li>
<li>Scale的时候设置的参数，代表的是缩放的系数，不是目标size，所以如果有其他transform参数在此之前做，要重新计算系数</li>
<li>CGAffineTansform系列本质是矩阵运算，顺序很重要</li>
<li>CGAffineTransformConcat(t1,t2)的顺序是t1->t2, 而CGAffineTransformXXX(t1, (args to t2))的顺序是t2->t1，不要搞错</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这礼拜都在玩树莓派，Xcode都几乎没打开过，该收收心了。OmniFocus里攒了一堆已过期的待办，feedly也有好多未读，都又到周末了，先把上个礼拜留下来的几个准备写的Topic写了吧。<br>关于UIView的旋转，踩了一个小坑，看了看也没人说过。大家都知道使用.transform可以做旋转，用起来也很简单。在我的UIView Demo中（见上周Blog<a href="http://conanwhf.github.io/2016/01/03/UISlider/" title="UIController中Slider监听回调具体实现的分离">UIController中Slider监听回调具体实现的分离</a>），我也添加了旋转的功能，开始是在handler中这么写的(back是一个UIView)：</p>
<pre><code>let x = (Float(ctl.show.frame.width) - conf[0] )/2
let y = (Float(ctl.show.frame.height) - conf[1] )/2
back.frame.size = CGSize(width: CGFloat(conf[0], height: CGFloat(conf[1])
back.frame.origin = CGPoint(x: Int(x), y: Int(y))
back.transform = CGAffineTransformMakeRotation( CGFloat(Double(conf[7] * M_PI  / 180.0))
</code></pre><p>前面几句修改大小和位置，最后一句做旋转。没添加旋转之前缩放和位移都是对的，添加了旋转之后效果却不是我想象的那样以图形中心为圆心转动，而是这样有时候会自己拉扁的：<br><img src="http://whf.d.pr/CNsl+" alt=""></p>]]>
    
    </summary>
    
      <category term="Transform　" scheme="http://conanwhf.coding.me/tags/Transform/"/>
    
      <category term="iOS" scheme="http://conanwhf.coding.me/tags/iOS/"/>
    
      <category term="CocoaTouch" scheme="http://conanwhf.coding.me/categories/CocoaTouch/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己编译给树莓派RaspberryPi的交叉编译工具]]></title>
    <link href="http://conanwhf.coding.me/2016/01/14/rpi-toolchain/"/>
    <id>http://conanwhf.coding.me/2016/01/14/rpi-toolchain/</id>
    <published>2016-01-14T03:31:26.000Z</published>
    <updated>2016-08-25T10:32:07.000Z</updated>
    <content type="html"><![CDATA[<p>  说到交叉编译工具，真是血泪史。搞了快两天，才终于迂回搞定。老规矩，先放Script<a href="https://github.com/conanwhf/RaspberryPi-script" target="_blank" rel="external">传送门</a>，<strong>build/build-toolchain.sh</strong><br>  一开始我以为这东西用的人多，交叉编译工具应该不是事儿，去官网下一个就行了，可是我去GitHub一看，这toolchain最近的更新也是<strong>三年</strong>前，这……能用？先下载吧，同时各种搜，感觉我没有走错地方，大家就是用的这一款！<br>  可是我忘了我是OSX。不出所料，在我的电脑上跑不了。而且看了下这个toolchain还是给ARMv6编的好吗，现在明明就是ARMv7了！这么跑性能不受影响吗？更让我无语的是板子上的gcc也是ARMv6的……😰编译个内核什么的那么慢，官方的toolchain又不能用，自己编译势在必行。<br>又是一通各种搜，搜到了个别人2014年编译的mac用toolchain，试了试，普通的程序没问题，编kernel编不过。搜到了个比较详细的在Mac上编译的blog，可惜也是几年前的，跟现在的环境不一样，各种出状况又goole解决，最后还是编译crosstool不成功。可能这一两年，不论是crosstool，OSX，还是GCC，都已经又改了不少吧。<br>  最后，我放弃了，毕竟还是要做iOS开发的，不敢随便乱sudo，还是上虚拟机吧。竭尽全力把所有能删的都删了，看看剩余的18G空间（128G MBP你懂的），哭着做了个Debian的虚拟机……为了节约，GUI都不要，命令行的最小系统。后来还是吃亏在这上面了，编译到一半空间不够，临时扩展磁盘，fdisk,format,mount,ln -s😞所以，根据我经验，不管在哪里，请<strong>至少至少至少准备10G有效空间！！！</strong>（12G是我调整后整个虚拟机大小，最后还剩了2G；如果系统已经有了，那free space至少8G）<br>废话说完，正经操作其实不多，主要就是装一个神器<strong>crosstool-ng</strong>，配置好，然后交给它编译交叉编译工具就行了！具体如下： <a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/01/14/rpi-toolchain/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/01/14/rpi-toolchain/'>自己编译给树莓派RaspberryPi的交叉编译工具</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
<h2 id="u865A_u62DF_u673A_u914D_u7F6E"><a href="#u865A_u62DF_u673A_u914D_u7F6E" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><p>基于最纯粹最小系统，改个vi，加个sudo账户，如果系统以前就用可以跳过。</p>
<pre><code>sudo apt-get install -y vim
echo “deb ALL=(ALL) NOPASSWD: ALL” | sudo tee -a /etc/sudoers
</code></pre><h2 id="u73AF_u5883_u51C6_u5907"><a href="#u73AF_u5883_u51C6_u5907" class="headerlink" title="环境准备"></a>环境准备</h2><p>因为是新系统，要装的库实在太多，我一边编，一边google，无数次出错了就多装一个库再来，这些是最精简的要求了，一般的系统里应该很多都已经装了</p>
<pre><code>sudo apt-get -y update
sudo apt-get install -y bison flex texinfo gawk automake subversion
sudo apt-get install -y gperf help2man make libtool libncurses5-dev 
sudo apt-get install -y gcj-jdk python-dev g++
</code></pre><p>这个libtool我不知道为什么，明明装了却总说没装，于是我自己手动装了一遍。不过后来想想，可能应该装libtool-dev？没去验证</p>
<pre><code>git clone git://git.savannah.gnu.org/libtool.git
cd libtool
./configure; make; make install
</code></pre><h2 id="u7F16_u8BD1crosstool-ng"><a href="#u7F16_u8BD1crosstool-ng" class="headerlink" title="编译crosstool-ng"></a>编译crosstool-ng</h2><pre><code>git clone https://github.com/crosstool-ng/crosstool-ng.git
cd crosstool-ng
./bootstrap
./configure --prefix=/opt/crosstool-ng
make
make install
</code></pre><p>然后加环境变量<code>export PATH=$PATH:/opt/crosstool-ng/bin</code></p>
<h2 id="u7F16_u8BD1_u4EA4_u53C9_u7F16_u8BD1_u5DE5_u5177_28_u4E0D_u80FD_u662Froot_u7528_u6237_29"><a href="#u7F16_u8BD1_u4EA4_u53C9_u7F16_u8BD1_u5DE5_u5177_28_u4E0D_u80FD_u662Froot_u7528_u6237_29" class="headerlink" title="编译交叉编译工具(不能是root用户)"></a>编译交叉编译工具(不能是root用户)</h2><h3 id="u68C0_u67E5tools_u7248_u672C"><a href="#u68C0_u67E5tools_u7248_u672C" class="headerlink" title="检查tools版本"></a>检查tools版本</h3><p>编译过程中要用到很多库，有几个比较关键的库的版本需要提前看好，否则可能导致编译失败。这个是要在树莓派的终端看的，不是指编译环境。</p>
<ol>
<li>Glibc版本：<code>lld —v</code></li>
<li>GCC版本：<code>gcc —v</code></li>
<li>目标板Kernel版本：<code>uname -r</code>。目前我用的最新版本是Linux-4.1.15</li>
</ol>
<h3 id="u914D_u7F6E_u7F16_u8BD1_u9009_u9879"><a href="#u914D_u7F6E_u7F16_u8BD1_u9009_u9879" class="headerlink" title="配置编译选项"></a>配置编译选项</h3><ul>
<li>首先去一个随便什么地方（要有读写权限）建立一个文件夹作为当前目录，用来存放临时的配置文件<pre><code>mkdir toolchain
cd toolchain
</code></pre></li>
<li><p>crosstool-ng是有一些不同平台的default配置的，他们放在<strong>crosstool-ng/samples/$PLATFORM/crosstool.config</strong>。很幸运树莓派2B正好是有默认配置的，可以用：</p>
<pre><code>ct-ng armv7-rpi2-linux-gnueabihf
</code></pre><p>来调用，然后就会自动保存为.config文件，这个跟kernel有点像。</p>
</li>
<li><p>默认的配置还是有些地方需要调整，我们要手动配置一下：</p>
<pre><code>ct-ng menuconfig
</code></pre><p>这里面的界面就非常像Kernel的Config了。基于默认配置，需要修改的部分不多，重要的有以下几个：</p>
<blockquote>
<ol>
<li>Paths and misc options  —><br>[X]  Try features marked as EXPERIMENTAL<br>(3)  Number of parallel jobs  //同时进行编译的线程，如果机器好点的话可以改大点加快速度</li>
<li>Toolchain options  —><br>(rpi2)  Tuple’s vendor string  //一个标识符，会出现在最终编译工具的文件名上</li>
<li>Operating System  —><br>Linux kernel version()  //内核版本，之前记录下来的</li>
<li>C-library  —><br>glibc version ()  // Glibc版本</li>
<li>C compiler  —><br>gcc version ()  //GCC版本</li>
<li>Companion libraries  —><br>这里面有一些其他的库的版本选择，不太会影响编译成功与否，有需要可以改</li>
</ol>
</blockquote>
</li>
</ul>
<p>最后看看还有什么自己的特殊需要，例如目标Path之类，改完以后保存</p>
<h3 id="u7F16_u8BD1"><a href="#u7F16_u8BD1" class="headerlink" title="编译"></a>编译</h3><p>一句话：</p>
<pre><code>ct-ng build
</code></pre><p>然后等着吧！首先还会下载GCC之类的源码，所以准备好网络环境。如果没有出错的话，也要等个两三个钟头。完成之后，会在<code>~/xtool</code>（默认设置）里看到最终的交叉编译工具。拿去用吧！我测试了普通程序、内核、驱动，都跑得好好的，搞定收工！😄</p>
<h3 id="u6709_u5173Mac_u7684_u51E0_u53E5_u8BDD"><a href="#u6709_u5173Mac_u7684_u51E0_u53E5_u8BDD" class="headerlink" title="有关Mac的几句话"></a>有关Mac的几句话</h3><p>关于Mac的OSX系统，多废话两句。在Mac上的crosstool-ng之所以用不了，一是因为很多工具没有，二是即使有也太过于陈旧，第三点最重要：Mac上的GCC等一套工具并不是基于GNU的，而是Apple自己弄的Clang。虽然我们有brew这样的神器，但GCC, grep, awk, libtool, automake……这么多关键的库都要重来，又不能影响系统，就算是写脚本做软链接也是相当浩大的工程。所以，如果不是对自己特别有信心，又特别爱折腾，我真心建议还是用虚拟机吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>  说到交叉编译工具，真是血泪史。搞了快两天，才终于迂回搞定。老规矩，先放Script<a href="https://github.com/conanwhf/RaspberryPi-script">传送门</a>，<strong>build/build-toolchain.sh</strong><br>  一开始我以为这东西用的人多，交叉编译工具应该不是事儿，去官网下一个就行了，可是我去GitHub一看，这toolchain最近的更新也是<strong>三年</strong>前，这……能用？先下载吧，同时各种搜，感觉我没有走错地方，大家就是用的这一款！<br>  可是我忘了我是OSX。不出所料，在我的电脑上跑不了。而且看了下这个toolchain还是给ARMv6编的好吗，现在明明就是ARMv7了！这么跑性能不受影响吗？更让我无语的是板子上的gcc也是ARMv6的……😰编译个内核什么的那么慢，官方的toolchain又不能用，自己编译势在必行。<br>又是一通各种搜，搜到了个别人2014年编译的mac用toolchain，试了试，普通的程序没问题，编kernel编不过。搜到了个比较详细的在Mac上编译的blog，可惜也是几年前的，跟现在的环境不一样，各种出状况又goole解决，最后还是编译crosstool不成功。可能这一两年，不论是crosstool，OSX，还是GCC，都已经又改了不少吧。<br>  最后，我放弃了，毕竟还是要做iOS开发的，不敢随便乱sudo，还是上虚拟机吧。竭尽全力把所有能删的都删了，看看剩余的18G空间（128G MBP你懂的），哭着做了个Debian的虚拟机……为了节约，GUI都不要，命令行的最小系统。后来还是吃亏在这上面了，编译到一半空间不够，临时扩展磁盘，fdisk,format,mount,ln -s😞所以，根据我经验，不管在哪里，请<strong>至少至少至少准备10G有效空间！！！</strong>（12G是我调整后整个虚拟机大小，最后还剩了2G；如果系统已经有了，那free space至少8G）<br>废话说完，正经操作其实不多，主要就是装一个神器<strong>crosstool-ng</strong>，配置好，然后交给它编译交叉编译工具就行了！具体如下：]]>
    
    </summary>
    
      <category term="crosstool-ng" scheme="http://conanwhf.coding.me/tags/crosstool-ng/"/>
    
      <category term="toolchain" scheme="http://conanwhf.coding.me/tags/toolchain/"/>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/categories/RaspberryPi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派RaspberryPi内核编译]]></title>
    <link href="http://conanwhf.coding.me/2016/01/12/rpi-kernel/"/>
    <id>http://conanwhf.coding.me/2016/01/12/rpi-kernel/</id>
    <published>2016-01-12T07:31:26.000Z</published>
    <updated>2016-08-26T05:04:11.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个（曾经的）内核开发者，弄到块板子怎么能不重新编译内核？系统配好跑起来后的第二件事，就是编译内核了。在树莓派上编译内核很简单，基本上就是按照官方文档跑脚本，先放GitHub上的Script<a href="https://github.com/conanwhf/RaspberryPi-script" target="_blank" rel="external">传送门</a>，<strong>build/kernel.sh</strong></p>
<h2 id="u7CFB_u7EDF_u7B80_u4ECB"><a href="#u7CFB_u7EDF_u7B80_u4ECB" class="headerlink" title="系统简介"></a>系统简介</h2><h3 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h3><p>树莓派的文件系统设计还是不错的，能比较方便地更新内核和各种固件。整个文件系统分为两个部分：Fat32分区和Ext4分区。Fat32分区是mount到/boot上的，里面放了内核和启动的核心固件；Ext4就是一般的根文件系统了，放其他的所有东西，包括firmware和各种ko等。这种设计免去了用户烧录的麻烦，只是他们的bootloader没有开放源码，对于极客来说是很不爽的事情。<br>所谓的系统更新，就是每次编译kernel之后，直接把生成的文件放到特定的地方，重启就行。这也是为什么系统自带的工具<strong>rpi-update</strong>可以自动更新内核、firmware等等一切东西。</p>
<h3 id="u786C_u4EF6_u7684_u9009_u62E9_u548C_u542F_u52A8"><a href="#u786C_u4EF6_u7684_u9009_u62E9_u548C_u542F_u52A8" class="headerlink" title="硬件的选择和启动"></a>硬件的选择和启动</h3><p>树莓派一代和二代用的两个不同的ARM芯片，这个差别在操作系统中并没有体现出来，我是指：官方提供的系统镜像是同一个。开始我很奇怪，后来看到了它的文件系统，才明白，它是靠不同的kernel文件名来区分的。这两种板子的platform分别叫”bcm2708”和”bcm2709”，启动的时候bootloader会根据硬件情况自动区分，读取不同的kernel image，进而load不同的firmware和driver。</p>
<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/01/12/rpi-kernel/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/01/12/rpi-kernel/'>树莓派RaspberryPi内核编译</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

<h2 id="u6E90_u7801_u4E0B_u8F7D__26amp_3B__u73AF_u5883_u51C6_u5907"><a href="#u6E90_u7801_u4E0B_u8F7D__26amp_3B__u73AF_u5883_u51C6_u5907" class="headerlink" title="源码下载 &amp; 环境准备"></a>源码下载 &amp; 环境准备</h2><p>要说编译内核有什么好准备的，那恐怕就是要准备一个好点的网络环境和大大的耐心了。不算下载source code，我整个系统编了五六个小时吧。好在编译是一直有输出的，有点盼头，不然真是要cancel掉了……<br>先是源码下载：</p>
<pre><code>git clone --depth=1 git://github.com/raspberrypi/linux.git linux  
</code></pre><p>然后是工具的准备，最好先<code>apt-get -y update</code>一下</p>
<pre><code>sudo apt-get -y install gcc make bc screen ncurses-dev
</code></pre><h2 id="u6B63_u5F0F_u7F16_u8BD1_uFF08_u4E8C_u4EE3B_u4E3A_u4F8B_uFF09"><a href="#u6B63_u5F0F_u7F16_u8BD1_uFF08_u4E8C_u4EE3B_u4E3A_u4F8B_uFF09" class="headerlink" title="正式编译（二代B为例）"></a>正式编译（二代B为例）</h2><p>源码和编译环境准备好了以后，就要开编了。kernel的config文件官方已经给出，什么都不改也是可以跑得很好的，看看有什么要改的然后就让它跑着自己睡觉去吧：</p>
<pre><code>KERNEL=kernel7
make bcm2709_defconfig
make menuconfig

make -j4 zImage modules dtbs
sudo make modules_install
sudo cp arch/arm/boot/dts/*.dtb /boot/
sudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/
sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/
sudo scripts/mkknlimg arch/arm/boot/zImage /boot/$KERNEL.img
</code></pre><h2 id="u5B8C_u6210"><a href="#u5B8C_u6210" class="headerlink" title="完成"></a>完成</h2><p>一觉醒来，终于跑完了！看看输出有没有什么错误，不要太鲁莽。如果没什么问题，就可以<code>reboot</code>了，enjoy!</p>
<h2 id="u4E07_u4E00_u2026_u2026"><a href="#u4E07_u4E00_u2026_u2026" class="headerlink" title="万一……"></a>万一……</h2><p>万一，编译出了什么问题，系统跑不起来了……🤔我是不是应该先写这一部分？最简单的办法当然是重烧官方img，不过码农怎么会这么粗暴……你只要备份好/boot, /lib/firmware, /lib/modules这三个文件夹就行了。<br>最坏的情况，你之前没有备份？另外拿张卡，烧进官方系统跑起来，插入之前的卡，mount上去（系统应该会自动做了，在~/media/底下），更新那三个文件夹。<br>最最坏的情况，你没有第二张卡？那只好simulate一个disk出来，把上面的解决办法在主机上做一遍了……😏</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为一个（曾经的）内核开发者，弄到块板子怎么能不重新编译内核？系统配好跑起来后的第二件事，就是编译内核了。在树莓派上编译内核很简单，基本上就是按照官方文档跑脚本，先放GitHub上的Script<a href="https://github.com/conanwhf/RaspberryPi-script">传送门</a>，<strong>build/kernel.sh</strong></p>
<h2 id="u7CFB_u7EDF_u7B80_u4ECB"><a href="#u7CFB_u7EDF_u7B80_u4ECB" class="headerlink" title="系统简介"></a>系统简介</h2><h3 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h3><p>树莓派的文件系统设计还是不错的，能比较方便地更新内核和各种固件。整个文件系统分为两个部分：Fat32分区和Ext4分区。Fat32分区是mount到/boot上的，里面放了内核和启动的核心固件；Ext4就是一般的根文件系统了，放其他的所有东西，包括firmware和各种ko等。这种设计免去了用户烧录的麻烦，只是他们的bootloader没有开放源码，对于极客来说是很不爽的事情。<br>所谓的系统更新，就是每次编译kernel之后，直接把生成的文件放到特定的地方，重启就行。这也是为什么系统自带的工具<strong>rpi-update</strong>可以自动更新内核、firmware等等一切东西。</p>
<h3 id="u786C_u4EF6_u7684_u9009_u62E9_u548C_u542F_u52A8"><a href="#u786C_u4EF6_u7684_u9009_u62E9_u548C_u542F_u52A8" class="headerlink" title="硬件的选择和启动"></a>硬件的选择和启动</h3><p>树莓派一代和二代用的两个不同的ARM芯片，这个差别在操作系统中并没有体现出来，我是指：官方提供的系统镜像是同一个。开始我很奇怪，后来看到了它的文件系统，才明白，它是靠不同的kernel文件名来区分的。这两种板子的platform分别叫”bcm2708”和”bcm2709”，启动的时候bootloader会根据硬件情况自动区分，读取不同的kernel image，进而load不同的firmware和driver。</p>]]>
    
    </summary>
    
      <category term="Kernel" scheme="http://conanwhf.coding.me/tags/Kernel/"/>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/categories/RaspberryPi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派RaspberryPi初始配置指南（2代B型）]]></title>
    <link href="http://conanwhf.coding.me/2016/01/12/rpi-start/"/>
    <id>http://conanwhf.coding.me/2016/01/12/rpi-start/</id>
    <published>2016-01-12T06:31:26.000Z</published>
    <updated>2016-08-25T10:31:48.000Z</updated>
    <content type="html"><![CDATA[<p>关于树莓派的开箱流程、初始配置文章不少，那些基础的有GUI配置的我就不多说了。可能是版本原因，我看到的有的东西已经跟我手头上的对不太上，记录一下。我是二代B型（真不想说我是2B😂），自用主机是MacBookPro，以下内容都基于此。另外我是基于一个程序员的视角而写，所以那些怎么ssh，开终端之类的东西都省略。所有脚本我都放在了GitHub上，<a href="https://github.com/conanwhf/RaspberryPi-script" target="_blank" rel="external">传送门</a></p>
<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/01/12/rpi-start/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/01/12/rpi-start/'>树莓派RaspberryPi初始配置指南（2代B型）</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

<h2 id="u5236_u4F5C_u542F_u52A8img"><a href="#u5236_u4F5C_u542F_u52A8img" class="headerlink" title="制作启动img"></a>制作启动img</h2><ol>
<li>从官网下载最新的image，解包，TF卡插入电脑</li>
<li>用mount查看，将TF卡umount</li>
<li><p>randisk<strong>X</strong>是要自己根据情况修改的</p>
<pre><code>sudo dd bs=1m if=2015-11-21-raspbian-jessie.img of=/dev/rdisk2
diskutil umount /Volumes/boot
</code></pre></li>
<li>拔卡，插入树莓派，上电，这时候系统应该跑起来了。最新的系统是默认打开SSH的，所以如果你插了网线、知道IP的话，已经可以直接SSH上去。初始用户pi,密码raspberry</li>
<li><strong>下面的命令都是在树莓派上跑的，请不要随便在自己主电脑上sudo!!!</strong></li>
</ol>
<h2 id="u66F4_u65B0_u5230_u6700_u65B0_u7248_u672C"><a href="#u66F4_u65B0_u5230_u6700_u65B0_u7248_u672C" class="headerlink" title="更新到最新版本"></a>更新到最新版本</h2><p>要花点时间，放到后面做也可以。<strong>另外我看到有人说国内连官方源太慢，我不在国内测不到，如果需要请自己搜索添加合适的源</strong></p>
<pre><code>sudo apt-get -y update
sudo apt-get -y upgrade
sudo apt-get -y dist-upgrade
sudo rpi-update
</code></pre><h2 id="u4FEE_u6539vi"><a href="#u4FEE_u6539vi" class="headerlink" title="修改vi"></a>修改vi</h2><p>Debian的默认vi太难用！改之。我的Github里还放了我的vi配置文件，随意取用</p>
<pre><code>sudo apt-get -y remove vim-common
sudo apt-get -y install vim
</code></pre><h2 id="u4E2D_u6587_u652F_u6301"><a href="#u4E2D_u6587_u652F_u6301" class="headerlink" title="中文支持"></a>中文支持</h2><p>字库和输入法，平时都用SSH的人其实用不到</p>
<pre><code>sudo apt-get -y install ttf-wqy-zenhei ttf-wqy-microhei
sudo apt-get -y install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin
</code></pre><h2 id="u5B98_u65B9_u81EA_u5E26_u7684menuconfig"><a href="#u5B98_u65B9_u81EA_u5E26_u7684menuconfig" class="headerlink" title="官方自带的menuconfig"></a>官方自带的menuconfig</h2><p>跑(sudo raspi-config)，这个命令行跑起来的界面和GUI上打开的不一样，不过内容差不多，建议修改以下几个</p>
<ul>
<li>用户pi密码，hostname</li>
<li>开启ssh,spi,i2c</li>
<li>修改时区</li>
<li>扩展卡上分区<br>然后就可以reboot了</li>
</ul>
<h2 id="VNC_u652F_u6301"><a href="#VNC_u652F_u6301" class="headerlink" title="VNC支持"></a>VNC支持</h2><h3 id="u5B89_u88C5_u670D_u52A1_u5668_u7AEFtightVNC"><a href="#u5B89_u88C5_u670D_u52A1_u5668_u7AEFtightVNC" class="headerlink" title="安装服务器端tightVNC"></a>安装服务器端tightVNC</h3><pre><code>sudo apt-get -y install tightvncserver
sudo apt-get -y install xfonts-base
</code></pre><h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><ol>
<li>配置连接密码：<code>vncpasswd</code></li>
<li>添加开机启动：<ul>
<li>创建/etc/init.d/tightvncserver，内容见<a href="https://github.com/conanwhf/RaspberryPi-script/blob/master/setup/tightvncserver" target="_blank" rel="external">这里</a></li>
<li>更新改变：<pre><code>sudo chmod +x /etc/init.d/tightvncserver
sudo update-rc.d tightvncserver defaults
</code></pre></li>
</ul>
</li>
</ol>
<h2 id="u5BA2_u6237_u7AEF_u8FDE_u63A5"><a href="#u5BA2_u6237_u7AEF_u8FDE_u63A5" class="headerlink" title="客户端连接"></a>客户端连接</h2><p>在我的Mac上，Finder里面⌘+k，填<code>vnc://&lt;rpi IP&gt;:5901</code>即可。人家都说可以用<code>vnc://IP:1</code>这样的方式，但我不行，不知道为啥</p>
<h2 id="u914D_u7F6E_u56FA_u5B9AIP_u5730_u5740"><a href="#u914D_u7F6E_u56FA_u5B9AIP_u5730_u5740" class="headerlink" title="配置固定IP地址"></a>配置固定IP地址</h2><ol>
<li>修改<strong>/etc/network/interfaces</strong>，当然下面的IP要换成你自己的</li>
</ol>
<p><em>iface eth0 inet manual</em> –>  </p>
<blockquote>
<p>iface eth0 inet static<br>address 192.168.0.120<br>netmask 255.255.255.0<br>gateway 192.168.0.1</p>
</blockquote>
<ol>
<li><p>重启服务</p>
<pre><code>sudo systemctl daemon-reload
sudo service networking restart
</code></pre></li>
</ol>
<h2 id="SSH_u7279_u6B8A_u914D_u7F6E"><a href="#SSH_u7279_u6B8A_u914D_u7F6E" class="headerlink" title="SSH特殊配置"></a>SSH特殊配置</h2><p>主要是给SSH的中文支持用的</p>
<pre><code>echo LC_ALL=en_US.UTF-8 | sudo tee -a /etc/environment
echo LANG=en_US.UTF-8 | sudo tee -a /etc/environment
</code></pre><h2 id="u52A0_u5927USB_u4F9B_u7535"><a href="#u52A0_u5927USB_u4F9B_u7535" class="headerlink" title="加大USB供电"></a>加大USB供电</h2><p>修改后可以使能USB的1.2A供电，不然插USB硬盘是不能用的</p>
<pre><code>echo “max_usb_current=1” | sudo tee -a /boot/config.txt
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>关于树莓派的开箱流程、初始配置文章不少，那些基础的有GUI配置的我就不多说了。可能是版本原因，我看到的有的东西已经跟我手头上的对不太上，记录一下。我是二代B型（真不想说我是2B😂），自用主机是MacBookPro，以下内容都基于此。另外我是基于一个程序员的视角而写，所以那些怎么ssh，开终端之类的东西都省略。所有脚本我都放在了GitHub上，<a href="https://github.com/conanwhf/RaspberryPi-script">传送门</a></p>]]>
    
    </summary>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/categories/RaspberryPi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派RaspberryPi入手]]></title>
    <link href="http://conanwhf.coding.me/2016/01/12/rpi-get/"/>
    <id>http://conanwhf.coding.me/2016/01/12/rpi-get/</id>
    <published>2016-01-12T05:31:26.000Z</published>
    <updated>2016-08-25T10:31:42.000Z</updated>
    <content type="html"><![CDATA[<p>  不知是哪根天线收到了什么隐藏信息，突发奇想想去买个树莓派玩玩。其实家里还有一块前公司齐活的开发板，但性能差了点，板子又大，总之就是腻味了以后哪儿哪儿都是缺点，新的诱惑无限大。于是去买了块树莓派2B，打算配个服务器学点Python玩玩，从下午一直折腾到半夜，终于配置得算是差不多成型了。<br>  以前没怎么研究过，认真四处看看，大致上情况是摸清了：硬件上总共出了算是三代n个型号（第三代Zero刚出），第一代硬件资料全齐，第二代就有点遮遮掩掩。我买的第二代B型，外设方面4口USB2.0，TF插槽、网口、HDMI、耳机插口、DSI摄像头接口、DSI屏幕接口各一。首先，我感觉USB2.0有点落伍，至少给一个3.0吧；其次，没有Nand flash，略不方便；再次，GPIO接口有点少，就那么40Pin还共用了串口+i2c+spi*2，也没数模转换，有点不够用；最后，那个LCDC接口是给谁用的啊？要自己单独做块转接板那么麻烦……除此之外，硬件凑合，但拿来做开发板太浪费，除非你的东西计算量很大；用来当个小小服务器、小小Linux机还不错。<br>  软件方面，官方操作系统是Debian的。那套GUI对我来说真的有点鸡肋，居然还有Office和Mathematical，然而这种配置跑图形界面，<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/01/12/rpi-get/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/01/12/rpi-get/'>树莓派RaspberryPi入手</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
我还不如去用iPad（当然价格也是不能比啦）。整个社区，国外的相对比较活跃，国内的就不行了。上各种贴吧论坛里看看，小白居多，而且论坛商业化严重，随便一点资料就是需要会员，或者引导你去他们的淘宝店买配件。我英文不行，所以常常还是用的中文搜索，学习iOS的时候中文资料多基本可以满足我需求；但对于各种树莓派的相关问题，我却需要用英文才能找到答案。从这一点上来说，贴吧人气和质量不行也是正常的。<br>  另外就是官方的Support。我去看了官网、官方论坛、官方Github等好几个地方，感觉官方在二次开发上面的支持并不是很热情，而是更倾向于提供一个小型电脑的使用环境而已。很多事情，官方文档只会告诉你应该怎么做，而不是其所以然。比如重新编译Kernel，他会有一个文档给出如何编译，如何更新Image，但没有关于文件系统、启动流程的解释，以及需要更新的文件都是用来干嘛的……对于有经验的工程师来说看看脚本也就大致明白了，但对于新手来说肯定是一头雾水，因为官方对树莓派的启动流程用的是一套自己的方式。再看看Github上，不少项目，可是每个项目具体是啥、怎么用、什么情况下用，并没有什么交代。刚开始我完全没搞明白，因为这是一个自定义的系统，有很多自定义的细节和方式，而我要去哪里搞明白这些事情？只有碰碰钉子了。<br>  啰嗦了一大堆，只是随便扯扯。折腾了两天，现在我终于把整个环境差不多搭好，n个传感器躺在淘宝购物车里，已经好几天没看iOS了，等把树莓派的东西总结总结，赶紧回归正事！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>  不知是哪根天线收到了什么隐藏信息，突发奇想想去买个树莓派玩玩。其实家里还有一块前公司齐活的开发板，但性能差了点，板子又大，总之就是腻味了以后哪儿哪儿都是缺点，新的诱惑无限大。于是去买了块树莓派2B，打算配个服务器学点Python玩玩，从下午一直折腾到半夜，终于配置得算是差不多成型了。<br>  以前没怎么研究过，认真四处看看，大致上情况是摸清了：硬件上总共出了算是三代n个型号（第三代Zero刚出），第一代硬件资料全齐，第二代就有点遮遮掩掩。我买的第二代B型，外设方面4口USB2.0，TF插槽、网口、HDMI、耳机插口、DSI摄像头接口、DSI屏幕接口各一。首先，我感觉USB2.0有点落伍，至少给一个3.0吧；其次，没有Nand flash，略不方便；再次，GPIO接口有点少，就那么40Pin还共用了串口+i2c+spi*2，也没数模转换，有点不够用；最后，那个LCDC接口是给谁用的啊？要自己单独做块转接板那么麻烦……除此之外，硬件凑合，但拿来做开发板太浪费，除非你的东西计算量很大；用来当个小小服务器、小小Linux机还不错。<br>  软件方面，官方操作系统是Debian的。那套GUI对我来说真的有点鸡肋，居然还有Office和Mathematical，然而这种配置跑图形界面，]]>
    
    </summary>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/categories/RaspberryPi/"/>
    
  </entry>
  
</feed>
