<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[iOS开发和七七八八]]></title>
  <subtitle><![CDATA[Conan学习笔记]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://conanwhf.coding.me/"/>
  <updated>2017-06-12T15:01:25.000Z</updated>
  <id>http://conanwhf.coding.me/</id>
  
  <author>
    <name><![CDATA[Conan Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（四）配置Kernel]]></title>
    <link href="http://conanwhf.coding.me/2017/06/12/bootup-4-kernel/"/>
    <id>http://conanwhf.coding.me/2017/06/12/bootup-4-kernel/</id>
    <published>2017-06-12T09:31:26.000Z</published>
    <updated>2017-06-12T15:01:25.000Z</updated>
    <content type="html"><![CDATA[<p>如今的Linux比uboot要成熟得更多，所有的模块都是可配置的。所以基本上对于kernel的移植，特别是这种已经有基础源码的项目，代码改动其实相当少，更多是时间花在调试和配置上。在所有工作中，最主要的困难恐怕就是怎么把系统跑进console了。</p>
<h2 id="uImage__26amp_3B_zImage"><a href="#uImage__26amp_3B_zImage" class="headerlink" title="uImage &amp; zImage"></a>uImage &amp; zImage</h2><p>这个问题太基础，只是因为跟手动跑系统有关，所以稍微提一下。kernel编译后的成果是zImage，uImage只是添加了一个长度为0x40的头，用来记录给uboot的相关信息。虽然uImage是专门给uboot用的，但uboot的启动并不一定要uImage，它既可以接受uImage也可以接受zImage。可以说：uImage的头信息本质上是一种启动参数的传递形式。<br>制作uImage的工具是<strong>mkimage</strong>，它是来自于uboot。为了避免各种可能的版本问题，建议直接使用uboot编译后的<code>uboot/tools/mkimage</code>。而uImage的制作脚本则包含在kernel的编译脚本中，使用命令：<br><code>make uImage LOADADDR=0x80008000</code><br>即可编译获得uImage，前提是你已经将mkimage放入了编译环境的/bin/文件夹下。LOADADDR是kernel的启动地址（<strong>注意，这不是真正的kernel运行地址</strong>），uBoot会将kernel拷贝到此地址后（实际中也可能不拷贝）执行。关于uboot使用的几个内存地址的具体讲解也很多，这么些年也没什么变化，需要了解的可以自行去搜索。</p>
<h2 id="u6839_u6587_u4EF6_u7CFB_u7EDF_u7684_u5236_u4F5C"><a href="#u6839_u6587_u4EF6_u7CFB_u7EDF_u7684_u5236_u4F5C" class="headerlink" title="根文件系统的制作"></a>根文件系统的制作</h2><p>一个系统必须要有文件系统才能跑起来，即使是很小很小的文件系统。目前一个最基本的文件系统都是基于Busybox制作的，制作过程的教程很多也大同小异，我就不赘述了。有的厂商或者Linux系统发行商也会提供根文件系统的下载，不过大多太过冗余，需要自行裁剪。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2017/06/12/bootup-4-kernel/</p><p>访问原文「<a href='http://conanwhf.coding.me/2017/06/12/bootup-4-kernel/'>ARM板移植Linux系统启动（四）配置Kernel</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>对于一块空板子，通常的做法是用一个能进入命令行的最小文件系统，然后将完整的文件系统和kernel等烧写到存储设备上。所以如何做一个能够启动的最小系统，就成了第一个步骤。由于这种最小系统启动时还不会用到存储装置（emmc or nand flash），文件系统是跑在RAM里的，有两种做法：将其包含在Kernel的镜像中，或者用uboot加载到内存后告诉kernel加载的内存地址。</p>
<h3 id="u5E26Ramdisk_u7684Kernel_u955C_u50CF"><a href="#u5E26Ramdisk_u7684Kernel_u955C_u50CF" class="headerlink" title="带Ramdisk的Kernel镜像"></a>带Ramdisk的Kernel镜像</h3><p>menuconfig里面配置kernel:<br>General setup  —> 选中Initial RAM filesystem and RAM disk (initramfs/initrd) support，将（）Initramfs source file(s)填写为准备好的根文件系统路径<br><img src="http://whf.d.pr/zWYCTN+" alt=""><br>保存，编译后即可。</p>
<h3 id="U-boot_u652F_u6301_u7684rootfs_u955C_u50CF"><a href="#U-boot_u652F_u6301_u7684rootfs_u955C_u50CF" class="headerlink" title="U-boot支持的rootfs镜像"></a>U-boot支持的rootfs镜像</h3><p>另一种方法是使用单独的根文件系统镜像，这样不需要重新编译kernel，只需要把数据重新打包即可。</p>
<ol>
<li><p>生成空白Image，可以稍微预留大一点，全0数据压缩后可以忽略：</p>
<pre><code>dd if=/dev/zero of=TEMP bs=1M count=5
</code></pre></li>
<li><p>将image挂载为loop文件系统</p>
<pre><code>losetup /dev/loop0 TEMP
sudo mke2fs -m 0 /dev/loop0
mkdir -p loop 
sudo mount -t ext2 /dev/loop0 loop
</code></pre></li>
<li><p>将数据copy到挂载后的image中，然后卸载：</p>
<pre><code>sudo cp -raf initramfs/* loop
sudo umount loop; rm -rf loop
</code></pre></li>
<li><p>压缩并制作成img:</p>
<pre><code>gzip -v9 TEMP
mkimage -n &apos;YOUR_MARK ext2 uboot ramdisk&apos; -A arm -O linux -T ramdisk -C gzip -d TEMP.gz ramdisk.img
</code></pre><p>这里的mkimage就是上文提到的来自于uboot的工具，它同样也只是将已有的文件加了一个uboot可以识别的头信息。注意这里的<code>-A arm</code>必须和kernel的目标平台相对应，否则uboot会拒绝引导。</p>
</li>
</ol>
<h2 id="DTS_28Device_Tree_Source_29"><a href="#DTS_28Device_Tree_Source_29" class="headerlink" title="DTS(Device Tree Source)"></a>DTS(Device Tree Source)</h2><p>在老的内核版本中，关于硬件的定义、配置和描述都是通过各种头文件和<code>#define</code>来实现的，而在新的内核中已经全部使用了DTS来描述硬件信息，从而实现了更加灵活的硬件支持和配置。DTS中的“硬件描述”，准确地说是设备描述，包括所有的硬件设备和软件设备节点，从CPU到外设，从型号描述到地址定义，具体到设备节点到硬件的链接等等，都可以定义。<br>DTS的具体表达文件是<code>*.dtb</code>，它们是由一组遵循特定语法的dts源文件编译而成，放在<code>arch/$PLATFORM/boot/dts</code>下，对于arm板来说就是<code>arch/arm/boot/dts/</code>。这个文件夹底下的文件有点像config file，每个<code>*.dts</code>文件对应一种配置，而dts文件又可以通过include某些<code>$SLICON.dtsi</code>来作为配置的基础，在此基础上添加、覆盖原有内容。一个dts一般只对应一种板子，但同一块板子可以使用几种不同的dts，例如可以通过指定不同的dtb文件，来选择启动时将HDMI还是LCD屏作为标准输出（lcdc0）。以BeagleBoneBlack举例，它的基本启动配置是am335x-boneblack.dts，而它又inlcude了am33xx.dtsi, am335x-bone-common.dtsi, am33xx-pruss-rproc.dtsi等文件。<br>查找编译所对应的dts file，可以查看<code>arch/arm/boot/dts/Makefile</code>，看看kernel config里定义的<code>CONFIG_SOC_XXX</code>所对应编译出来的dtb文件。一般来说一个芯片下有好几个dtb文件，它们就是对应了不同的应用场景，需要根据需要选择一个来作为启动配置。如果需要添加自己的dts文件，除了新建一个dts文件以外，还要记得在这个Makefile中把自己的target dtb添加进去。<br>关于DTS设备定义的语法，也不是这篇文章的重点，请允许我跳过。</p>
<h3 id="u4F7F_u7528DTS_u542F_u52A8_u7CFB_u7EDF"><a href="#u4F7F_u7528DTS_u542F_u52A8_u7CFB_u7EDF" class="headerlink" title="使用DTS启动系统"></a>使用DTS启动系统</h3><p>之前我并没有使用过DTS，对它也只有耳闻，所以开始移植的时候并没有想到这个部分。做好了kernel在uboot中手动引导启动后，我发现系统停在了<code>Starting kernel ...</code>这样的打印信息之后。经过搜索资料，我发现很有可能是因为uboot和kernel的机器号(Mechine ID)不匹配，为了确定这个问题，我在kernel config中打开low-level的调试选项：</p>
<blockquote>
<p>Kernel hacking  —><br>|- (X) Kernel low-level debugging functions (read help!)<br>-|— Kernel low-level debugging port (Kernel low-level debugging…   —><br>—- |- ( ) Kernel low-level debugging messages via OMAP36XX UART4<br>—- |- ( ) Kernel low-level debugging messages via OMAP4/5 UART4<br>—- |- ( ) Kernel low-level debugging messages via TI81XX UART1<br>—- |- ( ) Kernel low-level debugging messages via TI81XX UART2<br>—- |- ( ) Kernel low-level debugging messages via TI81XX UART3<br>—- |- (X) Kernel low-level debugging messages via AM33XX UART1<br>|- (X) Early printk</p>
</blockquote>
<p>记得选对UART驱动，不然是看不到打印的。这个驱动不是在kernel的drivers里面配置对了就可以的，driver里面的驱动要等基本的项目初始化后才会跑，这里指的是提前初始化UART以提供打印的驱动程序。<br>然后再次尝试，看打印信息果然是这个原因，但奇怪的是，在aviliable mechine的list里面，只有一个0xFFFFFFFF的mechine ID。我跟踪了很久的kernel和uboot代码，还是对此一筹莫展，直到再次搜索了类似的情况，发现有人说使用新版本的kernel才会出现这种情况，才想到了是没有使用DTS的原因。<br>于是我添加了对dts文件的地址指定：</p>
<pre><code>fatload usb 0:1 0x82000000 am335x-boneblack.dtb
fatload usb 0:1 0x83000000 uImage
bootm 0x83000000 - 0x82000000
</code></pre><p>这次uboot将dtb加载并传递了地址给kernel，kernel能够看到所需要的各种初始化信息，终于顺利地将系统跑了起来。</p>
<h2 id="u7F16_u8BD1_u540E_u7684_u6587_u4EF6location"><a href="#u7F16_u8BD1_u540E_u7684_u6587_u4EF6location" class="headerlink" title="编译后的文件location"></a>编译后的文件location</h2><p>至此，系统已经能够跑进console，剩下的就是引导和烧写问题了。编译后的相关文件location如下，在制作文件系统时需要将它们更新至软件包中：</p>
<ul>
<li>kernel: ./boot/zImage</li>
<li>dts: ./boot/dst/XXX.dtb</li>
<li>firmware: ./lib/firmware/</li>
<li>module:/lib/modules/$KERNEL_VERSION</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>如今的Linux比uboot要成熟得更多，所有的模块都是可配置的。所以基本上对于kernel的移植，特别是这种已经有基础源码的项目，代码改动其实相当少，更多是时间花在调试和配置上。在所有工作中，最主要的困难恐怕就是怎么把系统跑进console了。</p>
<h2 id="uImage__26amp_3B_zImage"><a href="#uImage__26amp_3B_zImage" class="headerlink" title="uImage &amp; zImage"></a>uImage &amp; zImage</h2><p>这个问题太基础，只是因为跟手动跑系统有关，所以稍微提一下。kernel编译后的成果是zImage，uImage只是添加了一个长度为0x40的头，用来记录给uboot的相关信息。虽然uImage是专门给uboot用的，但uboot的启动并不一定要uImage，它既可以接受uImage也可以接受zImage。可以说：uImage的头信息本质上是一种启动参数的传递形式。<br>制作uImage的工具是<strong>mkimage</strong>，它是来自于uboot。为了避免各种可能的版本问题，建议直接使用uboot编译后的<code>uboot/tools/mkimage</code>。而uImage的制作脚本则包含在kernel的编译脚本中，使用命令：<br><code>make uImage LOADADDR=0x80008000</code><br>即可编译获得uImage，前提是你已经将mkimage放入了编译环境的/bin/文件夹下。LOADADDR是kernel的启动地址（<strong>注意，这不是真正的kernel运行地址</strong>），uBoot会将kernel拷贝到此地址后（实际中也可能不拷贝）执行。关于uboot使用的几个内存地址的具体讲解也很多，这么些年也没什么变化，需要了解的可以自行去搜索。</p>
<h2 id="u6839_u6587_u4EF6_u7CFB_u7EDF_u7684_u5236_u4F5C"><a href="#u6839_u6587_u4EF6_u7CFB_u7EDF_u7684_u5236_u4F5C" class="headerlink" title="根文件系统的制作"></a>根文件系统的制作</h2><p>一个系统必须要有文件系统才能跑起来，即使是很小很小的文件系统。目前一个最基本的文件系统都是基于Busybox制作的，制作过程的教程很多也大同小异，我就不赘述了。有的厂商或者Linux系统发行商也会提供根文件系统的下载，不过大多太过冗余，需要自行裁剪。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.coding.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（三）UBOOT移植]]></title>
    <link href="http://conanwhf.coding.me/2017/06/09/bootup-3-uboot/"/>
    <id>http://conanwhf.coding.me/2017/06/09/bootup-3-uboot/</id>
    <published>2017-06-09T09:31:26.000Z</published>
    <updated>2017-06-09T12:07:06.000Z</updated>
    <content type="html"><![CDATA[<p>经过这些年的演变，U-boot已经从一个简单的loader慢慢发展成了一个小小系统，硬件上原生支持各种平台、外设，软件上支持Fat&amp;ext234等文件系统、传输协议、测试工具，可以说相当完善了。这种进化，负面影响是让整体变得更复杂臃肿，但也有更多的正面影响，是让我们的移植工作更加简单、模块化。</p>
<h2 id="Uboot_u4EE3_u7801_u7ED3_u6784"><a href="#Uboot_u4EE3_u7801_u7ED3_u6784" class="headerlink" title="Uboot代码结构"></a>Uboot代码结构</h2><a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2017/06/09/bootup-3-uboot/</p><p>访问原文「<a href='http://conanwhf.coding.me/2017/06/09/bootup-3-uboot/'>ARM板移植Linux系统启动（三）UBOOT移植</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

<p>代码结构是了解uboot的基础，作为一个成熟的开源软件，uboot的代码结构很清晰。绝大多数的代码都是通用的，所以在移植过程中，基本上只需要找到自己的对应平台，修改板子特有的部分即可。<br>├── api                uboot提供的API接口<br>├── arch               与体系结构相关的代码<br>│   ├── arm<br>│   │   ├── mach-omap2  BeagleBoneBlack使用的架构<br>│   ├── x86<br>├── board              根据不同的具体开发板而定制的代码<br>│   ├── ti             厂商：TI<br>│   │   ├── am335x     BeagleBoneBlack使用的平台，主要的改动应该在这里，包括内存初始化<br>│   │   ├── beagle<br>│   │   ├── common<br>│   │   ├── evm<br>├── cmd                通用命令行处理工具<br>├── common             通用核心代码，主要给uboot使用，部分SPL<br>│   ├── spl            SPL的通用代码<br>├── configs            配置文件<br>├── disk               磁盘分区相关<br>├── doc                文档<br>├── drivers            各种驱动，uboot使用<br>├── dts                dtb文件的编译脚本<br>├── examples           范例<br>├── fs                 文件系统代码<br>├── include            公用头文件<br>│   ├── configs        不同板子配置选项的头文件<br>├── lib                通用库<br>├── net                网络相关<br>├── post               Power On Self Test，开机自检程序<br>├── scripts            编译脚本<br>├── test               测试程序<br>├── tools              相关小工具<br>如果是想要重新编译和优化uboot，那么通常修改配置文件即可；如果是一块硬件上有修改的板子，那么则需要另外关注board/XXX/部分，基于原有的初始化代码进行修改；如果是完全新设计的芯片，则必须根据芯片不同模块的datasheet自己添加一套初始化代码，只有arm平台的一些基本内容可以通用了。</p>
<h2 id="u542F_u52A8_u6D41_u7A0B"><a href="#u542F_u52A8_u6D41_u7A0B" class="headerlink" title="启动流程"></a>启动流程</h2><p>前一篇讲SPL的启动的时候提到，最初从<code>start.S</code> call到了<code>crt0.S</code>。<code>crt0.S</code>会先后调用<code>board_init_f()</code>和<code>board_init_r()</code>两个函数，当作为SPL编译时<code>board_init_f()</code>是直接返回的，而在uboot时是有用的。大致上来说，<code>board_init_f()</code>侧重于基础硬件的初始化，以及软件堆栈等方面的准备，更底层一点；而<code>board_init_r()</code>则更多的是软件方面的初始化，并且最终完成uboot启动过程或进入命令行。</p>
<h3 id="common/board_f-c"><a href="#common/board_f-c" class="headerlink" title="common/board_f.c"></a><code>common/board_f.c</code></h3><p>这是uboot(实际上是uboot第二阶段，<strong>u-boot.img</strong>所包含的内容，下文不再区分)的入口函数<code>board_init_f()</code>所在的文件。可以看到函数<code>board_init_f()</code>很简单，初始化全局变量后，就根据一个<code>init_sequence_f</code>依次运行不同的函数，失败则把系统hang住，成功当然就是进入正常的启动流程中去了。<code>init_sequence_f</code>在同一个文件中也有定义，很长，我删减无关平台的内容大致看看：</p>
<pre><code>static init_fnc_t init_sequence_f[] = {
//==========基本数据init，malloc数据块
    setup_mon_len,
#ifdef CONFIG_OF_CONTROL
    fdtdec_setup,
#endif
#ifdef CONFIG_TRACE
    trace_early_init,
#endif
    initf_malloc,
    initf_console_record,
//初始化CPU
    arch_cpu_init,      /* basic arch cpu dependent setup */
    mach_cpu_init,      /* SoC/machine dependent CPU setup */
    initf_dm,
    arch_cpu_init_dm,
    mark_bootstage,     /* need timer, go after init dm */
#if defined(CONFIG_BOARD_EARLY_INIT_F)
    board_early_init_f,
#endif
//==========Timer
#if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \
        defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \
        defined(CONFIG_SH) || defined(CONFIG_SPARC)
    timer_init,     /* initialize timer */
#endif
//==========初始化环境变量
    env_init,       /* initialize environment */
//==========初始化串口，并打印信息
    init_baud_rate,     /* initialze baudrate settings */
    serial_init,        /* serial communications setup */
    console_init_f,     /* stage 1 init of console */
    display_options,    /* say that we are here */
    display_text_info,  /* show debugging info if required */
    print_cpuinfo,      /* display cpu info (and speed) */
#if defined(CONFIG_DISPLAY_BOARDINFO)
    show_board_info,
#endif
//==========基本外设初始化，包括I2C，SPI，WatchDog等
    INIT_FUNC_WATCHDOG_INIT
#if defined(CONFIG_MISC_INIT_F)
    misc_init_f,
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
    init_func_i2c,
#endif
#if defined(CONFIG_HARD_SPI)
    init_func_spi,
#endif
//==========内存初始化
    announce_dram_init,
    /* TODO: unify all these dram functions? */
#if defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \
        defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) || \
        defined(CONFIG_SH)
    dram_init,      /* configure available RAM banks */
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_SYS_DRAM_TEST)
    testdram,
#endif /* CONFIG_SYS_DRAM_TEST */
    INIT_FUNC_WATCHDOG_RESET
//==========一堆显示相关的初始化，略
    /*
     * Now that we have DRAM mapped and working, we can
     * relocate the code and continue running from DRAM.
     *
     * Reserve memory at end of RAM for (top down in that order):
     *  - area that won&apos;t get touched by U-Boot and Linux (optional)
     *  - kernel log buffer
     *  - protected RAM
     *  - LCD framebuffer
     *  - monitor code
     *  - board info struct
     */
//==========将环境变量重置，并打印相关信息
    setup_machine,
    reserve_global_data,
    reserve_fdt,
    reserve_arch,
    reserve_stacks,
    setup_dram_config,
    show_dram_config,
    display_new_sp,
#ifdef CONFIG_SYS_EXTBDINFO
    setup_board_extra,
#endif
    INIT_FUNC_WATCHDOG_RESET
    reloc_fdt,
    setup_reloc,
    NULL,
};
</code></pre><h2 id="common/board_r-c"><a href="#common/board_r-c" class="headerlink" title="common/board_r.c"></a><code>common/board_r.c</code></h2><p>类似的，在<code>board_init_r()</code>中也会按顺序调用这么一个函数列表，函数名都很容易看懂，具体就不列出来了。跟<code>board_init_f()</code>不同的是，它最后有一个<code>run_main_loop</code>：</p>
<pre><code>init_fnc_t init_sequence_r[] = {
    initr_trace,
    initr_reloc,
    ......
    run_main_loop,
};
</code></pre><p>这个函数会进入一个死循环，尝试自动启动系统或者进入uboot的命令行：</p>
<pre><code>static int run_main_loop(void)
{
ifdef CONFIG_SANDBOX
sandbox_main_loop_init();
endif
/* main_loop() can return to retry autoboot, if so just run it again */
for (;;)
main_loop();
return 0;
} 
</code></pre><h2 id="common/main-c"><a href="#common/main-c" class="headerlink" title="common/main.c"></a><code>common/main.c</code></h2><p>函数<code>main_loop()</code>的实现在main.c，可以看到，做好最后的准备工作后，uboot会尝试用<code>autoboot_command(s)</code>来启动kernel，如果失败，则进入<code>cli_loop()</code>函数中。</p>
<pre><code>void main_loop(void)
{
        const char *s;

        bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, &quot;main_loop&quot;);

#ifdef CONFIG_VERSION_VARIABLE
        setenv(&quot;ver&quot;, version_string);  /* set version variable */
#endif /* CONFIG_VERSION_VARIABLE */

        cli_init();

        run_preboot_environment_command();

#if defined(CONFIG_UPDATE_TFTP)
        update_tftp(0UL, NULL, NULL);
#endif /* CONFIG_UPDATE_TFTP */

        s = bootdelay_process();
        if (cli_process_fdt(&amp;s))
                cli_secure_boot_cmd(s);

        autoboot_command(s);

        cli_loop();
        panic(&quot;No CLI available&quot;);
}
</code></pre><h2 id="cli_loop_28_29"><a href="#cli_loop_28_29" class="headerlink" title="cli_loop()"></a><code>cli_loop()</code></h2><p>这个函数比较简单，追踪code可以看到，<code>common/cli.c, cli_loop()-&gt;common/cli_simple.c, cli_simple_loop()</code>， <code>cli_simple_loop()</code>就是uboot的命令行了，不断读取用户输入来做出反应，同样也是个死循环。所以绝大部分的时候，<code>main_loop()</code>中的循环并不会进行多次，而是一旦自动启动失败就进入了命令行，不会再次自动尝试启动。</p>
<h2 id="u4FEE_u6539_u79FB_u690D"><a href="#u4FEE_u6539_u79FB_u690D" class="headerlink" title="修改移植"></a>修改移植</h2><p>一般简单的板子移植，主要是内存初始化代码，和硬件配置选项，以及启动变量。硬件的驱动是不需要自己写的，但要配置准确。这些修改主要集中在两个地方：配置头文件和平台对应的board.c。以BeagleBoneBlack为例，它的特别内容都在以下两个文件中：</p>
<ul>
<li><code>board/ti/am335x/board.c</code></li>
<li><code>include/configs/am335x_evm.h</code><br>这是编译时脚本根据config中<code>CONFIG_TARGET_AM335X_EVM=y</code>来对应的，不同的平台文件会有所不同，但都可以通过查看Makefile和Kconfig来找到正确的文件。下文均以BeagleBoneBlack为例。</li>
</ul>
<h3 id="u542F_u52A8_u65B9_u5F0F"><a href="#u542F_u52A8_u65B9_u5F0F" class="headerlink" title="启动方式"></a>启动方式</h3><p>当uboot的启动流程进入到autoboot，其历史使命基本上也就完成了。但对于一个移植的板子来说，配置自动启动的选项却是一个很重要的问题。启动方式的列表定义在在<code>am335x_evm.h</code>中:</p>
<pre><code>define BOOT_TARGET_DEVICES(func) \
func(MMC, mmc, 0) \
func(LEGACY_MMC, legacy_mmc, 0) \
func(MMC, mmc, 1) \
func(LEGACY_MMC, legacy_mmc, 1) \
func(NAND, nand, 0) \
func(PXE, pxe, na) \
func(DHCP, dhcp, na)
endif
</code></pre><p>很容易看到这个启动方式是emmc,nand,PXE,DHCP，可以自己按照需要调整顺序或者添删。</p>
<h3 id="u5185_u5B58_u521D_u59CB_u5316"><a href="#u5185_u5B58_u521D_u59CB_u5316" class="headerlink" title="内存初始化"></a>内存初始化</h3><p>在<code>board/ti/am335x/board.c</code>中的函数<code>sdram_init()</code>就是内存的初始化函数，它会根据EEPROM得到的板子型号，对应不同的DRAM配置。阅读代码不难发现，配置具体信息是定义在<code>arch/arm/include/asm/arch-am33xx/ddr_defs.h</code>。如果需要修改或者添加不同的内存配置，修改这两个文件即可。</p>
<h3 id="u5176_u4ED6_u786C_u4EF6_u8C03_u6574"><a href="#u5176_u4ED6_u786C_u4EF6_u8C03_u6574" class="headerlink" title="其他硬件调整"></a>其他硬件调整</h3><p>绝大多数硬件的配置定义都在<code>am335x_evm.h</code>中，包括各种模块的Base address、初始化值、硬件定义等等，读者可以自行阅读。这些设置有的是根据芯片的手册而定，比如说memory的初始化值；有的是根据硬件设计而定，比如USB的Host &amp; PERIPHERAL设置；有的是可以根据需要自行决定，比如<code>CONFIG_SYS_BOOTM_LEN</code>。具体改什么、怎么改，要根据情况分析而定。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过这些年的演变，U-boot已经从一个简单的loader慢慢发展成了一个小小系统，硬件上原生支持各种平台、外设，软件上支持Fat&amp;ext234等文件系统、传输协议、测试工具，可以说相当完善了。这种进化，负面影响是让整体变得更复杂臃肿，但也有更多的正面影响，是让我们的移植工作更加简单、模块化。</p>
<h2 id="Uboot_u4EE3_u7801_u7ED3_u6784"><a href="#Uboot_u4EE3_u7801_u7ED3_u6784" class="headerlink" title="Uboot代码结构"></a>Uboot代码结构</h2>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.coding.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（二）SPL]]></title>
    <link href="http://conanwhf.coding.me/2017/06/08/bootup-2-spl/"/>
    <id>http://conanwhf.coding.me/2017/06/08/bootup-2-spl/</id>
    <published>2017-06-08T09:31:26.000Z</published>
    <updated>2017-06-08T11:03:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u542F_u52A8_u6A21_u5F0F"><a href="#u542F_u52A8_u6A21_u5F0F" class="headerlink" title="启动模式"></a>启动模式</h2><p>面对一块完全的空板子，首先要做的当然是让它启动起来。emmc/nand中完全没有内容，意味着没有uboot，没有命令行，所有的硬件包括内存都没有初始化，除了CPU。在上电的CPU之上，还跑了一个小小的叫做BootROM的程序。<br>通常每块芯片，都在硬件中包含了一个BootROM，是一个小程序，上电后自动运行，无法修改，不同的厂家有不同的设计，但都是给定几种不同的启动模式，然后循环检测。TI这块板就支持各种模式，如emmc, nand flash, network, spi, uart等。<br>所谓的不同启动模式，本质上也是类似的，都是从某个设备中读取很少的一点数据放到一定的地方（一般是SRAM或者STACK），然后把PC指针交给它。所以并不是支持什么启动就可以直接在设备上放操作系统了，BootROM能做的只是很基础的硬件初始化工作，更多的事情是需要Uboot来完成。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2017/06/08/bootup-2-spl/</p><p>访问原文「<a href='http://conanwhf.coding.me/2017/06/08/bootup-2-spl/'>ARM板移植Linux系统启动（二）SPL</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>言归正传。对于我手头的这块板子，没有nand flash，没有外接emmc(TF卡)，没有网口，板载emmc是空的，那么只能从UART启动了。TI对于Uart启动模式的设计，是将编译出来的<strong>u-boot-spl.bin</strong>（下文称为spl）使用<strong>xmodem</strong>通过串口传输过去，跑起来之后再开启ymodem接收模式，等待串口用<strong>ymodem</strong>传输<strong>u-boot.img</strong>(下文称为u-boot)完毕，将u-boot跑起来。</p>
<h2 id="SRAM_u548CDRAM"><a href="#SRAM_u548CDRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h2><p>下载了代码，重新编译之后，却发现连spl都完全没有打印信息。经过跟踪代码添加打印，发现好像spl根本没有跑起来，这让人感到很奇怪。我手头的板子是改过内存芯片的，uboot跑不起来很正常，因为DRAM可能没有正确初始化。但SPL我认为应该是跑在SRAM里的，SRAM只要上电便可以使用，不应该没有任何反应。<br>阅读文档和Debug信息之后，发现竟然还有个配置选项，是先初始化DRAM，再让SPL从DRAM的固定地址启动。它们定义在编译uboot的config中：<br><code>configs/am335x_boneblack_defconfig</code></p>
<pre><code>CONFIG_SPL_STACK_R_ADDR=0x82000000
CONFIG_SPL_STACK_R=y
</code></pre><p>跟踪代码，可以看到在ARM的初始化汇编程序中会调用这样的函数：<br><code>arch/arm/lib/crt0.S</code></p>
<pre><code># if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK)
# ifdef CONFIG_SPL_BUILD
/* Use a DRAM stack for the rest of SPL, if requested */
bl      spl_relocate_stack_gd
cmp     r0, #0
movne   sp, r0
movne   r9, r0
# endif
ldr     r0, =__bss_start        /* this is auto-relocated! */
</code></pre><p>而函数<code>spl_relocate_stack_gd</code>则在<code>common/spl/spl.c</code>中实现。在config中将<code>CONFIG_SPL_STACK_R=y</code>删除，SPL则顺利地跑起来，有了打印信息。<br>这个部分当时我十分费解，因为SPL原本是不需要配置DRAM然后再跑的，但我看了一下TI和uboot的release，很多板子都用到了这样的配置，不明白为什么。解决这个问题后，我就将SPL放在SRAM里的设置保留了下去。后来继续做移植的时候，因为这个问题我掉了一个坑，才知道这样的设置是有原因的：<br>做到烧写bootloader的时候，发现我烧的bootloader跑不起来，总是出了一半打印信息就死了。经过回想，自己的bootloader除了不会影响的硬件设置改动，跟Beaglebone原生的release差别就在这个SRAM和DRAM的问题了，后来一试果然如此。大概是因为从eMMC启动的SPL需要初始化eMMC，有一些地方还是要用到DRAM，才这么设计的吧。</p>
<h2 id="u4EE3_u7801_u6D41_u7A0B"><a href="#u4EE3_u7801_u6D41_u7A0B" class="headerlink" title="代码流程"></a>代码流程</h2><p>SPL主要的内容分为三个部分：启动ARM的汇编，和uboot共享的设备初始化，以及SPL本身独有的代码。SPL自身的代码在common/spl/下，而每个板子特有的设备初始化代码在board/ti/am335x/下，通过查看<code>scripts/Makefile.spl</code>可以知道，用来引导启动的MLO文件实际上是基于u-boot-spl.bin做出来的，所以基本可以看作是同样的代码。整个SPL的作用可以说就是“初始化”，是各个层次的XXX_board_init()函数互相调用的过程，下面通过阅读代码把启动流程大致过一遍（代码部分提炼，删减不重要部分）。</p>
<h3 id="arch/arm/cpu/armv7/start-S"><a href="#arch/arm/cpu/armv7/start-S" class="headerlink" title="arch/arm/cpu/armv7/start.S"></a><code>arch/arm/cpu/armv7/start.S</code></h3><p>这是上电后最开始的代码部分，对部分寄存器的状态进行设置，完成后调用<code>_main</code></p>
<pre><code>/* Set vector address in CP15 VBAR register */
ldr     r0, =_start
mcr     p15, 0, r0, c12, c0, 0  @Set VBAR
# endif

/* the mask ROM code should have PLL and others stable */
# ifndef CONFIG_SKIP_LOWLEVEL_INIT
bl      cpu_init_cp15
# ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
bl      cpu_init_crit
# endif
# endif

bl      _main
</code></pre><h3 id="arch/arm/lib/crt0-S"><a href="#arch/arm/lib/crt0-S" class="headerlink" title="arch/arm/lib/crt0.S"></a><code>arch/arm/lib/crt0.S</code></h3><p>这段代码的开头注释写得很清楚，它是ARM启动很重要的一段过程，完成了代码段、基础硬件(RAM)、stack等的初始化和配置，最终将指针交给了<code>board_init_r()</code>。</p>
<h3 id="common/spl/spl-c"><a href="#common/spl/spl-c" class="headerlink" title="common/spl/spl.c"></a><code>common/spl/spl.c</code></h3><p>uboot中通用的SPL代码，基本的<code>board_init_r()</code>实现，首先初始化SPL需要的内存空间，然后通过<code>spl_board_init()</code>初始化板子的基础部分，接着按照<code>board_boot_order</code>中的设备依次尝试读取uboot数据，并启动uboot。</p>
<pre><code>void board_init_r(gd_t *dummy1, ulong dummy2)
{
u32 spl_boot_list[]() = {
    BOOT_DEVICE_NONE,
    BOOT_DEVICE_NONE,
    BOOT_DEVICE_NONE,
    BOOT_DEVICE_NONE,
    BOOT_DEVICE_NONE,
};
struct spl_image_info spl_image;

debug(&quot;&gt;&gt;spl:board_init_r()\n&quot;);

if (!(gd-&gt;flags &amp; GD_FLG_SPL_INIT)) {
    if (spl_init())
        hang();
    }

# ifdef CONFIG_SPL_BOARD_INIT
    spl_board_init();
# endif

memset(&amp;spl_image, &apos;\0&apos;, sizeof(spl_image));
board_boot_order(spl_boot_list);

if (boot_from_devices(&amp;spl_image, spl_boot_list,
  ARRAY_SIZE(spl_boot_list))) {
    puts(&quot;SPL: failed to boot from all boot devices\n&quot;);
    hang();
}
switch (spl_image.os) {
    case IH_OS_U_BOOT:
        debug(&quot;Jumping to U-Boot\n&quot;);
    break;
    default:
        debug(&quot;Unsupported OS image.. Jumping nevertheless..\n&quot;);
}

debug(&quot;loaded - jumping to U-Boot...&quot;);
spl_board_prepare_for_boot();
jump_to_image_no_args(&amp;spl_image);
}
</code></pre><h3 id="arch/arm/mach-omap2/boot-common-c"><a href="#arch/arm/mach-omap2/boot-common-c" class="headerlink" title="arch/arm/mach-omap2/boot-common.c"></a><code>arch/arm/mach-omap2/boot-common.c</code></h3><p>这是OMAP芯片的通用代码，实现了<code>spl_board_init()</code>。首先保存中间状态，然后call <code>preloader_consle_init()</code>来初始化Uart和打印显示（位于<code>common/spl/spl.c</code>）。完成之后我们便能通过UART看到在SPL中的打印信息。<br>接下来是硬件相关部分：初始化SPL，I2C，MISC，WatchDog，最后call到am33xx的spl代码<code>am33xx_spl_board_init()</code>。</p>
<pre><code>void spl_board_init(void)
{
/*  * Save the boot parameters passed from romcode.
     * We cannot delay the saving further than this,
         * to prevent overwrites.
         */
        save_omap_boot_params();

        /* Prepare console output */
        preloader_console_init();

# if defined(CONFIG_SPL_NAND_SUPPORT) || defined(CONFIG_SPL_ONENAND_SUPPORT)
    gpmc_init();
# endif
# ifdef CONFIG_SPL_I2C_SUPPORT
    i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE);
# endif
# if defined(CONFIG_AM33XX) &amp;&amp; defined(CONFIG_SPL_MUSB_NEW_SUPPORT)
    arch_misc_init();
# endif
# if defined(CONFIG_HW_WATCHDOG)
    hw_watchdog_init();
# endif
# ifdef CONFIG_AM33XX
    am33xx_spl_board_init();
# endif
}
</code></pre><h3 id="board/ti/am335x/board-c"><a href="#board/ti/am335x/board-c" class="headerlink" title="board/ti/am335x/board.c"></a><code>board/ti/am335x/board.c</code></h3><p>特定板子的硬件实现，完成了<code>am33x_spl_board_init()</code>。这里根据<code>board_is_XXX()</code>函数确定不同的板子型号，继而进行不同的硬件初始化流程。要注意这个板子的型号是根据EEPROM中烧录的信息来确定的，如果硬件上有修改，需要手动进行一些特殊处理。我手头的板子就是没有这个EEPROM的，当时也给我造成了一点小麻烦。<br>这些硬件初始化都完成后，就可以一路跳回<code>common/spl/spl.c, board_init_r()</code>，跑后续的uboot启动流程。至此，SPL任务完成！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u542F_u52A8_u6A21_u5F0F"><a href="#u542F_u52A8_u6A21_u5F0F" class="headerlink" title="启动模式"></a>启动模式</h2><p>面对一块完全的空板子，首先要做的当然是让它启动起来。emmc/nand中完全没有内容，意味着没有uboot，没有命令行，所有的硬件包括内存都没有初始化，除了CPU。在上电的CPU之上，还跑了一个小小的叫做BootROM的程序。<br>通常每块芯片，都在硬件中包含了一个BootROM，是一个小程序，上电后自动运行，无法修改，不同的厂家有不同的设计，但都是给定几种不同的启动模式，然后循环检测。TI这块板就支持各种模式，如emmc, nand flash, network, spi, uart等。<br>所谓的不同启动模式，本质上也是类似的，都是从某个设备中读取很少的一点数据放到一定的地方（一般是SRAM或者STACK），然后把PC指针交给它。所以并不是支持什么启动就可以直接在设备上放操作系统了，BootROM能做的只是很基础的硬件初始化工作，更多的事情是需要Uboot来完成。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.coding.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARM板移植Linux系统启动（一）启动流程]]></title>
    <link href="http://conanwhf.coding.me/2017/05/30/bootup-1-main/"/>
    <id>http://conanwhf.coding.me/2017/05/30/bootup-1-main/</id>
    <published>2017-05-30T09:31:26.000Z</published>
    <updated>2017-06-01T10:25:06.000Z</updated>
    <content type="html"><![CDATA[<p>几年前，我是一个标准的原厂Linux系统开发人员，用公司自己的芯片，移植整套BSP。对于Linux系统启动方面，自认为摸得很熟了，从上电加载的汇编码到Linux内核及文件系统的配置，无一不留下了我修改的代码，细节精确到nand flash的某block某page放了什么代码，内存某个地址加载的是什么，代码某个改动是为了兼容什么project，一清二楚。所以最近接到这个移植系统的工作，信心挺足，估摸硬件没有问题的话几天之内移植就能完成，哪知道被现实结结实实打脸。<br>之前我用的Linux系统是2.6，Uboot版本不详但Fat32的支持还是我们自己移植进去的，可以说相当跟不上时代了。最新的Kernel早就采用了DTS，Uboot也加了很多功能和驱动，我在移植的过程中几乎完成了一次重新学习的过程。虽然我这次用的板是基于TI的，但我希望能不局限于具体的板子型号，而是把规律性的东西写出来，让后来人有个参考。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2017/05/30/bootup-1-main/</p><p>访问原文「<a href='http://conanwhf.coding.me/2017/05/30/bootup-1-main/'>ARM板移植Linux系统启动（一）启动流程</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
<h2 id="u786C_u4EF6_u73AF_u5883"><a href="#u786C_u4EF6_u73AF_u5883" class="headerlink" title="硬件环境"></a>硬件环境</h2><p>首先交代背景。我在前公司做的板子硬件是自己设计的，系统烧写在nand flash上，也支持从SD卡加载Uboot和Kernel uImage启动。大致的启动流程是BootROM上电读取nandflash上某个固定page的数据，大小不超过2K（为了兼容不同的nand flash page），这是IPL，然后自加载启动程序，初始化RAM, flash，接着读取Uboot，用Uboot加载flash上的内核和跟文件系统，跑起来。Uboot、Kernel、rootdisk都是用特定的工具写在Flash固定的位置，没有基于文件系统。<br>这次我要做的板子，硬件是基于TI的BeagleBoneBlack，拿掉了一些不需要的硬件，也修改了一些东西。影响比较大的是拿掉了CapeSystem用的EEPROM，网口，TF卡，以及换了一块内存芯片，能用的只剩下USB，和内部的一块emmc。TI的文档对于手动修改、编译、烧写等方面的信息写得语焉不详，源码也有点问题，我的移植过程变得跟想象的不太一样，有点摸索前进的感觉。</p>
<h2 id="u542F_u52A8_u6D41_u7A0B"><a href="#u542F_u52A8_u6D41_u7A0B" class="headerlink" title="启动流程"></a>启动流程</h2><p>言归正传。对于任何Linux系统启动的流程，其实都是一样的：</p>
<ol>
<li>系统上电，BootROM寻找可以用来启动的设备，从设备中读取SPL</li>
<li>运行SPL读取和跑起来真正的Uboot</li>
<li>在Uboot中读取Kernel、根文件系统、DTB，加载到各自的内存地址中</li>
<li>将启动参数通过启动命令传递给Kernel，跳转到Kernel运行</li>
<li>Kernel初始化基本部分，加载根文件系统，启动完毕</li>
</ol>
<p>SPL和Uboot都来自于U-boot的release，有部分共用的代码，编译完毕同时得到。注意在TI的SDK中（其他的我不清楚是否一样）,SPL有两种形式：u-boot-spl.bin和MLO。它们一个是串口启动用，一个是eMMC/Nandflash启动用，不能混用。以上每个阶段不同的东西跑起来的步骤都是一样的：被加载到内存的某个地址，PC指针跳转运行。区别只是在于<strong>被谁加载、从哪里加载、加载到内存的哪里</strong>。</p>
<h3 id="u542F_u52A8_u6D41_u7A0B_u7684_u53D8_u5F0F"><a href="#u542F_u52A8_u6D41_u7A0B_u7684_u53D8_u5F0F" class="headerlink" title="启动流程的变式"></a>启动流程的变式</h3><h4 id="u88AB_u8C01_u52A0_u8F7D"><a href="#u88AB_u8C01_u52A0_u8F7D" class="headerlink" title="被谁加载"></a><strong>被谁加载</strong></h4><p>对于一个完整的流程而言，每个文件被谁加载基本上都是固定的，除了根文件系统。根文件系统既有可能被uboot加载，也可能被kernel加载。注意被uboot加载时，根文件系统需要做成一个uboot能够接受的image，有固定的头，类似zImage和uImage的区别。而在调试过程中，加载的过程有可能是手动的，或者通过不同的设备传输拷贝，被谁加载其实完全不重要了。</p>
<h4 id="u4ECE_u54EA_u91CC_u52A0_u8F7D"><a href="#u4ECE_u54EA_u91CC_u52A0_u8F7D" class="headerlink" title="从哪里加载"></a><strong>从哪里加载</strong></h4><p>这个问题的各种变化，就对应了不同的启动模式（一般意义上的，非硬件意义上）。你当然可以所有的东西都读取自内置emmc，也可以插卡让系统从卡上加载；你也可以从Uart传输uboot的image跑起来，进入uboot的命令行，手动从TF卡或者网络读取kernel；你甚至可以在uboot中从nand flash读取Kernel image，从网络获得根文件系统，从usb中加载dtb，从TF卡里拿到启动参数，最后把它们综合到一起，引导整个系统。</p>
<h4 id="u52A0_u8F7D_u5230_u5185_u5B58_u7684_u54EA_u91CC"><a href="#u52A0_u8F7D_u5230_u5185_u5B58_u7684_u54EA_u91CC" class="headerlink" title="加载到内存的哪里"></a><strong>加载到内存的哪里</strong></h4><p>其实也很简单：加载到哪里都可以，只要不冲突。首先是要计算好文件的大小，不要让后来加载的文件覆盖了之前的；然后是最好将Kernel从较高的地址跑起来，规划好内存分区，以免kernel跑起来后破坏了根文件系统等数据。关于怎么定义内存地址，又是另外一个话题，网上教程很多，我就不多说了。</p>
<h4 id="u52A0_u8F7D_u6587_u4EF6_u7684_u53D8_u5316"><a href="#u52A0_u8F7D_u6587_u4EF6_u7684_u53D8_u5316" class="headerlink" title="加载文件的变化"></a>加载文件的变化</h4><p>在实际中，Kernel启动的阶段变化很多，Kernel、根文件系统、DTB这三个部分也并非形式僵化的三个文件。比如大部分日常启动时，uboot只加载了kernel和dtb，文件系统往往是kernel后来自己mount上去的，这时候只是传递了一个启动参数，<em>root=XXXXX</em>；而调试阶段常用的自带rootdisk的kernel，也不需要另外加载根文件系统。DTB文件是DTS全面应用之后才出现的，定义了板子的硬件设备信息，经过某些特殊配置有时也是可以省略（理论上，并未亲测过）。</p>
<p>   在调试中，往往会遇到很多启动的问题，明确启动的这几个基本原则和流程，能让调试的过程更轻松。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>几年前，我是一个标准的原厂Linux系统开发人员，用公司自己的芯片，移植整套BSP。对于Linux系统启动方面，自认为摸得很熟了，从上电加载的汇编码到Linux内核及文件系统的配置，无一不留下了我修改的代码，细节精确到nand flash的某block某page放了什么代码，内存某个地址加载的是什么，代码某个改动是为了兼容什么project，一清二楚。所以最近接到这个移植系统的工作，信心挺足，估摸硬件没有问题的话几天之内移植就能完成，哪知道被现实结结实实打脸。<br>之前我用的Linux系统是2.6，Uboot版本不详但Fat32的支持还是我们自己移植进去的，可以说相当跟不上时代了。最新的Kernel早就采用了DTS，Uboot也加了很多功能和驱动，我在移植的过程中几乎完成了一次重新学习的过程。虽然我这次用的板是基于TI的，但我希望能不局限于具体的板子型号，而是把规律性的东西写出来，让后来人有个参考。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://conanwhf.coding.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多说评论关闭]]></title>
    <link href="http://conanwhf.coding.me/2017/03/23/DuoShuoClose/"/>
    <id>http://conanwhf.coding.me/2017/03/23/DuoShuoClose/</id>
    <published>2017-03-23T09:35:25.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚发现多说不正常，去官网看，才发现多说已经要关了……</p>
<blockquote>
<p>重要通知: 多说即将关闭<br>多说网 发表于 3月21日<br>因公司业务调整，非常遗憾的向大家宣布多说项目即将关闭。 我们将于2017年6月1日正式关停服务，在此之前您可以通过后台的数据导出功能导出自己站点的评论数据。 对此给您造成的不便，我们深表歉意，感谢您的一路相伴。</p>
</blockquote>
<p>感谢多说在过去日子里提供的服务，一个无法变现的项目难以为继，作为程序员我能理解。合适的新评论系统我还没有找到，国内的服务太多广告太一言难尽，国外的又太慢会被墙，不然我也不会专门在coding放个整站镜像了。所以目前的计划是所有评论暂时关闭，如果有什么想说的，欢迎发email给我交流，或者在github上留言也OK。虽然这么长时间并没有什么人留言，但还是感谢每一个关注的人。谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚发现多说不正常，去官网看，才发现多说已经要关了……</p>
<blockquote>
<p>重要通知: 多说即将关闭<br>多说网 发表于 3月21日<br>因公司业务调整，非常遗憾的向大家宣布多说项目即将关闭。 我们将于2017年6月1日正式关停服务，在此之前您可以通]]>
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2017年02月]]></title>
    <link href="http://conanwhf.coding.me/2017/02/28/Tips201702/"/>
    <id>http://conanwhf.coding.me/2017/02/28/Tips201702/</id>
    <published>2017-02-28T09:25:39.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<p>9月份出去玩了一趟又回了个国，在外面晃了快两个月，啥工作都荒废了。更别说回来以后就开始犯懒打滚不工作，一直到年前才开始整理近半年积攒下来的未读文章😛，真是工程浩大！只好拿出耐心慢慢来……</p>
<ul>
<li>APP包瘦身<ol>
<li>删除项目中没有使用的图片。 查找XCode工程中没被使用的图片资源</li>
<li>删除项目中没有用到的class 和 xib 及storyboard。分析工程中没有用到class<ul>
<li>安装 fui 工具:<code>sudo gem install fui -n /usr/local/bin</code></li>
<li>fui usage: <a href="https://github.com/dblock/fui" target="_blank" rel="external">https://github.com/dblock/fui</a></li>
<li>到工程目录下，执行 <code>fui find</code> 命令，可以找出所有的没有用到的class文件。</li>
</ul>
</li>
<li>分析ipa包，找出大于500K的文件或内容 使用<code>find . -type f -size +500000c | xargs ls -lh</code></li>
</ol>
</li>
<li><strong>给代码排序</strong>：使用Spotlight来搜索Automator，并打开它；然后点击File->New，并选择服务(service)一项；在Actions筛选栏，输入shell，然后双击运行shell脚本；在新添加的服务的菜单栏上,检查Output replaces selected text；<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2017/02/28/Tips201702/</p><p>访问原文「<a href='http://conanwhf.coding.me/2017/02/28/Tips201702/'>开发Tips收集-2017年02月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
将脚本内容切换至sort | uniq；同时按下command ＋ s，将服务保存为 Sort &amp; Uniq。</li>
<li>iOS之报错“Cannot create _weak reference in file using manual reference counting”解决办法：在Build Settings———>Aplle LLVM8.0 - Language - Objectibe-C————->Weak Reference In Manual Retain Release 设置为YES。</li>
<li>尽量不要调用familyName来创建系统文字，否则会导致系统字体的自动调整功能失效。</li>
<li>sqlite 数据库中，当把表里的数据都清空时，下次插入的数据的 id 主键不会从 0 开始。保险起见 下次从数据库获取数据时先获取第一个的 id 主键</li>
<li>如果设置了 tableView 的上边距再使用 MJRefresh时，刷新控件会错位，可使用忽略 tableView等的内边距方法，该方法在类：MJRefreshHeader 里，方法名 ignoredScrollViewContentInsetTop</li>
<li>填写表单型的 tableView，用到了 textField 要注意需要显示的是 textField.text 还是 textField.placeholder，注意 cell 循环引用。 需要写多种类似的表格时，UI 界面就一套，用本地不同的 plist 数据去控制表格，给数据很多属性来区分：增加正则判断数值，增加样式…</li>
<li>kvc 修改已有类的私有属性是可以的，使用苹果未暴露的类的私有属性和方法是不允许的</li>
<li>真机测试的时候报错：“The application could not be verified”。解决方法：删除 App；重启 Xcode；Xcode clean；Xcode run</li>
<li>Xcode 8日志疯了解决办法：在 Scheme 设置里加一条 OS_ACTIVITY_MODE ，设置为 disable</li>
<li>如果我们想知道程序启动的时间，则可以在工程的scheme中添加环境变量DYLD_PRINT_STATISTICS，这样在调试时，可以在控制台打印出程序启动过程中各个阶段所消耗的时间。</li>
<li>使用struct来定义常量，可以最大程度地利用Swift类型安全的语言特性，使你在编译期就可以检查出一些低级的失误。</li>
<li>使用Asset Catalogs来图像资源文件：采取Asset Catalog进行统一管理后，不仅工程干净清爽了许多，还可以用一张矢量图来让XCode自动为你生成不同分辨率的资源。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<p>9月份出去玩了一趟又回了个国，在外面晃了快两个月，啥工作都荒废了。更别说回来以后就开始犯懒打滚不工作，一直到年前才开始整理近半年积攒下来的未读文章😛，真是工程浩大！只好拿出耐心慢慢来……</p>
<ul>
<li>APP包瘦身<ol>
<li>删除项目中没有使用的图片。 查找XCode工程中没被使用的图片资源</li>
<li>删除项目中没有用到的class 和 xib 及storyboard。分析工程中没有用到class<ul>
<li>安装 fui 工具:<code>sudo gem install fui -n /usr/local/bin</code></li>
<li>fui usage: <a href="https://github.com/dblock/fui">https://github.com/dblock/fui</a></li>
<li>到工程目录下，执行 <code>fui find</code> 命令，可以找出所有的没有用到的class文件。</li>
</ul>
</li>
<li>分析ipa包，找出大于500K的文件或内容 使用<code>find . -type f -size +500000c | xargs ls -lh</code></li>
</ol>
</li>
<li><strong>给代码排序</strong>：使用Spotlight来搜索Automator，并打开它；然后点击File->New，并选择服务(service)一项；在Actions筛选栏，输入shell，然后双击运行shell脚本；在新添加的服务的菜单栏上,检查Output replaces selected text；]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2017-02]]></title>
    <link href="http://conanwhf.coding.me/2017/02/28/ReadingList2017-02/"/>
    <id>http://conanwhf.coding.me/2017/02/28/ReadingList2017-02/</id>
    <published>2017-02-28T02:36:54.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>术与道:移动应用UI设计必修课</strong><br>家里人这次过来帮我带了不少实体书，这就是其中的一本，亚马逊双十一打折时候买的。整本书内容很少，图特别多，用零碎时间翻了两下就看完了。开始的时候，即使是小白如我也觉得作者在凑字数骗稿费，后来慢慢地看出一点点门道，关于APP设计的思维和规范，虽然书里真的没讲什么，都是基础得不能再基础的东西。不过作为一个一点都不懂设计的开发人员，看完以后有一点点入门的感觉。我猜人家的受众也就是定义在刚毕业啥都不会的菜鸟设计师，作为一本教设计的书来说肯定不合格太简单了，但是对我倒是有点正合适。准备下回写APP的时候认真地按照书中讲的设计规范来做事，也算是没白看。</li>
<li><strong>金融的解释:金融学二十九讲</strong><br>这本书是早就定下的书单，跟着那本斯坦福极简经济学的，先读读经济原理，再搞清楚金融运作。它经常出现在各种推荐书单上，我原本抱有很大的期望，但也许是珠玉在前，一读之下，有点失望。此书的前面三分之一部分也是讲经济的，后面才引申到金融。跟极简经济学那本相比，明显少了一种脉络感，让人有种盲人摸象无法领悟整体的感觉。同样的内容，这本书就更像是拿教科书来扩充讲解一下，读完了还是有点模模糊糊无法抓住重点；而斯坦福极简经济学则会把经济学中各种概念的因果关系和相互影响的线索讲得很清晰，读完心中自成体系。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2017/02/28/ReadingList2017-02/</p><p>访问原文「<a href='http://conanwhf.coding.me/2017/02/28/ReadingList2017-02/'>读书清单 2017-02</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>所以不知道是金融的部分更难，还是确实作者功力有限，后面的金融学部分我读完了还是有点雾里看花的感觉。原本读这本书就是带有功利性的，想多了解一些金融的运作，对自己的投资行为有所帮助。可是读完了只是明白了那些概念是什么，而不明白那些变化是为什么；以我自己的功力，显然不足以自行推演出来。不明白为什么的话，又怎么能进行逻辑分析、指导实践呢？于是这本书完全变成了金融学科普，没有达到想象中的效果。</li>
<li><strong>几何天才的杰作:伊斯兰图案设计</strong><br>很薄的一本小册子，看中亚的评价都出乎意料地好，于是买了。这本书从最基本的五芒星、正方形、圆形等构件出发，利用各个形状的不同比例，通过各种重复、旋转、组合、扩充（不同图形的顶点相连）来变化出更多更复杂的图形。我一直很喜欢分形的东西，觉得那种无限延伸的秩序感很让人着迷，这本书中的很多图就让我可以发上好久的呆。原本以为这本书会比较偏数学，但其实只是由浅入深比较平实地罗列各种伊斯兰图案而已。让我感到震惊的是，书中讲到，每个图案都有它自己代表的意思，对应古兰经中的内容；甚至他们有一套使用阿拉伯数字以前的数字和符号系统，也能融入图案中去，一幅图可以表明古兰经中的某一章节！我看了那图，感觉前阵子《你一生的故事》中间外星人的文字也不过就是这样了……<br>书的最后还有一些实践性的内容，告诉你如何使用模板自己画一些相对简单的图案（其实也很复杂了）。刚好最近买了点磁力小短棒和钢珠在搭着玩，亲身体会到了书中说的那些奇妙的变换。关于等n边型的不同边长和角度的重复却神奇的变化，图形的世界真是令人着迷！</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选</li>
<li>知乎周刊</li>
<li>名侦探柯南漫画vol.928-985</li>
</ol>
<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2><ol>
<li>蒋勋说红楼梦</li>
<li>《经济学人》2016必读精选-当黑天鹅坐上无人车</li>
<li>大脑使用指南：其实你活在大脑创造的虚拟世界中</li>
</ol>
<h2 id="u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_43-96"><a href="#u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_43-96" class="headerlink" title="买的正版非免费书             43.96"></a>买的正版非免费书             <strong>43.96</strong></h2><ol>
<li>人类砍头小史                <strong>1.99</strong></li>
<li>第一推动丛书·宇宙系列（套装共6册，一套书读懂宇宙、黑洞与时空）                      <strong>12.99</strong></li>
<li>科学最前沿·第一辑 (《科学美国人》精选系列·科学最前沿)  <strong>15.99</strong></li>
<li>科学最前沿·第二辑 (《科学美国人》精选系列·科学最前沿)  <strong>12.99</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这个月过年，年后工作也来了。再加上我迷上了拼图，一下子买买买一大堆，很多业余时间都花在拼图上，花在读书上的时间就更少了。不过年后父母过来，帮我把新买的静境电子书也带来，大屏幕真的很爽！我一口气看完了去年一整年的柯南漫画，还不过瘾，想看《长歌行》硬是忍住了。现在可以直接带着去健身房看书了，不过只有椭圆机上OK，真正跑步的时候看时不时翻页需要稳定手指，严重扰乱呼吸节奏。所以现在都是带着iPad和静境去，有椭圆机就看书、没有就上跑步机看片😊 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>术与道:移动应用UI设计必修课</strong><br>家里人这次过来帮我带了不少实体书，这就是其中的一本，亚马逊双十一打折时候买的。整本书内容很少，图特别多，用零碎时间翻了两下就看完了。开始的时候，即使是小白如我也觉得作者在凑字数骗稿费，后来慢慢地看出一点点门道，关于APP设计的思维和规范，虽然书里真的没讲什么，都是基础得不能再基础的东西。不过作为一个一点都不懂设计的开发人员，看完以后有一点点入门的感觉。我猜人家的受众也就是定义在刚毕业啥都不会的菜鸟设计师，作为一本教设计的书来说肯定不合格太简单了，但是对我倒是有点正合适。准备下回写APP的时候认真地按照书中讲的设计规范来做事，也算是没白看。</li>
<li><strong>金融的解释:金融学二十九讲</strong><br>这本书是早就定下的书单，跟着那本斯坦福极简经济学的，先读读经济原理，再搞清楚金融运作。它经常出现在各种推荐书单上，我原本抱有很大的期望，但也许是珠玉在前，一读之下，有点失望。此书的前面三分之一部分也是讲经济的，后面才引申到金融。跟极简经济学那本相比，明显少了一种脉络感，让人有种盲人摸象无法领悟整体的感觉。同样的内容，这本书就更像是拿教科书来扩充讲解一下，读完了还是有点模模糊糊无法抓住重点；而斯坦福极简经济学则会把经济学中各种概念的因果关系和相互影响的线索讲得很清晰，读完心中自成体系。]]>
    
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.coding.me/tags/BookList/"/>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[静境电子书评测]]></title>
    <link href="http://conanwhf.coding.me/2017/02/12/JingJingTest/"/>
    <id>http://conanwhf.coding.me/2017/02/12/JingJingTest/</id>
    <published>2017-02-12T09:35:25.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6574_u4F53_u611F_u89C9"><a href="#u6574_u4F53_u611F_u89C9" class="headerlink" title="整体感觉"></a>整体感觉</h2><p>我已经有个KPW3，携带方便，其他方面都挺满意，就是觉得屏幕小了点。大屏电子书可选择的太少，我的要求一是要屏大，二是要能看的格式多（我对PDF要求并不多，我的书基本上以azw3&amp;mobi为主，少量epub&amp;pdf），三是不要太重（不能超过iPad），这三条综合下来就已经淘汰了大法、DXG，最终选了静境，带电磁书写款，总价2399。<br>整个静境电子书的大小比普通的教材书籍略小<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2017/02/12/JingJingTest/</p><p>访问原文「<a href='http://conanwhf.coding.me/2017/02/12/JingJingTest/'>静境电子书评测</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
（见图），重量和加了套的KPW3差不多，和KPW3一样，屏幕凹陷背壳采用塑料材质，但磨砂的手感很好，显得还挺有质感不廉价。标配一个电磁笔和皮套，电子书的身体上没有放笔的地方，略不方便，皮套倒是显得挺有档次。<br><img src="http://whf.d.pr/vvXb+" alt=""><br><img src="http://whf.d.pr/wDJU+" alt=""><br>机器9.7寸显示屏，内部存储12G，没有扩展卡，没有背光，支持WIFI和蓝牙，整个系统是采用的Android4.4，是厂家自己修改过的优化版系统，还自带一个应用商城，里面放的厂家优化过的一些APP，也支持自己另外装APP。从我的测试结果来看，普通的Android应用还是别想了，随便一点点刷新就能闪瞎。让我觉得有点不爽的是，通过USB连到电脑上，Mac居然看不见，我只好去开了Win10的虚拟机。</p>
<h2 id="u663E_u793A_u6548_u679C"><a href="#u663E_u793A_u6548_u679C" class="headerlink" title="显示效果"></a>显示效果</h2><p>电子书最重要的就是显示效果了，但是关于显示效果，在静境上有两种不同的显示模式：画质优先和速度优先。感觉上它们的区别一是16阶灰度和8阶（可能更低）灰度；一是画质优先时会每次都整屏强制刷新以消除残影，而速度优先的刷新频率不明。因为这个灰度的问题，在速度优先时简直无法使用普通的UI，特别是那些深色为底色的APP(比如Kindle)，不光书的封面图案难辨，甚至是白色图形的按键像是返回的箭头也看不见！<br>在看书的时候，画质优先和速度优先的模式，也会有一些不同。速度优先效果会差一点，字体边缘的颗粒感比较明显，而体现在字体放得比较小的时候就是某些细的笔划会消失；画质优先的显示效果好，但每次的强制刷新让人还是不舒服，我习惯了KPW3的人都难以适应。这两种模式的显示区别，我胡乱猜想一下大概就是KPW3和入门版Kindle的区别吧。下图是KPW3和静境的显示对比，因为静境没有背光，所以我也把Kindle的背光调整到0。<br><img src="http://whf.d.pr/aYMV+" alt=""><br>这是静境的画质优先模式，可以看到，字体的显示两者基本上是差不多的，但静境整体比较暗，估计傍晚看就得开灯了。我自己贴了个DXG的贴膜，但手残没贴好有气泡，各位看官忽略。另外强光下静境的反光比Kindle严重，不过两个设备我都是贴了磨砂膜，所以也不好说。<br>翻页速度方面，速度优先的模式下，静境和Kindle差不多。考虑到屏幕大小差很多，这也算不错了。而画质优先模式下就比较慢，同时点屏幕，Kindle已经翻完了静境才开始翻，然后又是一个同样的时间才翻完。而且翻页的时候强制刷新不知道是全黑了一下还是怎么，反正刷新的时候特别明显。以上这些测试是用的静境应用商城里的Kindle app，其他的应用效果可能略有不同。<br>另外速度模式因为不刷新，所以翻页多了之后会有很明显的重影，不过你可以手动按键刷新。下面的图是速度模式下的显示效果以及翻页4次以后的残影情况。<br><img src="http://whf.d.pr/IsKa+" alt=""><br>综上所述，我觉得这两种模式，看纯文字书的时候适合用速度优先模式，而普通的应用界面和看漫画适合用画质优先。幸好设备的三个按键中间有一个就是调整刷新的，长按就可以迅速切换。</p>
<h2 id="u6587_u4EF6_u652F_u6301"><a href="#u6587_u4EF6_u652F_u6301" class="headerlink" title="文件支持"></a>文件支持</h2><p>然后谈谈各种文件的支持。我把商城里面的几种阅读应用都下下来了，用几个漫画、不同的格式、几个大文件（400MB左右）、扫描版PDF等挨个测试了一遍：</p>
<ol>
<li>系统自带的阅读器：打开文件超级慢，经常死，好处是可以用电磁笔随时涂涂画画作笔记<ol>
<li>fbreader：支持azw3，太慢，容易死机，</li>
<li>koreader：我的漫画mobi和chm打开出错，不支持azw3，打开大文件慢但阅读速度不错，支持pdf切边重排</li>
<li>静读天下：UI不错，不支持azw3，不支持pdf重排，大文件打开快</li>
<li>alreader，支持azw3但不支持PDF，打开大文件速度比静读天下慢，但打开后反应流畅；看漫画自动缩放比例效果很好，无需特殊调整</li>
<li>福昕阅读器：专门阅读PDF，支持重排，打开文件快，也可以作笔记，但笔记反应比较慢<br>总的来说，最后我选择alreader作为主力，扫描PDF用福昕，还是足够解决各种需求的。以下是漫画、代码、英文等几种书的阅读实拍：<br><img src="http://whf.d.pr/yuJj+" alt=""><br><img src="http://whf.d.pr/ze4F+" alt=""><br><img src="http://whf.d.pr/VCOy+" alt=""><br><img src="http://whf.d.pr/ERMv+" alt=""><br><img src="http://whf.d.pr/kPMF+" alt=""></li>
</ol>
</li>
</ol>
<h2 id="u624B_u5199_u7B14"><a href="#u624B_u5199_u7B14" class="headerlink" title="手写笔"></a>手写笔</h2><p>静境配了一个电磁笔，支持电磁触控，号称能提供纸质一般的书写感。实际体验下来，主界面的便利贴和“草稿”应用都偶尔会被压在屏幕上的手掌干扰，但专门的笔记应用不会；书写感觉还是很流畅的，但不太跟笔，写得快了会有明显的时差；在PDF上写出那种像纸质书一样的笔记效果只有自带的阅读软件支持，虽然用起来还不错，但这个自带的阅读器开稍微大一点的文件就会死，打开文件也巨慢，所以普通小一点的文档还是没压力，书就还是算了。让我感到惊喜的是在笔记中笔另一端可以当橡皮擦用，很好玩。写的笔记会自动存成PNG图片，上一张我的测试图，字太丑请忽略：<br><img src="http://whf.d.pr/peSp+" alt=""><br>其实整个静境电子书的触摸反应不是特别灵敏，但对电磁笔的触控很灵敏，我现在已经习惯于左手拿书右手拿笔，感觉还不错。</p>
<h2 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h2><p>受到安卓系统的局限，整个静境的操作简直惨不忍睹。我的日常设备都是Apple系的，已经习惯了各种流畅不折腾的使用，就算我曾经是个Android系统开发人员，也花了很多时间才让它达到可以安安静静看书的状态。几乎每个应用都要做出相应的调整：关闭动画效果、改滑动为翻页、改控制、改背景为白色……即使折腾好了，也要忍受卡卡的界面和并不少见的失去响应。虽然我对大屏显示的书和漫画满心喜欢，也不能忽略这些读书之外难以忍受的操作。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>作为少有的大屏电子书，静境做到了基本的一点：读书。但我建议想下手的同学们，先考虑自己是否符合下面几条：</p>
<ol>
<li>常看漫画、PDF文档，或真的很喜欢用大屏看书，嫌Kindle太小</li>
<li>拥有Kindle，能客观认识到墨水屏的种种局限性，并对此有足够的心理准备</li>
<li>对看书这件事很热爱，对看书以外的事有耐心（针对卡卡的系统和App）</li>
<li>不差这两千来块钱<br>都满足的话，勇敢下手吧！大屏看书看漫画真的很爽哒！</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6574_u4F53_u611F_u89C9"><a href="#u6574_u4F53_u611F_u89C9" class="headerlink" title="整体感觉"></a>整体感觉</h2><p>我已经有个KPW3，携带方便，其他方面都挺满意，就是觉得屏幕小了点。大屏电子书可选择的太少，我的要求一是要屏大，二是要能看的格式多（我对PDF要求并不多，我的书基本上以azw3&amp;mobi为主，少量epub&amp;pdf），三是不要太重（不能超过iPad），这三条综合下来就已经淘汰了大法、DXG，最终选了静境，带电磁书写款，总价2399。<br>整个静境电子书的大小比普通的教材书籍略小]]>
    
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2017-01]]></title>
    <link href="http://conanwhf.coding.me/2017/02/01/ReadingList2017-01/"/>
    <id>http://conanwhf.coding.me/2017/02/01/ReadingList2017-01/</id>
    <published>2017-02-01T09:36:54.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>黑客</strong><br>一本常常出现在IT人书单上的书，然而我却没有看完。从晶体管时代开始，讲述那些以改进系统为唯一目标的天才程序员的故事。也不能说不好看，作为技术人员来说，过去那些事还是挺有意思的，比如思考一下如何用蜂鸣器做出音乐效果而不只是节拍，或者考虑最初的三个CPU指令应该是哪些，要不就是想象怎么在一个资源少到极限的系统中做调试器……这让我每每翻开这本书就有一种很纠结的心情：一方面看得实在是太慢了，大部分地方读起来也挺无聊，感觉不知道啥时候才能看完；另一方面偶尔有点思维体操的惊喜感，又让人不是能那么决绝地放弃这本书。最后我在看到大约三分之一的地方还是半途而废了，确实书里讲的东西离现在太远了，描述也蛮枯燥的。剩下的三分之二我大略地翻了翻，然后看完了后记以及2010年kindle版上市时的后后记。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2017/02/01/ReadingList2017-01/</p><p>访问原文「<a href='http://conanwhf.coding.me/2017/02/01/ReadingList2017-01/'>读书清单 2017-01</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
第一代黑客们的人生目前基本上都已经定型并且分歧巨大，最关键的问题在于书中讲的：<em>“一方面，信息应该是昂贵的，因为它非常有价值。你在正确的地方得到正确的信息，就会改变你的人生。另一方面，信息应该是免费的，因为获得信息的成本不断地降低。这就是两者的矛盾所在。”</em></li>
<li><strong>上海秘境 (理想国)</strong><br>作为半个上海人，虽然对上海并不熟悉，但挺有兴趣。借来这本书随便看看，但真的就只能随便看看。讲了不少上海鲜为人知or广为人知，旅游团却绝不会到的地方，多数是近代历史遗迹。了解一下可以，但讲得实在没什么意思，所以看过之后也完全没有想去的欲望。</li>
<li><strong>数字游戏：关于足球，你全弄错了……吗？</strong><br>原来以为是一个讲足球比赛中的数学的书，例如概率论什么的，其实全是统计学。基本上就是各种统计结果，类似一场比赛进几个球，每进一个球能提高多少胜率之类的。我家某人作为一个球迷加数学学霸，都看不下去这本书，我就更是没什么兴趣了。</li>
<li><strong>技巧：如何用一年时间获得十年的经验</strong><br>这是一本渐入佳境的书。开始第一章，就是一个有点自大的IT从业者在絮叨自己或朋友的光辉史/奋斗史，看得我已经要放弃了；第二章，终于开始有点干货，讲作者自己到底是如何学习的，虽然也并不见得有多少技巧，无非是跳出舒适区、大量重复练习两条而已。读到一半，要不是看到两篇书评对此书推崇备至，我已经要删掉，并且决定如今类似知乎大神写的书，以后一概不看。最后想想，反正书也不厚，干脆看完。看到最后一页，感觉是：这就完了？有那么点点意思……书的后半截讲了很多并非实际操作反而可以称为鸡汤的东西，但我却觉得精华恰恰在鸡汤之中。其实他讲到的学习技巧和观点，跟我自己的感受和方法相当吻合，所以有一种“虽然你说得不错但我自己也知道”的感觉；反倒是到了后面，这种感觉变成了“虽然道理我都明白但你这么一说我更清晰自己该怎么做”。总结就是：将学习内容分解、大量但有乐趣的练习、抛开顾虑先去做、持续地做、长期保持哪怕微小的进步。<br>整本书大概是作者的Blog精选集，除去开始的部分不谈，后来讲的东西还是挺多干货的。只是通篇还是有难以掩饰的优越感和一点点的自负，不免让人反感。总之，勉强算瑕不掩瑜吧！<br>另：昨天才知道这个作者就是前段时间在SwfitCon闹出风波那位，这……说什么好呢？IT技术界的网红确实越来越多了啊！我想是因为行业整体上跟美国印度交流变多了，被他们传染了浮夸风吧。</li>
<li><strong>你一生的故事</strong><br>这本书绝对是之前错过的精品。因为电影《降临》上映，亚马逊给这书改了个名字大力推荐，我也就找来看看。特德·蒋的这本短篇集N年前就已经出版，作为当年科幻世界编辑部的狂热爱好者，我没有买的原因大概是因为觉得《巴比伦塔》并不算科幻吧，继而否定了作者的所有作品。其实《巴比伦塔》给我的震撼还是很大的，不然也不至于这么多年后一下子就能清晰地回忆起这个故事的几乎所有细节，只是那时候年纪小不够包容，对非科幻的内容不感兴趣。也幸好是这样，因为这本书里面的某些东西，真的需要一点阅历才能懂的。<br>我不太清楚我读的是哪个版本，里面的内容比四川科技出版社那一版要多几个故事，但又不是译林版。客观地说，这些故事的水平有点参差不齐，也并不都是科幻小说，但这一点都没有影响我对作者的评价。看得出来作者是个很聪明的人，在《领悟》里面把高智商的感觉形容得相当贴切（不要脸的说我略微能体会到一点）；绝对的理科生，很多技术上的point信手拈来，绝不是硬拗出来的；对人性的领悟很深，能够合理塑造人物形象；最最重要的一点，也是很多科幻作者做不到因而显得故事相当单薄的原因，就是描述和洞察人类社会性的功底相当深厚。<br>这一点在《赏心悦目—审美干扰镜》中表现得尤其明显。干扰镜的设定只是一个科幻背景，通篇围绕强制使用干扰镜的法令投票，轮流写出正反两方的表达，一步一步层层推进：从要不要使用干扰镜，到是否应该强制使用干扰镜，到长期使用干扰镜的效果和后果，到人性对外表的评估偏好，到人们对内在歧视产生的审视，到利益集团对政策的倾向性和隐形权利，然后加了个鸡腿—宣传对民意、对人思维的影响，以颠覆结果的神结尾结束。即使到了最后，小说也没有写明作者自己的想法，他只是诱导读者自己去思考，思考一个决策的方方面面。从常规的角度来说，这是一篇没有“中心思想”的小说，但在我心中，这毫无疑问是一篇比神作《你一生的故事》还要神作的神作，两者一是神在开创性的想法（文字能决定思维方式甚至感知到的物理系统），一是神在一般科幻没有的既合乎情理又引人思考的深刻逻辑。<br>另外作者的逻辑能力非常厉害，关于悖论和推导的游戏玩得得心应手，并且有足够的文字功底能表述清楚逻辑上很多复杂的东西，让人看了会心一笑。Ted从来不表明自己的立场，他只是慢慢地讲出背景，接着是背景下的推论，一面、两面，然后自然而然地导出了矛盾和冲突。我很喜欢这种建立在在天马行空基础之上的合情合理，令人耳目一新又倍感流畅。<br>话说这个“你一生的故事”改编成的电影，我还没有去看，但看评论是把作者最重要的核心思想整个拿掉了，而是变成了一个通过跟外星人接触获得感知未来的俗套故事。真是可惜！</li>
<li><strong>斯坦福极简经济学</strong>（推荐）<br>没什么可说的，入门经济学书籍，很棒，必看！整本书分成两部分：微观经济学和宏观经济学，0基础的人看望也能对整个经济学有大致的了解，也不厚很容易看，虽然基于美国国情但理论是相同的，对我很有启发。</li>
<li><strong>时寒冰说：未来二十年，经济大趋势（未来篇）</strong><br>最近人民币汇率波动太大，一直在思考怎样才能在目前的情况下做好投资，找来不少经济、货币政策方面的书学习。这本书我也没看全，先看了讲汇率的部分，然后把其他部分粗略读了一遍，再把《现实篇》大致翻翻就算完。时寒冰讲了那么多，来来回回围绕的就是一个观点：美国正在积蓄力量重新崛起，它是个以国家利益为最高核心的国家，所以会尽一切力量阻止中国经济的赶超。所有的一切问题都是中美对抗问题，都要归结到美国会如何做，中国如何应对上来。虽然这个观点我认为至少大背景是对的，但其实并没有他说的那么阴谋论。虽然整本书夸张了点，但感觉他讲的汇率部分不管是预测还是分析都挺对的。不过其他的部分看看就算，取其精华去其糟粕吧。<br>P.S.看完这书才发现，原来时寒冰前几年跟牛刀一起鼓吹房价崩盘论，这……让我该信他还是不信他呢？😏</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选</li>
<li>知乎周刊-知乎日报年度精选</li>
<li><strong>雪球专刊-人民币贬值怎么办？</strong>（推荐）<br>虽然是论坛发言选，但真的很多干货。通过读这本薄薄的册子，我一下子搞懂了汇率贬值、升值是怎么回事，有什么影响，为什么前几年要升值、为什么最近会贬值……小白入门必读！不过里面真正关于“怎么办”的应对之法，就还是只当参考文档看看吧。</li>
</ol>
<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2><ol>
<li>就业利息和货币通论</li>
<li>《经济学人》2016必读精选-当黑天鹅坐上无人车</li>
<li>大脑使用指南：其实你活在大脑创造的虚拟世界中</li>
<li>蒋勋说红楼梦</li>
</ol>
<h2 id="u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_233-65"><a href="#u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_233-65" class="headerlink" title="买的正版非免费书             233.65"></a>买的正版非免费书             <strong>233.65</strong></h2><ol>
<li>有趣的世界（图灵新知11册）                    <strong>24.99</strong></li>
<li>白先勇作品集(套装共5册)                      <strong>10.95</strong></li>
<li>六堂课，解读开创性经济学理论 (《经济学人》选辑)   <strong>4.79</strong></li>
<li>全球悬疑大师典藏合集·共15册                    <strong>9.99</strong></li>
<li>思享家丛书:1+12:通向常识的道路+正义的可能+亦摇亦点头+大先生(套装共4册)     <strong>4.99</strong></li>
<li>一本杂志和一个时代的体温:《新周刊》二十年精选(套装上中下册)    <strong>19.99</strong></li>
<li>新东方·英语语法新思维:初级教程+中级教程+高级教程(套装共3册)   <strong>14.99</strong></li>
<li>万物简史+趣味生活简史                         <strong>19.99</strong></li>
<li>￼科学元典全集                                 <strong>99.99</strong></li>
<li>吃货的生物学修养                              <strong>7.99</strong></li>
<li>探索生命系列：缤纷的生命+生命的未来（共2册）      <strong>14.99</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>   本月过年，于是依然很多折扣出现，于是依然没能收手……那套《科学元典》说实话我就没打算看，收了镇宅😆这世上有意思值得读的书太多！好在这个月我还算读了点书，主要是经济形势扑朔迷离，自己对投资方向已经完全没了想法，只好努力补补课。书到用时方恨少啊！每每想好好分析一下经济形势，都觉得黑天鹅太多、自己的知识太少、看不清未来的样子。这个月零零散散读了点经济类的杂志、文章和书，至少搞清楚了汇率波动是怎么回事、汇率的改变压力来自于哪里，心里也慢慢有了一点底，不那么无措了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>黑客</strong><br>一本常常出现在IT人书单上的书，然而我却没有看完。从晶体管时代开始，讲述那些以改进系统为唯一目标的天才程序员的故事。也不能说不好看，作为技术人员来说，过去那些事还是挺有意思的，比如思考一下如何用蜂鸣器做出音乐效果而不只是节拍，或者考虑最初的三个CPU指令应该是哪些，要不就是想象怎么在一个资源少到极限的系统中做调试器……这让我每每翻开这本书就有一种很纠结的心情：一方面看得实在是太慢了，大部分地方读起来也挺无聊，感觉不知道啥时候才能看完；另一方面偶尔有点思维体操的惊喜感，又让人不是能那么决绝地放弃这本书。最后我在看到大约三分之一的地方还是半途而废了，确实书里讲的东西离现在太远了，描述也蛮枯燥的。剩下的三分之二我大略地翻了翻，然后看完了后记以及2010年kindle版上市时的后后记。]]>
    
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.coding.me/tags/BookList/"/>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2016-12]]></title>
    <link href="http://conanwhf.coding.me/2016/12/31/ReadingList2016-12/"/>
    <id>http://conanwhf.coding.me/2016/12/31/ReadingList2016-12/</id>
    <published>2016-12-31T07:26:54.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u8BFB_u4E66_u6E05_u53552016-02"><a href="#u8BFB_u4E66_u6E05_u53552016-02" class="headerlink" title="读书清单2016-02"></a>读书清单2016-02</h1><h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><p><strong>极简投资</strong><br>小白入门书，不过里面讲的投资理念我觉得很好，确实适合懒人以及没投资天分的人，比如说我。后半部对万能险的推崇有做广告的嫌疑，毕竟是出自某商业刊物吧，目前来说万能险肯定是不适合了，P2P也很危险。不过无伤大雅，核心是理解极简投资是怎么一回事，而不是具体该投哪些项目。总结一下，极简投资的核心就是分散、中短期的投资方式。分散指的是将资金分散在几个尽量不相关的方向上（如股市龙头股、债市等），注意是方向，不是单一股票而是指数，这是为了均摊风险，东边不亮西边亮；中短期投资一般就是一年，为了减小市场和投资者心理波动所造成的损失，用长期收益抵消短期浮亏。从数学上来说，极简投资并不是最优投资方案，却是相对来说较安全且兼顾收益的稳健投资方案。 <a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/12/31/ReadingList2016-12/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/12/31/ReadingList2016-12/'>读书清单 2016-12</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</p>
</li>
<li><p><strong>跑步时该如何呼吸</strong><br>这本书整体看下来还是很有收获的，虽然讲得比较啰嗦，包括各种案例和人们的正面反馈，可以删掉。对我来说，只看关键点就是：<br>A). 跑步的强度可以用呼吸的频率来衡量，应该把对配速的关注转移到对呼吸上来；<br>B). 跑步时身体受到冲击最大的时候是落地且开始呼气的时候，跑者受伤多因为每次呼气都重复在同一侧落地时；<br>C). 韵律呼吸解决的就是上面的两个问题：用有规律且相对步数为单数的周期，平均分散左右两边的冲击，一个周期中呼气时间小于吸气时间，并保持可控的强度；<br>D). 具体到实践上，采取腹式呼吸，n步一吸/(n+1)步一呼的模式（n一般为2-4之间，n越小表示当前的跑步强度越大）<br>问题是理论清楚不代表能做到。实际上我是属于吸气短呼气长的人，操作起来特别别扭，因为往往一步的时间就把气吸到头了，呼气时又来不及把气吐完。正常情况下，就算是跑得最喘的时候，我呼气也要花3-4步的时间，而吸气一步之内就完成了。自己尝试了几次书中的方法，反而更容易岔气，也许要更长时间更多的练习才能熟练掌握吧。</p>
</li>
<li><p><strong>无价（洞悉大众心理玩转价格游戏经典版）</strong><br>这本书挺有意思，讲了很多价格心理学的实验，用来解释在经济生活中的各种现象，以及商家在定价时利用这种心理学现象玩的/可以玩的把戏。贯穿全书、至关重要的一个概念是“锚点”，也就是心理上对于事物价值判断的一个参照点。整本书围绕这个“锚点”，讲了很多心理如何被锚点影响的方式和特点，包括提价再打折、建立新的参照物、心理暗示、语言表述等等方式，来利用这个“锚点”最大限度地获取利益。简单地总结一下就是：<br>A). 锚点可以影响人们对价值的判断<br>B). 不论锚点如何离谱，人们总是会无意地将自己的价值判断靠向锚点<br>C). 锚点可以是直接或间接的参照物，也可以是暗示或者背景提示<br>D). 人们都有厌恶风险、厌恶损失的心理倾向，即使明知数学上两者价值相当<br>E). 人们的经济选择不完全依靠利益计算，有时也有道德判断的影响<br>F). 一些世俗偏好例如性别、肤色等也能影响人们在交互活动中的经济选择<br>G). 道德、世俗等的量化判断同样能够被锚点影响<br>H). 人们并不知道任何事物的真正价值，所有的判断依据都是来自于不同参照系中参照物的比较结果，这给我们利用锚点操纵价格甚至人心带来了基础<br>以上这些结论都来自于许多不同的经济学小实验，揭示出人是多么容易受到欺骗和操纵！在读这本书的过程中，我一边做出和实验中人们类似的选择并对结果表示认同，一边也在深深地汗颜心理学、行为学真的深刻地展示了包括我在内的全人类是多么的愚蠢……经济学上所谓的理性自然人现实中根本不可能存在，所以这个世界的经济才会这么难以预测吧！</p>
</li>
<li><p><strong>中产富裕阶层金融投资研究报告/中产富裕阶层收入信心研究报告 </strong><br>金融时报的两个个报告，很短，大致总结了一下中产阶级的投资状况。让我不解的是，这个“中产阶级富裕阶层”的标准也太低了，家庭年收入10W即可，就算放在二线，夫妻双方加起来月薪8K也绝对称不上富裕，刚够生活而已。我觉得，除去房贷车贷租房吃饭交通等固定支出，可支配收入在10W的，才能勉强称为“中产富裕阶层”……好在报告说年收入平均在36W，说明高收入家庭还是占了不小比例的，这才看下去。<br>就算如此，这点内容实在也谈不上“研究报告”，说是“抽样统计结果”比较合适。结合30元的售价，更是匪夷所思，如果不是Unlimited借阅，我肯定要退货。统计结果大概包括收入分布、风险偏好、投资项目偏好、实际投资收益分布、2015股灾对收益的影响等；收入信心报告则是对下年收入增长预期不同的人群描像，类似预计收入增长10%以内的人年龄分布之类，比较简单，价值不大。</p>
</li>
<li><p><strong>中国休闲旅行需求研究报告</strong><br>跟上面一样，简短的报告，对旅游需求人群的抽样调查，年龄层次、受教育程度、目的地偏好、消费数额等做了个统计，没什么干货。</p>
</li>
<li><p><strong>富爸爸房地产投资指南</strong><br>富爸爸这一个系列实在是太多了，看着就像来圈钱的。不过实际看下来，这本书并不差，作者是真的有心得。当然美国的房地产市场跟中国的完全不同，要想从书中学到什么炒房的实战技能，首先你得是一个对国内市场相当了解的人。 整个书的核心思想就是寻找被低估的物业->使其增值->获得收益，作者更关注的是出租所带来的现金流而不是房产升值的差价，这和国内通常的炒房客在理念上就有所不同。不过书里面关于如何选择和评估物业的部分还是有很多可以借鉴的地方，花点时间看看并不亏。有意思的是，这本书最后挺长的篇幅是来自于刚当选的美国总统特朗普和他的两个儿子，写这书的时候应该是以地产大亨的身份吧。</p>
</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选</li>
<li>知乎周刊2015年度300问-经济</li>
<li>知乎周刊-减脂吃什么</li>
<li>知乎周刊-XXOO那些事</li>
</ol>
<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2><ol>
<li>黑客</li>
</ol>
<h2 id="u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0808-12_u6708_uFF09__uFF08390-03_uFF09"><a href="#u4E70_u7684_u6B63_u7248_u975E_u514D_u8D39_u4E66_uFF0808-12_u6708_uFF09__uFF08390-03_uFF09" class="headerlink" title="买的正版非免费书（08-12月）             （390.03）"></a>买的正版非免费书（08-12月）             （<strong>390.03</strong>）</h2><h3 id="u4E2D_u4E9A__uFF08270-05_uFF09"><a href="#u4E2D_u4E9A__uFF08270-05_uFF09" class="headerlink" title="中亚        （270.05）"></a>中亚        （<strong>270.05</strong>）</h3><ol>
<li>知识青年进阶：从有趣到有料再到变厉害（全15册） (果壳·十五言系列)    <strong>7.99</strong></li>
<li>牛津通识读本精选集（中文版 套装58册）          <strong>49.99</strong></li>
<li>哈佛百年经典(01-38卷)(套装共38册)            <strong>19.99</strong></li>
<li>OpenCV图像处理 (华章程序员书库)              <strong>9.99</strong></li>
<li>自己动手构造编译系统：编译、汇编与链接 (自己动手系列)  <strong>6.99</strong></li>
<li>白话大数据与机器学习                         <strong>9.99</strong></li>
<li>Swift编程实战：iOS应用开发实例及完整解决方案    <strong>12.99</strong></li>
<li>传记文学书系：从晚清到民国+我们的朋友胡适之+民国三大校长+再见大师(套装共4册) <strong>9.99</strong></li>
<li>诺贝尔经济学奖获得者丛书·经典必读（套装共5册）    <strong>14.99</strong></li>
<li>我所理解的Cocos2d-x                         <strong>23.99</strong></li>
<li>大脑认知系列共9册（《贪婪的大脑》）、《重塑大脑》、《意识与脑》、《上脑与下脑》等） <strong>19.99</strong></li>
<li>文学回忆录                                  <strong>0.10</strong></li>
<li>虫：2.5次世界大战（科幻文学“银河奖”获奖作品系列） <strong>0.10</strong></li>
<li>Xcode江湖录 (iOS/苹果技术丛书)               <strong>12.99</strong></li>
<li>Kali Linux高级渗透测试 (信息安全技术丛书)      <strong>9.99</strong></li>
<li>编程珠玑（第2版·修订版）                      <strong>12.99</strong></li>
<li>编程珠玑（续）（修订版）                      <strong>11.99</strong></li>
<li>健身达人一本通                              <strong>19.99</strong></li>
<li>全球证券投资经典译丛(共16卷)                  <strong>12.99</strong></li>
<li>爆品战略：39个超级爆品案例的故事、逻辑与方法     <strong>1.00</strong></li>
<li>丝绸之路：一部全新的世界史                    <strong>1.00</strong><h3 id="u56FE_u7075__uFF08119-98_uFF09"><a href="#u56FE_u7075__uFF08119-98_uFF09" class="headerlink" title="图灵      （119.98）"></a>图灵      （<strong>119.98</strong>）</h3></li>
<li>代码本色：用编程模拟自然系统 <strong>25.00</strong></li>
<li>黑客攻防技术宝典：浏览器实战篇 <strong>55.00</strong></li>
<li>垃圾回收的算法与实现 <strong>24.99</strong></li>
<li>Python数据挖掘入门与实践  <strong>14.99</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>回国一趟几个月，很久没有读书。但双十一、双十二剁了不少。已经买了太多太多的书，这辈子也读不完，加上亚马逊的unlimited包年……以后慎买！算一算整年包括实体书，我花了大概1000+，买到的书嘛……实体书大概15-20本，电子书就实在太多懒得算。其实这么看看电子书真的很便宜，如果我小时候有中亚、有kindle，估计我会瞎吧😆看人家写改革开放前的故事，好多爱书之人都是拿出工资的一半来买书，我曾经也暗暗下决心将来工作了要这样，结果可想而知。并且国内的书真的是很便宜，我看到好多专业书甚至翻译版比原版还便宜！书是越来越便宜了，看书的人却越来越少了。不过在新加坡看书的人还挺多，不管是书店还是图书馆都常常人满为患。书店的书，那价格才是让人望而却步，随便一本专业书能抵我这一年的买书钱。更麻烦的是绝大部分书都是英文的，中文以港台版为主😂我还是好好守着我的中亚吧！😁</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u8BFB_u4E66_u6E05_u53552016-02"><a href="#u8BFB_u4E66_u6E05_u53552016-02" class="headerlink" title="读书清单2016-02"></a>读书清单2016-02</h1><h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><p><strong>极简投资</strong><br>小白入门书，不过里面讲的投资理念我觉得很好，确实适合懒人以及没投资天分的人，比如说我。后半部对万能险的推崇有做广告的嫌疑，毕竟是出自某商业刊物吧，目前来说万能险肯定是不适合了，P2P也很危险。不过无伤大雅，核心是理解极简投资是怎么一回事，而不是具体该投哪些项目。总结一下，极简投资的核心就是分散、中短期的投资方式。分散指的是将资金分散在几个尽量不相关的方向上（如股市龙头股、债市等），注意是方向，不是单一股票而是指数，这是为了均摊风险，东边不亮西边亮；中短期投资一般就是一年，为了减小市场和投资者心理波动所造成的损失，用长期收益抵消短期浮亏。从数学上来说，极简投资并不是最优投资方案，却是相对来说较安全且兼顾收益的稳健投资方案。]]>
    
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.coding.me/tags/BookList/"/>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年08月]]></title>
    <link href="http://conanwhf.coding.me/2016/08/31/Tips201608/"/>
    <id>http://conanwhf.coding.me/2016/08/31/Tips201608/</id>
    <published>2016-08-31T09:25:39.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>不管你在哪个线程注册了 observer，notification 在哪个线程 post，那么它就将在哪个线程接收</li>
<li>数据缓存方式选择:<ol>
<li>fmdata数据库(增删改查)   –数据需要:增删改查</li>
<li>coreData                –数据需要:增删改查</li>
<li>序列化(NSUserDefault)    –状态、偏好设置、默认选项</li>
<li>单独.plist               –列表数据,城市信息等</li>
<li>单独.json文件           –页面列表数据</li>
<li>realm框架(增删改查)       –数据需要:增删改查</li>
</ol>
</li>
<li>清除签名文件 删除签名文件 清理Profile文件：Xcode - Preferences - Account - View Details,这个时候左下角有个刷新图标，点击一下就可以了</li>
<li>TableView头视图不随视图移动，头视图出现错位的错误原因：tableView的 UITableViewStyle 没有明确的声明。解决方法：在tableView声明的时候明确为 UITableViewStyleGrouped</li>
<li>ViewController生命周期：<br>  alloc -> initWithNibName -> loadView -> viewDidLoad -> viewWillAppear -> viewDidAppear -> viewWillDisappear -> viewDidDisappear -> dealloc<br>  注意1. 不要在loadView中调用父类方法<a href="/">super loadView</a>，因为这会影响CPU性能。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/08/31/Tips201608/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/08/31/Tips201608/'>开发Tips收集-2016年08月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br>  注意2. 切换前后台不会调用viewWillAppear</li>
<li>关于数据存储需要注意的点，总结在下面：<ol>
<li>关键数据<br>内容：用户创建的数据文件，无法在删除后自动重新创建<br>路径：主目录/Documents<br>管理：iOS系统即时遇到存储空间不足的情况下，也不会清除，同时会备份到iTunes或iCloud中</li>
<li>缓存数据<br>内容：可用于离线环境，可被重复下载重复生成，即使在离线时缺失，应用本身也可以正常运行<br>路径：主目录/Library/Caches<br>管理：在存储空间不足的情况下，会清空， 并且不会被自动备份到iTunes和iCloud中</li>
<li>临时数据<br>内容：应用运行时，为完成某个内部操作临时生成的文件<br>路径：主目录/tmp<br>管理：随时可能被iOS系统清除，且不会自动备份到iTunes和iCloud，尽量在文件不再使用时，应用自己清空，避免对用户设备空间的浪费</li>
<li>离线数据<br>内容：与缓存数据类似，可以被重新下载和重建，但是用户往往希望这些数据即使在存储紧张时也不会被系统自动删除<br>目录：主目录/Documents  或 主目录/Library/自定义的文件夹<br>管理：与关键数据类似，即使在存储空间不足的情况下也不会被清除，应用自己应该清除已经不再使用的文件，以免浪费用户设备空间 。需要设置”不备份到iCoud” ，否则会审核不过。</li>
</ol>
</li>
<li>App 的沙盒文件目录可以以 NSURL 的形式返回：<br>  <code>let documentURL = NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask).first</code></li>
<li>cell被重用如何提前知道? 重写cell的prepareForReuse 官方头文件中有说明.当前已经被分配的cell如果被重用了(通常是滚动出屏幕外了),会调用cell的prepareForReuse通知cell.注意这里重写方法的时候,注意一定要调用父类方法<a href="/">super prepareForReuse</a> .这个在使用cell作为网络访问的代理容器时尤其要注意,需要在这里通知取消掉前一次网络请求.不要再给这个cell发数据了.</li>
<li>addObserverForName监听消息处理跟addObserver的差别：addObserver的四个参数分别指定了通知的观察者、处理通知的回调、通知名及通知的发送对象；而addObserverForName同样是监听消息处理，只是它并没有观察者，却多出一个队列跟一个block的处理；addObserverForName参数说明，name和obj为nil时的情形与前面一个方法addObserver是相同的。如果queue为nil，则消息是默认在post线程中同步处理，即通知的post与转发是在同一线程中；但如果我们指定了操作队列，情况就变得有点意思了，我们一会再讲。block块会被通知中心拷贝一份(执行copy操作)，以在堆中维护一个block对象，直到观察者被从通知中心中移除。所以，应该特别注意在block中使用外部对象，避免出现对象的循环引用。如果一个给定的通知触发了多个观察者的block操作，则这些操作会在各自的Operation Queue中被并发执行。所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。该方法会返回一个表示观察者的对象，记得在不用时释放这个对象。</li>
<li>在iOS7之后，默认情况下，状态栏都是由UIViewController管理的，若想通过UIApplication进行管理，则需要配置plist文件:View controller-based status bar appearance 设置成NO (默认值为YES)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>不管你在哪个线程注册了 observer，notification 在哪个线程 post，那么它就将在哪个线程接收</li>
<li>数据缓存方式选择:<ol>
<li>fmdata数据库(增删改查)   –数据需要:增删改查</li>
<li>coreData                –数据需要:增删改查</li>
<li>序列化(NSUserDefault)    –状态、偏好设置、默认选项</li>
<li>单独.plist               –列表数据,城市信息等</li>
<li>单独.json文件           –页面列表数据</li>
<li>realm框架(增删改查)       –数据需要:增删改查</li>
</ol>
</li>
<li>清除签名文件 删除签名文件 清理Profile文件：Xcode - Preferences - Account - View Details,这个时候左下角有个刷新图标，点击一下就可以了</li>
<li>TableView头视图不随视图移动，头视图出现错位的错误原因：tableView的 UITableViewStyle 没有明确的声明。解决方法：在tableView声明的时候明确为 UITableViewStyleGrouped</li>
<li>ViewController生命周期：<br>  alloc -> initWithNibName -> loadView -> viewDidLoad -> viewWillAppear -> viewDidAppear -> viewWillDisappear -> viewDidDisappear -> dealloc<br>  注意1. 不要在loadView中调用父类方法<a href="/">super loadView</a>，因为这会影响CPU性能。]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详细梳理分区表和系统启动相关的各种概念]]></title>
    <link href="http://conanwhf.coding.me/2016/08/26/GPTandMBR/"/>
    <id>http://conanwhf.coding.me/2016/08/26/GPTandMBR/</id>
    <published>2016-08-26T09:30:25.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<p>MacBookPro的硬盘太小，前几天买了个128G的U盘想装好系统在虚拟机里引导，以节省日益膨胀的虚拟机文件占用的空间。我同时需要Mac、Win、Linux，买不起大容量MBP，天天寻思着删东西，实在是伤不起啊！😭预设的目标是要把Win和Ubuntu都装U盘上，而且支持在我的旧笔记本、Mac、虚拟机里都能正确引导，同时还要有一个数据分区，能在所有的系统中正常识别为U盘。为此，我狠狠研究了一通分区表，被各种缩写和规则搞得头昏脑胀。看看网上的东西也是常有错误，趁着还没忘光，自己梳理一遍吧！<br>声明：本文为作者（<a href="https://github.com/conanwhf" target="_blank" rel="external">Conan</a>）原创，转载请标明<a href="/conanwhf.github.io">出处</a>！</p>
<h2 id="GPT_u548CMBR"><a href="#GPT_u548CMBR" class="headerlink" title="GPT和MBR"></a>GPT和MBR</h2><p>首先当然是这俩，一切都源于此。最重要的信息是：他们都是<strong>分区表</strong>，一种用来表示硬盘分区信息的格式，不太严格地说是一个<strong>软件概念</strong>。啰嗦一句分区表是干什么的：在操作系统启动之前、硬件初始化之后，确定从硬盘启动的话，需要获得硬盘分区的基本信息，那就需要分区表了。分区表不只包含硬盘的分区信息，也包括一个很小的最基本的引导程序，用到引导第二阶段引导程序，如NTLDR、BOOTMGR和GRUB等，这些第二阶段的引导程序，是需要针对每个分区进一步读取数据才能获得的。</p>
<h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><p>全称<strong>主引导记录（Master Boot Record）</strong>，又叫做主引导扇区，位于硬盘的第一个扇区主要分为两个部分：引导程序和分区结构表。有时候也将其开头的446字节引导程序特指为MBR，其后是64字节的“磁盘分区表”（DPT），以及2字节的结束标志（55AA）。因此，在使用“主引导记<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/08/26/GPTandMBR/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/08/26/GPTandMBR/'>详细梳理分区表和系统启动相关的各种概念</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
录”（MBR）这个术语的时候，需要根据具体情况判断其到底是指整个主引导扇区，还是主引导扇区的前446字节。通常地相对于GPT来讨论MBR，则就是指这种分区模式的整套标准。<br>在这种模式下，描述分区的部分占64个字节，分别是对四个分区的信息进行描述，其中每个分区的信息占据16个字节（当然小于4个分区也可以），这也就是说MBR分区表最多只能有4个主分区或者3个主分区+1个扩展分区的由来。<br>具体分区信息的标准就不多说了，在每个分区信息的16字节中，分别有4个字节是表示分区的扇区起始号和扇区数目，它们的最大值是2^32-1。而通常来说一个扇区的大小为512byte，所以MBR能支持的最大硬盘（取决于扇区起始offset）大小是2^41byte，也就是2TB(按1024算)，或者说是2.2TB(按硬盘厂商的1000算)😶，亦即”MBR不支持3T大硬盘”（因为人家可以支持2T嘛）！<br>当年这个硬件限制出现的时候，有的厂商为了解决这个问题，另辟蹊径，通过提高每个扇区的大小来支持更大容量的硬盘。例如将扇区从512byte升级到2K，那么MBR就可以支持8T的硬盘了。但这种方法在扇区普遍为512B的市场上，反而出现了很多麻烦……后来，GPT出现了。</p>
<h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><p>GPT的全称是：<strong>全局唯一标识分区表（GUID Partition Table)</strong>，是用来取代MBR的新一代分区表格式。它的具体结构定义比较复杂，我就不多赘述了。相对MBR来说，GPT的信息量更大，表本身所占用的size也大得多。不同于MBR的使用偏移量来标识不同分区，GPT中每个分区都有一个唯一标识GUID作为关键字。<br>GPT表分为表头和n个表项两个部分，顾名思义，表头存储了一些总体上的信息，例如版本、校验、表项数目等；而每个表项就是每个分区的具体描述。在Windows里，使用GPT的硬盘最多可以有128个分区，但这<strong>不是GPT标准规定</strong>，只是因为Windows给分区表预留的大小只够放128个分区罢了（将来会改也说不定哦）。在GPT的表头中，表项的数目占4个字节，所以理论上来说是可以有2^32个分区的。<br>在每个表项中，用来记录分区起始和结束位置的信息扩展成了8字节，也就是最大能表示2^64的地址。不幸的是，这次它不是表示扇区号了，而是LBA(Logical Block Address,逻辑区块地址)；幸运的是，通常LBA的大小也是512Byte，不影响对这个问题的理解。LBA和扇区的区别，跟现代存储设备的发展有关，又是一个大长篇，不展开说了。总之，GPT分区表比MBR支持更多的分区、更大的分区、更大的物理硬盘。</p>
<h4 id="GUID__26amp_3B_UUID"><a href="#GUID__26amp_3B_UUID" class="headerlink" title="GUID &amp; UUID"></a>GUID &amp; UUID</h4><p>说到GPT，就不得不解释一下GUID是什么了。GUID的中文是<strong>全局唯一标识符(Global Unique Identifier)</strong>， 是一种由算法生成的唯一标识，总共有32个16进制数，即一个128位长的二进制整数。唯一标识，也就是说每个不同的分区都有自己的独一无二的GUID。从理论的角度看，GUID的生成并不是肯定没有重复的，只是概率非常非常小，小到在实际中可以忽略不计。例如在一个大的服务器集群里，都不会有重复的GUID。另外还有个UUID(Universally Unique Identifier，唯一识别码)，这是微软搞出来的，主要是对文档进行标识，跟GUID是一个意思，经常混用。<br>在很多描述系统启动、引导的文章或者是日常表述中，GPT和GUID是等价的（使用GUID来代替GPT）。阅读的时候概念清楚就行，别太较真。😄</p>
<h2 id="28U_29EFI__u548C__28Legacy_29_BIOS"><a href="#28U_29EFI__u548C__28Legacy_29_BIOS" class="headerlink" title="(U)EFI 和 (Legacy) BIOS"></a>(U)EFI 和 (Legacy) BIOS</h2><p>讲了半天，终于轮到EFI了。虽然EFI和GPT并不是一回事，但在很多的地方，都用EFI和GPT/GUID表达同一个意思，即EFI+GPT的启动方式。EFI实际上是一套包括软硬件的标准接口，但我们通常说的”主板支持EFI“是指的它的硬件部分，即主板符合EFI的标准。在这个维度意义上，和EFI相对的，则是从前广泛使用的Legacy BIOS标准（多数教程、文章将其直接写为BIOS，下同）。虽然他们都只是一种接口的定义，但再次不严格地说，我们大致可以将网络上多数文章、教程中的EFI和BIOS理解为一个<strong>硬件概念</strong>，即支持或不支持EFI的主板。可以说，EFI和传统BIOS的关系就如同GPT和MBR的关系，一代新人胜旧人。</p>
<h3 id="28U_29EFI"><a href="#28U_29EFI" class="headerlink" title="(U)EFI"></a>(U)EFI</h3><p>UEFI中文<strong>统一可扩展固件接口（Unified Extensible Firmware Interface）</strong>，它的前身是Intel在1998年开始开发的Intel Boot Initiative，后来被重命名为<strong>EFI（Extensible Firmware Interface, 可扩展固件接口）</strong>。Intel在2005年将其交由统一可扩展固件接口论坛（Unified EFI Forum）来推广与发展，为了凸显这一点，EFI也更名为UEFI。也就是说，UEFI和EFI是同一个东西，在本文全部写为EFI。<br>前面说了，EFI和GPT不是一回事，但他们其实是有从属关系的：GPT是EFI的一个组成部分。EFI的其他部分还包括初始化模块、驱动程序、执行环境、支持模块和应用等，可以说，EFI实际上是一个简单的小型操作系统。如果你了解过Linux中的Uboot，它和EFI在概念和流程上非常像。在一个EFI启动的系统中，上电后先执行初始化模块，然后加载各种基本的驱动，如果需要则读取一个特定的EFI系统分区，通过放在里面的引导文件启动系统。同时，EFI也包含一个是能够向下兼容BIOS的模块，用来引导传统的BIOS服务。<br>由于EFI是一整套接口定义，所以实际上完成一个完整的EFI启动需要硬件（通常指包含基本初始化模块的主板）、GPT分区表、EFI系统分区和操作系统几个部份的支持。虽然不大好理解，但本质上EFI规范与BIOS的区别是包含了主要的三个变化：</p>
<ol>
<li>能够读取GPT分区表。</li>
<li>能够执行特殊格式的代码。这种代码使用了C语言风格的参数堆栈传递方式，动态链接的形式构建，运行于32位或者64位模式，而不是BIOS中使用的16位基于中断的驱动程序。</li>
<li>支持从特定文件系统（EFI系统分区）中读取程序并加载运行。</li>
</ol>
<h4 id="EFI_u7CFB_u7EDF_u5206_u533A"><a href="#EFI_u7CFB_u7EDF_u5206_u533A" class="headerlink" title="EFI系统分区"></a>EFI系统分区</h4><p>说到EFI系统分区，又是一个新名词。其实<strong>EFI系统分区(也称为ESP或者EFISYS)是一个 FAT32 格式的物理分区</strong> (在硬盘主分区表上，而不是 LVM 或软件 RAID 等等)，它可以直接被EFI系统读取，但在一般情况下是一个隐藏分区，用来保存启动信息。想想Uboot，如果移植了Fat文件系统在Uboot里，它就可以读取SD卡中的kernel Image，是不是很像？同样的，在支持EFI的主板固件中也包含了FAT32的文件系统驱动，从而能够做到这一点。<br>在MacOS中，EFISYS（方便起见，后文均使用EFISYS表示）的大小固定为200MB，不可调整；在Windows中默认为100MB, 可以在装系统的时候修改。下图是我的Mac上的分区情况（空间真的少得可怜😭）：<br><img src="http://whf.d.pr/Zjzc+" alt=""><br>可以看到其中那个标记为”EFI“的分区就是了，平时你在磁盘管理中是看不到它的。但Linux与众不同，现在大多数的发行版都是把EFISYS直接挂载成boot分区，也就是可见的，Ubuntu, Debian, ArchLinux都是如此。<br>除了操作系统的引导文件，EFISYS也常常用来做多系统引导。因为EFI系统实际上是读一个程序并运行，那么其实可以做很多其他的事情，绝大多数多系统引导工具也都是基于这一点。例如比较出名的有变色龙、四叶草等，在各种黑苹果的安装教程中应用广泛，此处先按下不表。</p>
<h3 id="28Legacy_29_BIOS"><a href="#28Legacy_29_BIOS" class="headerlink" title="(Legacy) BIOS"></a>(Legacy) BIOS</h3><p>按顺序本来应该先说BIOS，但说了GPT不多讲讲EFI很多问题就解释不清了。BIOS其实大家都很熟悉，中文<strong> 基本输入输出系统（Basic Input/Output System）</strong>，在IBM兼容系统上，也是一种标准的固件接口。BIOS也没什么可多说的，从2012年起在PC市场逐渐被淘汰的老人家，但依然还是有很多老旧的发挥着余热的电脑在使用着它。<br>顺便说一下，曾经看到传说的一种分辨主板是否支持EFI的方法，就是看进入BIOS（此BIOS指按F2或什么别的进入的那个配置界面）以后鼠标能否使用、界面是否为带图片有UI的那种复杂界面而不是蓝白。这种判断方式当然不准确，但一定程度上说明了传统BIOS和EFI的区别：传统BIOS只能从ROM里load很小的一个程序，界面也都是用ASCII码组成的；而EFI可以支持FAT文件系统，也就有了更多的可能性和扩展性。</p>
<h2 id="u542F_u52A8_u5F15_u5BFC"><a href="#u542F_u52A8_u5F15_u5BFC" class="headerlink" title="启动引导"></a>启动引导</h2><p>理清楚概念，可以来聊聊启动引导的各种情况了。首先需要明确一个概念：BIOS的类型和分区表的格式是两个不同的概念，所以<strong>EFI和GPT并没有必然联系！</strong>事实上，EFI和MBR都有向下兼容的设计，而老版本的BIOS也并非不可能引导GPT（需要一些技巧）。下面来分别看看几种组合的情况。</p>
<h3 id="BIOS+MBR__26amp_3B_EFI+GPT"><a href="#BIOS+MBR__26amp_3B_EFI+GPT" class="headerlink" title="BIOS+MBR &amp; EFI+GPT"></a>BIOS+MBR &amp; EFI+GPT</h3><p>BIOS和MBR的组合历史悠久，是过去长期使用的方式，没什么好说的。而EFI+GPT的组合，则是两个新鲜事物，他们无疑也是匹配的。前面介绍的典型EFI启动过程，就是这种情况，目前市场的新电脑，也都是使用这种组合。</p>
<h3 id="EFI+MBR"><a href="#EFI+MBR" class="headerlink" title="EFI+MBR"></a>EFI+MBR</h3><p>EFI+MBR的启动靠的是EFI标准中<strong>CSM（Compatibility Support Module，兼容性支持模块）</strong>的作用，说白了就是把EFI假装成一个BIOS使用，也就是很多主板设置里面的兼容模式。这时候准确地说启动流程是跑在BIOS+MBR的模式，所以在这里所说的EFI+MBR指的是“支持EFI的主板在兼容模式下引导MBR”。</p>
<h3 id="BIOS+GPT"><a href="#BIOS+GPT" class="headerlink" title="BIOS+GPT"></a>BIOS+GPT</h3><p>这一部分才是真正复杂的地方。前面为了理解清晰并没有提到，GPT其实是完全向下兼容的，它兼容的方式是在表的最开头仍然存储了一份传统的MBR，给那些只支持MBR的设备/工具读取，这个MBR也叫做保护MBR。在一般情况下，为了防止不支持GPT的硬盘管理工具错误识别并破坏硬盘中的数据，在这个MBR中，只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表。不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作，除非用户特别要求删除这个分区。这就避免了意外删除分区的危险。另外，能够识别GPT分区表的操作系统会检查保护MBR中的分区表，如果分区类型不是0xEE或者MBR分区表中有多个项，也会拒绝对硬盘进行操作。我在自己的Mac上验证了一下，能看到fdisk所看到的分区如下：<br><img src="http://whf.d.pr/17j1L+" alt=""><br>这种情况下，BIOS自然无法引导系统，因为它看到的是一个整无法识别的分区。而要想让BIOS能够引导GPT分区的硬盘，方法自然也就跟EFI+MBR类似：让GPT装作自己是MBR。为了做到这一点，GPT支持一种叫“Hybrid MBR”的混合分区表模式。</p>
<h4 id="u6DF7_u5408_u5206_u533A_u8868Hybrid_MBR"><a href="#u6DF7_u5408_u5206_u533A_u8868Hybrid_MBR" class="headerlink" title="混合分区表Hybrid MBR"></a>混合分区表Hybrid MBR</h4><p>所谓的混合分区表，关键就在于GPT在表头存储的那份传统MBR。这个MBR存储了GPT分区表的一部分分区（通常是前四个分区），可以使不支持从GPT启动的操作系统从这个MBR启动，启动后只能操作MBR分区表中的分区。在传统BIOS看来，它是一个普通的MBR硬盘；而在EFI或者支持GPT的工具看来，它又是一个使用了GPT的硬盘。它的主体仍然是GPT分区表，只不过是将一般标记全硬盘为未知分区的MBR，改为正常的MBR信息，用以欺骗BIOS和操作系统。我将普通GPT在不同情况下的识别情况画了个图：<br><img src="http://whf.d.pr/15Nup+" alt=""><br>可以看到，一个包含n个分区的GPT硬盘（指使用GPT来存储分区情况的硬盘），如果不使用混合分区表的特殊处理，则会被只支持MBR的工具/设备认为是无法使用的。而对于混合分区表，它们则能够认出来一部分分区，和一个未知的分区。在启动时，如果混合分区表中被认出来的分区有可启动的系统，则也能顺利的引导，这就是传说中的BIOS+GPT模式，Apple那个“神奇”的Bootcamp也是基于这个原理。</p>
<h4 id="u624B_u52A8_u5236_u4F5C_u6DF7_u5408_u5206_u533A_u8868"><a href="#u624B_u52A8_u5236_u4F5C_u6DF7_u5408_u5206_u533A_u8868" class="headerlink" title="手动制作混合分区表"></a>手动制作混合分区表</h4><p>混合分区表的应用虽然广泛，但除了Bootcamp还真没有好的制作工具，一般是手动使用gdisk（跟fdisk类似的linux tool）制作。gdisk的基本操作跟fdisk基本一样，p是打印各个分区，d是删除，n是新建。为了测试需要，我在一个普通U盘使用gdisk分了几个不同类型的分区，下图是我用gdisk查看的情况：<br><img src="http://whf.d.pr/1eF2X+" alt=""><br>这是一种默认的情况，即GPT表中的MBR部分写为保护分区。然后输入r进入高级回复（Recovery/transformation）模式，按?可以看到命令菜单。我们输入h来制作混合分区表（make hybrid MBR）。程序会问你选择哪些分区加入MBR分区表？在这里输入分区的序列号即可，用空格分开，最多输入4个。如果不足4个，会问你是否要把未分区部分标记成成0XEE也就是未知分区。然后就是依次设置每个分区，包括启动分区和分区类型的设置。<br><img src="http://whf.d.pr/179WR+" alt=""><br>完成以后，输入o来查看混合分区的情况，输入w将修改写入分区表。<br><img src="http://whf.d.pr/VVcL+" alt=""><br>设置中我输入的是2 3 6三个分区，并且同意将第一个分区做成未知分区。可以看到，对比GPT表的分区，没有被加入的分区就跳过了，不会在MBR表中被显示出来。这时候再次使用gdisk读取磁盘，能看到MBR的状态从<strong>protective</strong>变成了<strong>hybrid</strong>：</p>
<blockquote>
<p>Partition table scan:<br>  <strong>MBR: hybrid</strong><br>  BSD: not present<br>  APM: not present<br>  GPT: present</p>
</blockquote>
<p>为了验证成果，把U盘拿到Windows的磁盘管理中查看：<br><img src="http://whf.d.pr/16mbX+" alt=""><br>可以看到4可用分区，以及一部分的未分配空间，即被我跳过的4，5分区。如果这几个分区中有安装Windows系统且标记为活动的分区，则可以启动Windows。</p>
<h2 id="u591A_u64CD_u4F5C_u7CFB_u7EDF_u5F15_u5BFC"><a href="#u591A_u64CD_u4F5C_u7CFB_u7EDF_u5F15_u5BFC" class="headerlink" title="多操作系统引导"></a>多操作系统引导</h2><p>一般情况下，一台电脑只需要装一个系统，根据自己的主板，该MBR的MBR，该GPT的GPT，没有什么问题；如果有多操作系统的需求，普通的安装盘例如Windows、Ubuntu也都支持。所以正常来说，多操作系统和MBR、GPT这些没啥关系，可架不住有的人、有的公司爱折腾啊！需要了解这些机制的情况，一种是牵涉到Apple的MacOS，什么黑苹果、Mac上装Windows；另一种是制作可携带的U盘上的操作系统并要求能兼容各种硬件（就是我了）。废话不多说，下面简单聊一下多操作系统的引导，才疏学浅时间有限，并没有全部实践过一遍，以原理为主，力求不纸上谈兵误导观众。</p>
<h3 id="u542F_u52A8_u5668"><a href="#u542F_u52A8_u5668" class="headerlink" title="启动器"></a>启动器</h3><p>多操作系统绕不开启动器。顾名思义，启动器是系统启动用的工具，在BIOS/EFI读取磁盘信息后，往往不是直接进入操作系统，而是运行一个启动器，再由启动器引导真正的操作系统。即使在单操作系统中，你也一定见识过启动器的存在，比如Linux用户开机后的图形or命令行的选择，或者Windows用户强制关机后出现的修复菜单，至于Mac？按住option开机试试看。😄Linux系列常用的启动器是GRUB，而盗版启动光盘、修电脑小哥常用启动器则有cover四叶草和变色龙。启动器本身是一个比较宽泛的概念，有的只有引导作用，有的甚至集成了一些常用的驱动程序和工具。具体不同的启动器就不展开说了，大工程，总之，启动器是操作系统和BIOS/EFI之间的桥梁。</p>
<h3 id="u64CD_u4F5C_u7CFB_u7EDF_u5BF9EFI_u7684_u652F_u6301_u60C5_u51B5"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u5BF9EFI_u7684_u652F_u6301_u60C5_u51B5" class="headerlink" title="操作系统对EFI的支持情况"></a>操作系统对EFI的支持情况</h3><p>回到EFI死磕。前面说了，EFI是一套标准，那么其实跟操作系统也有关。贴一下Wiki上的操作系统支持列表：<br><img src="http://whf.d.pr/SthO+" alt=""><br><img src="http://whf.d.pr/njSJ+" alt=""><br><img src="http://whf.d.pr/G6dc+" alt=""><br>那些“自EFI/GPT启动”启动的，才是我们平常说的“支持EFI”或者“支持GPT”的系统。很明显，Linux是最开放的，MacOS因为几乎没有重装系统的问题自成一派，而Windows……呵呵哒🙄这种混乱造就了一大波折腾爱好者们在各种论坛上的各种安装教程，把我看得也是脑子跟着混乱了。</p>
<h3 id="BootCamp"><a href="#BootCamp" class="headerlink" title="BootCamp"></a>BootCamp</h3><p>BootCamp是Apple出品的在Mac上安装Window的工具，看到这里，聪明的小伙伴应该已经猜到BootCamp所使用的原理了，对，就是混合分区表。事实上，BootCamp不只是分区工具、引导器，它还是一整套软硬件的支持系统，例如还有输入输出设备的支持等等（Mac键盘布局跟Win不一样）。<br>关于BootCamp的启动模式，威锋上有一篇帖子写得很详细，有兴趣可以研究一下，感觉他写得比我好多了，这部份我也就不献丑了。<a href="http://bbs.feng.com/read-htm-tid-6890655.html" title="【Mac技术组】Mac 系统引导过程概述 &amp; BootCamp 的秘密 ..." target="_blank" rel="external">Mac 系统引导过程概述 &amp; BootCamp 的秘密</a>这篇帖子中关于GPT的细节也有讲到，正好可以作为此文的补充。😊但有一点要特别指出：Apple的主板是支持EFI的，并且没有什么地方可以设置成兼容模式。所以BootCamp并不是简单使用了前文所述EFI+MBR模式，更不是BOIS+GPT的模式，而是利用EFI的系统来启动引导器，使用引导器软件读取MBR再启动。至于你问我为什么这么麻烦，为什么不直接全部用GPT？看看上面的操作系统EFI支持列表……微软💊的锅推不掉……</p>
<h3 id="u6211_u7684_u542F_u52A8U_u76D8"><a href="#u6211_u7684_u542F_u52A8U_u76D8" class="headerlink" title="我的启动U盘"></a>我的启动U盘</h3><p>读到这里，我想面对各种奇葩的操作系统安装需求，心中会有数很多了吧。至于文章开头提到的需求，老实说，我放弃了。😥我的旧电脑是leagcy BIOS的，也就是不支持GPT。MBR只支持4个分区，Ubuntu又不想完全不分区，那就只有使用混合分区了，这就需要一个好的启动器，让BIOS先把启动器跑起来，再用启动器引导不同的系统。但更关键的问题是我没有找到一个把Windows装到U盘某一个分区的办法（只找到安装到整个U盘的工具<a href="http://www.easyuefi.com/wintousb/index-cn.html" target="_blank" rel="external">WinToUSB</a>）。于是最后我做了两个系统U盘，一个Ubuntu，一个Windows。真是个悲伤的结局……</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>本文尽量详细的梳理了一遍跟GPT相关的各种概念，力求清晰原理，让各位能看完以后不再跟我一样面对各种混杂的缩写和理论发蒙。不求讲得有多精彩多么深入浅出（我自己了解的都很浅），只求能解释清楚原理，指导实践。</p>
<h2 id="u9644_u5F55-_u53C2_u8003Wiki"><a href="#u9644_u5F55-_u53C2_u8003Wiki" class="headerlink" title="附录-参考Wiki"></a>附录-参考Wiki</h2><p>列一下参考的Wiki中文条目：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" title="主引导记录" target="_blank" rel="external">主引导记录</a></li>
<li><a href="https://zh.wikipedia.org/wiki/GUID" title="GUID" target="_blank" rel="external">GUID</a></li>
<li><a href="https://zh.wikipedia.org/wiki/BIOS" title="BIOS" target="_blank" rel="external">BIOS</a></li>
<li><a href="https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8" target="_blank" rel="external">全局唯一标识分区表</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2" title="EFI" target="_blank" rel="external">EFI</a></li>
<li><a href="https://wiki.archlinux.org/index.php/EFI_System_Partition_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="external">EFI System Partition</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>MacBookPro的硬盘太小，前几天买了个128G的U盘想装好系统在虚拟机里引导，以节省日益膨胀的虚拟机文件占用的空间。我同时需要Mac、Win、Linux，买不起大容量MBP，天天寻思着删东西，实在是伤不起啊！😭预设的目标是要把Win和Ubuntu都装U盘上，而且支持在我的旧笔记本、Mac、虚拟机里都能正确引导，同时还要有一个数据分区，能在所有的系统中正常识别为U盘。为此，我狠狠研究了一通分区表，被各种缩写和规则搞得头昏脑胀。看看网上的东西也是常有错误，趁着还没忘光，自己梳理一遍吧！<br>声明：本文为作者（<a href="https://github.com/conanwhf">Conan</a>）原创，转载请标明<a href="/conanwhf.github.io">出处</a>！</p>
<h2 id="GPT_u548CMBR"><a href="#GPT_u548CMBR" class="headerlink" title="GPT和MBR"></a>GPT和MBR</h2><p>首先当然是这俩，一切都源于此。最重要的信息是：他们都是<strong>分区表</strong>，一种用来表示硬盘分区信息的格式，不太严格地说是一个<strong>软件概念</strong>。啰嗦一句分区表是干什么的：在操作系统启动之前、硬件初始化之后，确定从硬盘启动的话，需要获得硬盘分区的基本信息，那就需要分区表了。分区表不只包含硬盘的分区信息，也包括一个很小的最基本的引导程序，用到引导第二阶段引导程序，如NTLDR、BOOTMGR和GRUB等，这些第二阶段的引导程序，是需要针对每个分区进一步读取数据才能获得的。</p>
<h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><p>全称<strong>主引导记录（Master Boot Record）</strong>，又叫做主引导扇区，位于硬盘的第一个扇区主要分为两个部分：引导程序和分区结构表。有时候也将其开头的446字节引导程序特指为MBR，其后是64字节的“磁盘分区表”（DPT），以及2字节的结束标志（55AA）。因此，在使用“主引导记]]>
    
    </summary>
    
      <category term="Boot" scheme="http://conanwhf.coding.me/tags/Boot/"/>
    
      <category term="GPT" scheme="http://conanwhf.coding.me/tags/GPT/"/>
    
      <category term="MBR" scheme="http://conanwhf.coding.me/tags/MBR/"/>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派RaspberryPi系统备份Image的制作]]></title>
    <link href="http://conanwhf.coding.me/2016/08/25/rpi-cloneimg/"/>
    <id>http://conanwhf.coding.me/2016/08/25/rpi-cloneimg/</id>
    <published>2016-08-25T02:02:26.000Z</published>
    <updated>2017-06-01T08:46:45.000Z</updated>
    <content type="html"><![CDATA[<p>在树莓派上做开发，难免会弄出各种版本的系统，加上有时候还需要拿给客户自己烧录或者demo，总是要clone一下TF卡，做系统做到烦躁。于是想想有没有什么办法能做跟官方release一样的烧录img出来，基本要求就是全系统克隆，但做出的img跟卡的容量无关，只跟系统占用的存储大小有关。</p>
<h2 id="u7B80_u5355_u5168_u5361_u5907_u4EFD"><a href="#u7B80_u5355_u5168_u5361_u5907_u4EFD" class="headerlink" title="简单全卡备份"></a>简单全卡备份</h2><p>其实如果只是简单备份，可以直接将TF卡插入Linux电脑，用dd命令来备份和恢复(设备号不固定这里只是例子，还是用fdisk -l先查看一下比较保险)：</p>
<pre><code># Backup the system to img file in Linux
dd if=/dev/mmcblk0 of=raspberrypi-bak.img bs=1M
# A little difference if Mac
dd if=/dev/rdisk2 of=raspberrypi-bak.img bs=1M
#
# Restore system from img
dd if=raspberrypi-bak.img bs=1M of=/dev/mmcblk0
# Or in Mac
dd if=raspberrypi-bak.img bs=1M of=/dev/rdisk2
</code></pre><p>不过这样做，16G的卡哪怕你只用了1G，整个备份文件也有16G，占用空间耗时间是小事，想想拿这么大文件给客户不方便，也显得太不专业了。<br>在网上搜了一下，已经有朋友先行做过类似的事情：<a href="http://www.fendou.info/raspberry-pi-sd-card-backup-and-recovery/" title="树莓派 Raspberry Pi SD卡系统备份与还原" target="_blank" rel="external">树莓派 Raspberry Pi SD卡系统备份与还原</a>，看了一下按照他的步骤实践了一遍，但出现了一些问题，折腾了很久最终才解决。</p>
<h2 id="RaspberryPi_u7684_u6587_u4EF6_u7CFB_u7EDF"><a href="#RaspberryPi_u7684_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="RaspberryPi的文件系统"></a>RaspberryPi的文件系统</h2><p>首先介绍一下RaspberryPi的文件系统。树莓派的官方系统是基于Debian的，主要是两个分区：<strong>启动分区boot和根分区</strong>。boot分区为fat32格式，挂载在/boot，存放一些系统启动需要的基本文件，包括内核、驱动、firmware、启动脚本等；根分区文件系统是ext4格式，挂载于/，存放一些安装的软件和库文件、系统配置、用户数据等等；另外当系统启动时会自动生成和挂载一些必要的其他文件夹，包括temfs、sysfs、proc、debugfs、configfs等（使用mount可以看到他们），这些都是虚拟文件系统，由操作系统自动管理，备份时不需要关注。日常使用时，修改的文件包括安装的软件都是在根分区中，而如果自行编译内核，需要更新的文件都在/boot中。<br>所以备份一个系统，实际上是要备份这两个分区，官方发布的烧录镜像，也是包含了这样的两个分区，并保证通过dd的操作，能将其完整写入目标TF卡。首次烧录完毕后，不论你的TF卡容量为多少，启动后的boot和/分区大小都是固定的，然后可以使用<code>raspi-config</code>来扩展根分区的大小，boot分区不变，来达到使用所有卡内容量的目的。<br>相对应的备份步骤，大致为：创建img，把img当作一个磁盘分区和格式化，mount各个分区，将文件备份至对应的分区中，umount分区结束备份。</p>
<h2 id="u76EE_u6807_u5907_u4EFD_u6587_u4EF6_u7684_u521B_u5EFA_u548C_u5206_u533A"><a href="#u76EE_u6807_u5907_u4EFD_u6587_u4EF6_u7684_u521B_u5EFA_u548C_u5206_u533A" class="headerlink" title="目标备份文件的创建和分区"></a>目标备份文件的创建和分区</h2><p>既然是备份到文件，那么首先需要创建一个备份文件，并且把这个文件看作一个虚拟设备，对其进行分区。<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/08/25/rpi-cloneimg/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/08/25/rpi-cloneimg/'>树莓派RaspberryPi系统备份Image的制作</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
需要用到的工具有_parted, kpartx, dosfstools, rsync_，使用apt-get安装：</p>
<pre><code>sudo apt-get -y install rsync dosfstools parted kpartx
</code></pre><h3 id="u521B_u5EFA_u65B0_u7684_u6587_u4EF6"><a href="#u521B_u5EFA_u65B0_u7684_u6587_u4EF6" class="headerlink" title="创建新的文件"></a>创建新的文件</h3><p>我们用<code>dd</code>命令来创建一个新的img，img的大小和当前RaspberryPi已使用的存储空间有关。使用<code>df -P</code>来查看磁盘空间状态（以1K为单位），会看到如下的信息：<br><img src="http://whf.d.pr/1awb8+" alt=""><br>其中红框的部分就是我们需要关注的，将它们对应的Used数目取出，计算得到需要创建的img大小：<br>    img=rpibackup.img</p>
<pre><code>#sudo rm $img
bootsz=df -P | grep /boot | awk &apos;{print $2}&apos;
rootsz=df -P | grep /dev/root | awk &apos;{print $3}&apos;
totalsz=echo $bootsz $rootsz | awk &apos;{print int(($1+$2)*1.3)}&apos;
sudo dd if=/dev/zero of=$img bs=1K count=$totalsz
</code></pre><p>这里的totalsz是基于两个分区使用总和的1.3倍，一方面是分区表、格式化等操作造成的空间损失，另一方面是系统对剩余空间的要求。我曾经尝试过使用1.1，然而系统启动后在终端大部分命令都报错，说空间不足。</p>
<h3 id="u5C06_u6587_u4EF6_u5206_u533A"><a href="#u5C06_u6587_u4EF6_u5206_u533A" class="headerlink" title="将文件分区"></a>将文件分区</h3><p>工具parted可以用来把一个img文件当作一个磁盘来分区。使用<code>fdisk -l</code>能够看到系统中各个磁盘分区的情况，在我的树莓派上系统TF卡的分区情况如下：<br><img src="http://whf.d.pr/1dR76+" alt=""><br>我们把boot分区设计为跟原分区大小一样，root分区则是扩展到img文件的末尾。对应的脚本：</p>
<pre><code>bootstart=sudo fdisk -l /dev/mmcblk0 | grep mmcblk0p1 | awk &apos;{print $2}&apos;
bootend=sudo fdisk -l /dev/mmcblk0 | grep mmcblk0p1 | awk &apos;{print $3}&apos;
rootstart=sudo fdisk -l /dev/mmcblk0 | grep mmcblk0p2 | awk &apos;{print $2}&apos;
echo &quot;boot: $bootstart &gt;&gt;&gt; $bootend, root: $rootstart &gt;&gt;&gt; end&quot;
rootend=sudo fdisk -l /dev/mmcblk0 | grep mmcblk0p2 | awk &apos;{print $3}&apos;
sudo parted $img --script -- mklabel msdos
sudo parted $img --script -- mkpart primary fat32 ${bootstart}s ${bootend}s
sudo parted $img --script -- mkpart primary ext4 ${rootstart}s -1
</code></pre><h3 id="u5206_u522B_u683C_u5F0F_u5316fat32_u548Cext4_u5206_u533A"><a href="#u5206_u522B_u683C_u5F0F_u5316fat32_u548Cext4_u5206_u533A" class="headerlink" title="分别格式化fat32和ext4分区"></a>分别格式化fat32和ext4分区</h3><p>然后对分区分别进行格式化，我们可以通过loop来建立虚拟的磁盘挂载点，进行后续的操作：</p>
<pre><code>loopdevice=sudo losetup -f --show $img
device=/dev/mapper/sudo kpartx -va $loopdevice | sed -E &apos;s/.*(loop[0-9])p.*/\1/g&apos; | head -1
sleep 5
sudo mkfs.vfat ${device}p1 -n boot
sudo mkfs.ext4 ${device}p2
</code></pre><p>在中间的这个sleep是我在实践中发现，创建loop的设备节点需要一些时间，如果手动在终端贴命令则没有问题，而若是用脚本执行，则在format时节点还没有创建好，从而造成格式化失败。</p>
<h2 id="u5907_u4EFDBoot_u5206_u533A"><a href="#u5907_u4EFDBoot_u5206_u533A" class="headerlink" title="备份Boot分区"></a>备份Boot分区</h2><p>Boot分区是Fat32格式且数据不多，直接mount然后copy数据即可，注意权限问题。</p>
<pre><code>mountb=$usbmount/backup_boot/
mkdir -p $mountb
sudo mount -t vfat ${device}p1 $mountb
sudo cp -rfp /boot/* $mountb
sync 
sudo umount $mountb
</code></pre><h2 id="u5907_u4EFD_u6839_uFF08root_uFF09_u5206_u533A"><a href="#u5907_u4EFD_u6839_uFF08root_uFF09_u5206_u533A" class="headerlink" title="备份根（root）分区"></a>备份根（root）分区</h2><p>根分区的备份是我折腾了很久的部分。因为它文件众多，不止一个文件夹，而且在系统运行时有一些文件、文件夹是临时生成或者mount的，不能全部直接copy。这就需要有一种方法能区分真正写在磁盘上的文件并将其备份。</p>
<h3 id="u5931_u8D25_u7684_u7ECF_u9A8C_uFF1Adump_26amp_3Brestore"><a href="#u5931_u8D25_u7684_u7ECF_u9A8C_uFF1Adump_26amp_3Brestore" class="headerlink" title="失败的经验：dump&amp;restore"></a>失败的经验：dump&amp;restore</h3><p>在开头提到的道友那篇文章里，是采用了针对ext4备份和恢复的工具dump和restore。</p>
<blockquote>
<p>sudo mount -t ext4 $partRoot /media/<br>cd /media<br>sudo dump -0uaf - / |  sudo restore -rf -<br>cd; sudo umount /media</p>
</blockquote>
<p>但在关键的步骤出现了<strong> Broken pipe</strong>错误，经过重复测试多次，虽然每次报错的文件和inode不一样，但每次都无法顺利完成。这个问题在原博的评论中也有人遇到了：</p>
<blockquote>
<p>restore: ./lost+found: File exists<br>./tmp/rstdir1445584846: (inode 159534) not found on tape<br>./tmp/rstmode1445584846: (inode 161527) not found on tape<br>DUMP: Broken pipe<br>DUMP: The ENTIRE dump is aborted.<br>………………</p>
</blockquote>
<p>针对这个问题我做了一些测试。首先是把<code>sudo dump -0uaf - / | sudo restore -rf -</code>分开，取消管道，先dump到一个文件再restore。发现dump总是成功的，而问题出在restore上，所以就broken pipe了。开始怀疑是restore的时候权限有问题，后来把dump出来的文件拿到PC上做restore，也同样是失败。这样就很有可能是dump的文件有问题，仔细看看每次出错的文件都是隐藏或者临时文件，怀疑跟这个有关，但找了一大圈dump相关的参数尝试，依然是没有解决。</p>
<h3 id="u4F7F_u7528rsync_u5907_u4EFD"><a href="#u4F7F_u7528rsync_u5907_u4EFD" class="headerlink" title="使用rsync备份"></a>使用rsync备份</h3><p>由于每次测试dump和restore花的时间很长，项目又比较急，我实在是不能再耽搁下去了，于是决定放弃这种方式。想了一下，曾经用过<a href="https://github.com/billw2/rpi-clone" title="rpi-clone" target="_blank" rel="external">rpi-clone</a>来做卡与卡之间的备份，那么备份成文件也应该是一样的。我于是去看了下它的源码，把根文件系统备份相关的部分提出来就能直接用起来了。这里用的是备份工具rsync，其本质上是基于文件系统之上的的直接拷贝，因为没有用到增量备份，所以跟cp其实是一回事。只是rsync能很好的保留各种权限、时间戳、软链接和文件信息，避免了一些用cp的问题。保险起见，我依然沿用了它。<br>首先还是mount一下：</p>
<pre><code>mountr=$usbmount/backup_root/
mkdir -p $mountr
sudo mount -t ext4 ${device}p2 $mountr
</code></pre><p>然后要对存在swap分区的情况进行特殊处理：</p>
<pre><code>if [ -f /etc/dphys-swapfile ]; then
        SWAPFILE=`cat /etc/dphys-swapfile | grep ^CONF_SWAPFILE | cut -f 2 -d=`
    if [ &quot;$SWAPFILE&quot; = &quot;&quot; ]; then
        SWAPFILE=/var/swap
    fi
    EXCLUDE_SWAPFILE=&quot;--exclude $SWAPFILE&quot;
fi
</code></pre><p>接着就是所有文件的备份，跳过某些临时、系统自动生成的文件和文件夹：</p>
<pre><code>sudo rsync --force -rltWDEgopt --delete --stats --progress\
    $EXCLUDE_SWAPFILE \
    --exclude &apos;.gvfs&apos; \
    --exclude &apos;/dev&apos; \
        --exclude &apos;/media&apos; \
    --exclude &apos;/mnt&apos; \
    --exclude &apos;/proc&apos; \
        --exclude &apos;/run&apos; \
    --exclude &apos;/sys&apos; \
    --exclude &apos;/tmp&apos; \
        --exclude &apos;lost\+found&apos; \
    --exclude &apos;$usbmount&apos; \
    // $mountr
</code></pre><p>完成后新建一些特殊文件夹，用来做系统启动时某些文件的自动挂载点，例如proc和mnt等等：</p>
<pre><code>for i in dev media mnt proc run sys boot; do
    if [ ! -d $mountr/$i ]; then
        sudo mkdir $mountr/$i
    fi
done
if [ ! -d $mountr/tmp ]; then
    sudo mkdir $mountr/tmp
    sudo chmod a+w $mountr/tmp
fi
</code></pre><p>到这里基本上就完成了，有一点小小的修改就是把网络配置文件删掉，以免换了新的网络环境启动系统无法自动配置：</p>
<pre><code>sudo rm -f $mountr/etc/udev/rules.d/70-persistent-net.rules
sync
</code></pre><p>最后umount，清理loop设备，结束备份：</p>
<pre><code>sudo umount $mountr
# umount loop device
sudo kpartx -d $loopdevice
sudo losetup -d $loopdevice
sudo umount $usbmount
rm -rf $mountb $mountr
</code></pre><h3 id="Mount_USB_device"><a href="#Mount_USB_device" class="headerlink" title="Mount USB device"></a>Mount USB device</h3><p>使用dump/restore的时候，有一个跳过特定文件的参数，在前文提到的教程中，作者是将img放到用户目录，并且跳过这个文件的。虽然使用rsync备份的时候，依然可以这么做，但考虑到通用性和调试的方便，我把文件直接备份在了外接的U盘上，以避免考虑各种“自己备份自己”可能带来的问题。顺便把相关的USB mount脚本和判断也贴一下供参考：</p>
<pre><code>usbmount=/mnt
mkdir -p $usbmount
if [ -z $1 ]; then
    echo &quot;no argument, assume the mount device is /dev/sda1 ? Y/N&quot;
    read key
    if [ &quot;$key&quot; = &quot;y&quot; -o &quot;$key&quot; = &quot;Y&quot; ]; then
        sudo mount -t vfat -o uid=1000 /dev/sda1 $usbmount
    else
        echo &quot;$0 [backup dest device name], e.g. $0 /dev/sda1&quot;
        exit 0
    fi
else
    sudo mount -t vfat -o uid=1000 $1 $usbmount
fi
if [ -z &quot;`grep $usbmount /etc/mtab`&quot; ]; then
    echo &quot;mount fail, exit now&quot;
    exit 0
fi 
</code></pre><p> 当然，如果你有兴趣，大可以自己改一改尝试直接备份在用户目录，只是我感觉依然是需要copy出来，意义不大。😏</p>
<h2 id="u6062_u590D_u5907_u4EFD"><a href="#u6062_u590D_u5907_u4EFD" class="headerlink" title="恢复备份"></a>恢复备份</h2><p>备份img做好了，恢复备份就无需多谈了。既然是用树莓派的小伙伴，自然有一百种方法将镜像烧录到卡上。实在不知道的，放官方链接：<a href="https://www.raspberrypi.org/documentation/installation/installing-images/README.md" title="Installing images" target="_blank" rel="external">Installing images</a>，或者看这篇：<a href="http://conanwhf.github.io/2016/01/12/rpi-start/" title="树莓派初始配置指南（2代B型）" target="_blank" rel="external">树莓派初始配置指南（2代B型）</a>。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>整理后完整的script我已经更新到GitHub:<a href="https://github.com/conanwhf/RaspberryPi-script/blob/master/rpi-backup.sh" target="_blank" rel="external">https://github.com/conanwhf/RaspberryPi-script/blob/master/rpi-backup.sh</a>，如果对你有所帮助，<strong>欢迎Star</strong>！😊有什么疑问和质疑，也欢迎砸过来！🤗<br>顺便提一下，写这篇文章的时候，我发现官方已经release了一个备份工具，<a href="https://github.com/raspberrypi/piclone" title="piclone" target="_blank" rel="external">piclone</a>，看上去是在两个TF卡之间备份，跟rpi-clone功能一样。我还没有测过，有兴趣的小伙伴可以试一下，看看源码，也许/的备份能有新的思路和方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在树莓派上做开发，难免会弄出各种版本的系统，加上有时候还需要拿给客户自己烧录或者demo，总是要clone一下TF卡，做系统做到烦躁。于是想想有没有什么办法能做跟官方release一样的烧录img出来，基本要求就是全系统克隆，但做出的img跟卡的容量无关，只跟系统占用的存储大小有关。</p>
<h2 id="u7B80_u5355_u5168_u5361_u5907_u4EFD"><a href="#u7B80_u5355_u5168_u5361_u5907_u4EFD" class="headerlink" title="简单全卡备份"></a>简单全卡备份</h2><p>其实如果只是简单备份，可以直接将TF卡插入Linux电脑，用dd命令来备份和恢复(设备号不固定这里只是例子，还是用fdisk -l先查看一下比较保险)：</p>
<pre><code># Backup the system to img file in Linux
dd if=/dev/mmcblk0 of=raspberrypi-bak.img bs=1M
# A little difference if Mac
dd if=/dev/rdisk2 of=raspberrypi-bak.img bs=1M
#
# Restore system from img
dd if=raspberrypi-bak.img bs=1M of=/dev/mmcblk0
# Or in Mac
dd if=raspberrypi-bak.img bs=1M of=/dev/rdisk2
</code></pre><p>不过这样做，16G的卡哪怕你只用了1G，整个备份文件也有16G，占用空间耗时间是小事，想想拿这么大文件给客户不方便，也显得太不专业了。<br>在网上搜了一下，已经有朋友先行做过类似的事情：<a href="http://www.fendou.info/raspberry-pi-sd-card-backup-and-recovery/" title="树莓派 Raspberry Pi SD卡系统备份与还原">树莓派 Raspberry Pi SD卡系统备份与还原</a>，看了一下按照他的步骤实践了一遍，但出现了一些问题，折腾了很久最终才解决。</p>
<h2 id="RaspberryPi_u7684_u6587_u4EF6_u7CFB_u7EDF"><a href="#RaspberryPi_u7684_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="RaspberryPi的文件系统"></a>RaspberryPi的文件系统</h2><p>首先介绍一下RaspberryPi的文件系统。树莓派的官方系统是基于Debian的，主要是两个分区：<strong>启动分区boot和根分区</strong>。boot分区为fat32格式，挂载在/boot，存放一些系统启动需要的基本文件，包括内核、驱动、firmware、启动脚本等；根分区文件系统是ext4格式，挂载于/，存放一些安装的软件和库文件、系统配置、用户数据等等；另外当系统启动时会自动生成和挂载一些必要的其他文件夹，包括temfs、sysfs、proc、debugfs、configfs等（使用mount可以看到他们），这些都是虚拟文件系统，由操作系统自动管理，备份时不需要关注。日常使用时，修改的文件包括安装的软件都是在根分区中，而如果自行编译内核，需要更新的文件都在/boot中。<br>所以备份一个系统，实际上是要备份这两个分区，官方发布的烧录镜像，也是包含了这样的两个分区，并保证通过dd的操作，能将其完整写入目标TF卡。首次烧录完毕后，不论你的TF卡容量为多少，启动后的boot和/分区大小都是固定的，然后可以使用<code>raspi-config</code>来扩展根分区的大小，boot分区不变，来达到使用所有卡内容量的目的。<br>相对应的备份步骤，大致为：创建img，把img当作一个磁盘分区和格式化，mount各个分区，将文件备份至对应的分区中，umount分区结束备份。</p>
<h2 id="u76EE_u6807_u5907_u4EFD_u6587_u4EF6_u7684_u521B_u5EFA_u548C_u5206_u533A"><a href="#u76EE_u6807_u5907_u4EFD_u6587_u4EF6_u7684_u521B_u5EFA_u548C_u5206_u533A" class="headerlink" title="目标备份文件的创建和分区"></a>目标备份文件的创建和分区</h2><p>既然是备份到文件，那么首先需要创建一个备份文件，并且把这个文件看作一个虚拟设备，对其进行分区。]]>
    
    </summary>
    
      <category term="Boot" scheme="http://conanwhf.coding.me/tags/Boot/"/>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/tags/RaspberryPi/"/>
    
      <category term="Script" scheme="http://conanwhf.coding.me/tags/Script/"/>
    
      <category term="Linux" scheme="http://conanwhf.coding.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Droplr的测试]]></title>
    <link href="http://conanwhf.coding.me/2016/08/20/DroplrTest/"/>
    <id>http://conanwhf.coding.me/2016/08/20/DroplrTest/</id>
    <published>2016-08-20T09:35:25.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<p>买了Droplr的永久会员，测试一下外链图片，如果OK就把七牛换了……国内的免费服务太让人没安全感！<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/08/20/DroplrTest/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/08/20/DroplrTest/'>Droplr的测试</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<br><img src="http://whf.d.pr/18C89+" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>买了Droplr的永久会员，测试一下外链图片，如果OK就把七牛换了……国内的免费服务太让人没安全感！]]>
    
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2016-08]]></title>
    <link href="http://conanwhf.coding.me/2016/08/15/ReadingList2016-08/"/>
    <id>http://conanwhf.coding.me/2016/08/15/ReadingList2016-08/</id>
    <published>2016-08-15T09:36:54.000Z</published>
    <updated>2017-06-06T04:10:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>催眠师手记</strong><br>刚开通借阅，看到首页推荐，于是下下来看了下。故事还可以，看到一多半的时候就开始腻……最后是努力看完的后面两个故事，属于还能看看的故事书吧。本来以为是专业性比较强的东西，结果是打着手记外衣的小说。作者有点模仿福尔摩斯的感觉，只是这次厉害的那个关键人物换成了非第一人称：解密二人组，有一个人上知天文下知地理专业精湛，另一个负责处理杂事以及理解天才的不可理解之处。这样的故事讲好了也还不错，只可惜这本书里的故事，有点装神弄鬼。Any way，比起普遍的酸酸文艺风和无法直视的网文，这本书还算可以一读，拿来休闲正好。</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选</li>
<li>知乎周刊2015年度300问-心理<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/08/15/ReadingList2016-08/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/08/15/ReadingList2016-08/'>读书清单 2016-08</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

<h2 id="u6B63_u5728_u8BFB_u7684_u4E66"><a href="#u6B63_u5728_u8BFB_u7684_u4E66" class="headerlink" title="正在读的书"></a>正在读的书</h2></li>
<li>南海暗战</li>
</ol>
<h2 id="u4E2D_u4E9A_u4E70_u7684_u4E66_uFF0807-08_u6708_uFF09_37-73"><a href="#u4E2D_u4E9A_u4E70_u7684_u4E66_uFF0807-08_u6708_uFF09_37-73" class="headerlink" title="中亚买的书（07-08月）             37.73"></a>中亚买的书（07-08月）             <strong>37.73</strong></h2><ol>
<li>斯坦福极简经济学              <strong>1.00</strong></li>
<li>巴金文集（套装共19本）         <strong>9.99</strong></li>
<li>专业主义                     <strong>3.36</strong></li>
<li>高盛帝国(套装上下册):全球唯一一部全面讲述高盛百年屹立的企业传记    <strong>3.40</strong></li>
<li>精准拉伸 疼痛消除和损伤预防的针对性练习   <strong>9.99</strong></li>
<li>Linux内核设计的艺术：图解Linux操作系统架构设计与实现原理（第2版）  <strong>9.99</strong></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这几个月都没写这个了，今天算是几个月的总结吧。其实也是几个月没读书了……说是读书总结，不如说是买书总结，因为最近都在忙项目，书买得不少却一直没怎么看，连运动都好几周没做，整个人快懒坏。但七月份有一天是结结实实捡了大漏，兴奋了我好几天，不记一下不甘心。:-)<br>那天刷微博，看到大锤转发说亚马逊发福利，一批书1元购，但不是所有人都有。马上去查了下自己的优惠券，啥也没有，挺失落的。到了晚上，又刷出来一条说有的话会收到短信，我再去看千年不用专收验证码的手机，果然有！开心打开链接，书的质量真是不错，有好几本都是我放在心愿单上等降价的。试着下了一本，0元？好奇怪……收到的短信说是1元啊……再试，还是0元。这……考虑到亚马逊历来的良心表现，即使这是个bug，也不会不认账的。我放心地把心仪的几本都买下来，全部0元。跑去看李大锤微博的评论，有说0元的，有说1元的，有说收到优惠券的……我有点蒙，但隐隐约约一种“要占大便宜”的感觉充斥了大脑，使我兴奋得不行。我再次打开优惠链接，确认之前真的没扣款，按价格从高到低排序，放心大胆地一条条点开购买起来！当然里面的书也有很一般的，我只点开有兴趣的看看评论，决定要不要，一开几十个tab，慢慢临幸过来，那感觉真是爽！整个过程虽然有点机械和无聊，但被强烈兴奋感所驱使的我，毫无懈怠感，不停地点击了一个多钟头，一直到过12点才全部完成。等喘口气才发现，不加判断点击购买的最后几本书，已经不是0元了，但是个很奇怪的数字，大约是2-3折的样子。<br>第二天我打开邮箱，亚马逊的购买记录180条……去看微博评论，原来真正的活动是部分用户发了张100元的优惠券，可以在书单中以1元的价格买书，也就是上限100本；而我却是0元买了180本……这时候再去看那些书单，价格也不是1元了，而是另外一个打了折的价格。也就是说，在12点之前，大概是有bug导致我可以0元无限购书，之后就恢复正常了……不犯懒是个多好的品质啊！幸亏我速度快清单都点完了，也幸亏我跳过了部分不喜欢的书，不然也点不完，哈哈哈！本来以为这个漏洞很多人都抓到了，后来看看微博评论、各大论坛的反馈，并没有什么大面积占到便宜的反馈，我心里更是开心了好几天啊！某人说现在知道我是真爱书了，买到了书能高兴这么久。而且这些书的质量确实都很高，评分绝大多数在4+，特别是很多历史书正和某人口味，这段时间一直在看，感觉一时半会是看不完了。:D</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8BFB_u5B8C_u7684_u4E66"><a href="#u8BFB_u5B8C_u7684_u4E66" class="headerlink" title="读完的书"></a>读完的书</h2><ol>
<li><strong>催眠师手记</strong><br>刚开通借阅，看到首页推荐，于是下下来看了下。故事还可以，看到一多半的时候就开始腻……最后是努力看完的后面两个故事，属于还能看看的故事书吧。本来以为是专业性比较强的东西，结果是打着手记外衣的小说。作者有点模仿福尔摩斯的感觉，只是这次厉害的那个关键人物换成了非第一人称：解密二人组，有一个人上知天文下知地理专业精湛，另一个负责处理杂事以及理解天才的不可理解之处。这样的故事讲好了也还不错，只可惜这本书里的故事，有点装神弄鬼。Any way，比起普遍的酸酸文艺风和无法直视的网文，这本书还算可以一读，拿来休闲正好。</li>
</ol>
<h2 id="u8BFB_u5B8C_u7684_u6742_u5FD7"><a href="#u8BFB_u5B8C_u7684_u6742_u5FD7" class="headerlink" title="读完的杂志"></a>读完的杂志</h2><ol>
<li>中文传媒精选</li>
<li>知乎周刊2015年度300问-心理]]>
    
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.coding.me/tags/BookList/"/>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.coding.me/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派RaspberryPi 3B的一些改变]]></title>
    <link href="http://conanwhf.coding.me/2016/08/12/rpi-3b/"/>
    <id>http://conanwhf.coding.me/2016/08/12/rpi-3b/</id>
    <published>2016-08-12T11:31:26.000Z</published>
    <updated>2017-06-01T08:47:12.000Z</updated>
    <content type="html"><![CDATA[<p>工作原因换上了最新的树莓派3B，使用了几天，虽然变化不大，但跟2B还是有一些区别的。在这里写下来供爱好者们参考。</p>
<ol>
<li>硬件上，基本上是可以通用的，接口跟2B保持一致，GPIO的排列也没有变过。值得注意的是3B自带了WIFI模块，所以你会看到开机就能有Wlan0的设备。</li>
<li>系统上，有一些改变可能是操作系统升级导致的，比如cmdline跟以前不同，但总的来说变化不大。官网的烧录img和github提供的kernel源码现在都已经提供了3B的支持，只是烧录系统就不讨论了，如果是自己编译kernel的话要注意<code>/boot/bcm2710-rpi-3-b.dtb</code>这个文件，这是系统支持3B的关键。内核的img名字还是<strong>kernel7.img</strong>没变，新的系统能同时支持3B和2B。是否把<strong>bcm2701-rpi-3-b.dtb</strong>拷贝到旧的系统中就能使其支持3B，我没有测试过，但我想应该不能成功，因为恐怕还需要更新一些index。</li>
<li>实际使用中，关于UART发现了一个很好玩的变化。以前串口的设备是<code>/dev/ttyAMA0</code>，但在3B上变成了<code>/dev/ttyS0</code>。确切地说，是3B的设备多出来一个<strong>ttyS0</strong>，并且使用ttyAMA0无法传输数据，必须使用ttyS0。前面说了新的系统可以同时兼容两种板子，我用同样的软件在2B和3B上都试了一下，2B依然只有ttyAMA0，所以可以肯定这不是软件升级的区别，具体原因就不知到了。<br>目前只看到这些不同，用起来也没什么区别的样子，可能好的地方就是可以省出一个USB口吧。😀</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>工作原因换上了最新的树莓派3B，使用了几天，虽然变化不大，但跟2B还是有一些区别的。在这里写下来供爱好者们参考。</p>
<ol>
<li>硬件上，基本上是可以通用的，接口跟2B保持一致，GPIO的排列也没有变过。值得注意的是3B自带了WIFI模块，所以你会看到开机就能有W]]>
    </summary>
    
      <category term="RaspberryPi" scheme="http://conanwhf.coding.me/tags/RaspberryPi/"/>
    
      <category term="Linux" scheme="http://conanwhf.coding.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年06月]]></title>
    <link href="http://conanwhf.coding.me/2016/07/01/Tips201606/"/>
    <id>http://conanwhf.coding.me/2016/07/01/Tips201606/</id>
    <published>2016-07-01T09:25:39.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>iOS获取通知需要注意以：iOS 设备收到一条推送（APNs），用户点击推送通知打开应用时，应用程序根据状态不同进行处理需在 AppDelegate 中的以下两个方法中添加代码以获取apn内容<ol>
<li>如果 App 状态为未运行，此函数将被调用，如果launchOptions包含UIApplicationLaunchOptionsRemoteNotificationKey表示用户点击apn 通知导致app被启动运行；如果不含有对应键值则表示 App 不是因点击apn而被启动，可能为直接点击icon被启动或其他。<br>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions;<br>// apn 内容获取：<br>NSDictionary *remoteNotification = [launchOptions objectForKey: UIApplicationLaunchOptionsRemoteNotificationKey]</li>
</ol>
</li>
</ul>
<ol>
<li>基于iOS 6 及以下的系统版本，如果 App状态为正在前台或者点击通知栏的通知消息，那么此函数将被调用，并且可通过AppDelegate的applicationState是否为UIApplicationStateActive判断程序是否在前台运行。此种情况在此函数中处理：<br> (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo; // apn内容为userInfo</li>
<li>基于iOS 7 及以上的系统版本，如果是使用 iOS 7 的 Remote Notification 特性那么处理函数需要使用<br> (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler; // apn内容为userInfo</li>
</ol>
<ul>
<li>触摸事件withEvent:的方法处理流程:首先会在当前视图view上调用pointInside:withEvent:方法来判断触摸事件是否存在当前view中，如果返回NO，则说明触摸事件不在该view范围中，hitText:withEvent:方法返回nil；如果返回YES，则说明触摸在该view中，则向该view的subViews发送htiText:withEvent:消息，所有subviews的数组遍历顺序是从后往前，直至遍历到pointInside:withEvent:返回值为非空或者遍历完所有subview结束。如果遍历有非空对象,则hitTextField:withEvent:返回该对象结束；如果遍历完没有非空对象，则返回自己（self）。</li>
<li>响应者原理：首先会在触摸view上调用inital view方法，看能否处理此事件，如果不能则会将事件传递给其上级视图（inital view的superView）；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到window，如果window还是不能处理此事件则继续交给application（UIApplication单例对象）处理，如果最后application还是不能处理此事件则将其丢弃。</li>
<li>UITabBarController的subview 共有两个，一个叫 UITabBar，就是底下的那个 Bar；另一个叫UITranstionview，就是 Bar 上面的视图。把UITabBar的 y 向下移49个单位，把UITranstionview 的 hight 加长 49 个单位，也能实现隐藏UITabBar的效果。</li>
<li>UITextView开始编辑时，文字没有左上角对齐解决办法：其一，没有给textview对齐方式；其二，没有将BOOL类型的“automaticallyAdjustsScrollViewInsets”属性置为yes</li>
</ul>
<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/07/01/Tips201606/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/07/01/Tips201606/'>开发Tips收集-2016年06月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>iOS获取通知需要注意以：iOS 设备收到一条推送（APNs），用户点击推送通知打开应用时，应用程序根据状态不同进行处理需在 AppDelegate 中的以下两个方法中添加代码以获取apn内容<ol>
<li>如果 App 状态为未运行，此函数将被调用，如果launchOptions包含UIApplicationLaunchOptionsRemoteNotificationKey表示用户点击apn 通知导致app被启动运行；如果不含有对应键值则表示 App 不是因点击apn而被启动，可能为直接点击icon被启动或其他。<br>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions;<br>// apn 内容获取：<br>NSDictionary *remoteNotification = [launchOptions objectForKey: UIApplicationLaunchOptionsRemoteNotificationKey]</li>
</ol>
</li>
</ul>
<ol>
<li>基于iOS 6 及以下的系统版本，如果 App状态为正在前台或者点击通知栏的通知消息，那么此函数将被调用，并且可通过AppDelegate的applicationState是否为UIApplicationStateActive判断程序是否在前台运行。此种情况在此函数中处理：<br> (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo; // apn内容为userInfo</li>
<li>基于iOS 7 及以上的系统版本，如果是使用 iOS 7 的 Remote Notification 特性那么处理函数需要使用<br> (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler; // apn内容为userInfo</li>
</ol>
<ul>
<li>触摸事件withEvent:的方法处理流程:首先会在当前视图view上调用pointInside:withEvent:方法来判断触摸事件是否存在当前view中，如果返回NO，则说明触摸事件不在该view范围中，hitText:withEvent:方法返回nil；如果返回YES，则说明触摸在该view中，则向该view的subViews发送htiText:withEvent:消息，所有subviews的数组遍历顺序是从后往前，直至遍历到pointInside:withEvent:返回值为非空或者遍历完所有subview结束。如果遍历有非空对象,则hitTextField:withEvent:返回该对象结束；如果遍历完没有非空对象，则返回自己（self）。</li>
<li>响应者原理：首先会在触摸view上调用inital view方法，看能否处理此事件，如果不能则会将事件传递给其上级视图（inital view的superView）；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到window，如果window还是不能处理此事件则继续交给application（UIApplication单例对象）处理，如果最后application还是不能处理此事件则将其丢弃。</li>
<li>UITabBarController的subview 共有两个，一个叫 UITabBar，就是底下的那个 Bar；另一个叫UITranstionview，就是 Bar 上面的视图。把UITabBar的 y 向下移49个单位，把UITranstionview 的 hight 加长 49 个单位，也能实现隐藏UITabBar的效果。</li>
<li>UITextView开始编辑时，文字没有左上角对齐解决办法：其一，没有给textview对齐方式；其二，没有将BOOL类型的“automaticallyAdjustsScrollViewInsets”属性置为yes</li>
</ul>]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年05月]]></title>
    <link href="http://conanwhf.coding.me/2016/05/31/Tips201605/"/>
    <id>http://conanwhf.coding.me/2016/05/31/Tips201605/</id>
    <published>2016-05-31T09:25:39.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIImage两种初始化方式的区别：<br>　　使用<strong>imageNamed</strong>：第一次读取的时候，先把这个图片放到缓存里，下次再使用到这个同名图片的时候直接从缓存中读取；优点：方便快捷，只有第一次使用的时候稍慢，接下来再使用就会稍微快点；缺点：如果在当前工程中只使用一次会浪费内存。（这个内存在程序关闭的时候才释放）<br>　　使用<strong>initWithContentsOfFile</strong>：每次都会根据路径去读取，不会占用内存，如果图片在当前工程中只使用一次，应该选择这个方法</li>
<li>UIView和CALayer的区别与联系）<ol>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li>
<li>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display</li>
<li>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</li>
<li>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</li>
<li>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</li>
</ol>
</li>
<li>在使用 ImagesQA.xcassets 时需要注意：将图片直接拖入image到ImagesQA.xcassets中时，图片的名字会保留。这个时候如果图片的名字过长，那么这个名字会存入到ImagesQA.xcassets中，名字过长会引起SourceTree判断异常。</li>
<li>UIScrollView添加了一个很好用的属性keyboardDismissMode，这样可以让键盘在滚动时自动收起。这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/05/31/Tips201605/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/05/31/Tips201605/'>开发Tips收集-2016年05月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<ol>
<li>UIScrollViewKeyboardDismissModeNone,</li>
<li>UIScrollViewKeyboardDismissModeOnDrag,      // dismisses the keyboard when a drag begins</li>
<li>UIScrollViewKeyboardDismissModeInteractive, // the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss</li>
</ol>
</li>
<li>iOS加载启动图的时候隐藏statusbar只需要在info.plist中加入<strong>Status bar is initially hidden</strong>，设置为YES就好</li>
<li>NSDate 在保存数据，传输数据中，一般最好使用UTC时间。在显示到界面给用户看的时候，需要转换为本地时间。</li>
<li>UITableViewCell中，对cell设置<strong>indentationLevel</strong>的值，可以将cell 分级别。还有 CGFloat <strong>indentationWidth</strong>属性，设置缩进的宽度。总缩进的宽度 = indentationLevel * indentationWidth</li>
<li>static的使用：<ol>
<li>修饰局部变量,修改的是生命周期，在整个程序运行过程中,只初始化一次,而且只有一份内存,并没有改变作用域</li>
<li>修饰全局变量,修改的是作用域。没有被static修饰的全局变量,项目中的任何文件,可以访问；static修饰的全局变量,只在当前文件中访问</li>
</ol>
</li>
<li>isMemberOfClass 和 isKindOfClass：两者都能检测一个对象是不是某个类的成员；isKindOfClass不仅能确定一个对象是不是某个类的成员,也能确定一个对象是否是派生自该类的类的成员,而isMemberOfClass只能做到前者.</li>
<li>TCP 和UDP 的区别与联系：TCP 为传输控制层协议,为面向连接,可靠的,点到点的通信；UDP 为用户数据报协议,非连接的不可靠的点到多点的通信；TCP 侧重可靠传输,UDP 侧重快速传输</li>
<li>读写小文件是 iPhone 的一大弱点。16MB 的文件测试与 Mac 的测试结果差不多，但是 16 字节的文件测试 iPhone 花了 Mac 10 倍的时间。相比 Mac，iPhone 的存储设备吞吐量很高，但是有一些额外的延迟。</li>
<li>iOS的应用都是通过bundle进行封装的，对应的bundle类型是Application类型，平时我们通过XCode编译出来的Target（即我们开发的应用），其实就是一个Application类型bundle，即一个文件夹！但是Finder会把这个bundle当做一个文件显示给我们，其实是因为这个bundle自身也是一个package，而Mac系统会把所有的package当做一个文件来对待，显示给用户，从而防止用户误操作导致程序文件损坏或丢失。</li>
<li>NSURLConnettion是 Core Foundation/CFNetwork框架 API 之上的一个抽象. NSURLConnettion是用来指代 Foundation 框架中的一系列组件: NSURLRequest,NSURLResponse,NSURLProtocol,NSURLCache,NSHTTPCookieStorage,NSURLCredentialStorage 以及同名类 NSURLConnection.</li>
<li>NSURLSession 不仅仅包括同名的 NSURLSession, 还包括NSURLRequest 和 NSURLCache. 同时将NSURLConnection 对应为NSURLSession,NSURLSessionFiguration 以及NSURLSession 的三个子类,即NSURLSessionTask,NSURLSessionUpLoadTask 和 NSULSessionDownLoadTask.</li>
<li>和 NSURLConnection 相比, NSURLSession 最大的改变可以配置每一个缓存的session 缓存, cookie 值,协议以及证书策略甚至夸程序共享这些信息.这保证了程序和网络框架之间的相互独立.每一个 NSURLSession 有一个 NSURLSessionConfiguration 来进行初始化, NSURLSessionConfiguration指定了策略,以及在移动设备上增强性能的选项.NSURLSession 的另一个特点就是 session Task, 用来处理的上传和下载.和 NSURLConnection 最大的不同之处在于,所有的 task 共享其创造者 NSURLSession.</li>
<li>NSURLSession即有 session 的代理方法又有 Task 的代理方法.session 的代理方法用来处理连接层的问题(服务器的信任,客户端证书的评估等),Task 的代理方法用来处理鉴权查询和以网络请求有关的问题.</li>
<li>AVAudioPlayer包含在 AVFoundation框架中，所以开发的时候首先导入音频的框架AVFoundation.framework。注意：引入头文件 #import \<avfoundation avfoundation.h\="">。<pre><code>AVAudioPlayer的初始化的时候需要给一个播放文件：AVAudioPlayer  *avAudioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:文件路径 error:nil];
</code></pre></avfoundation></li>
<li>要修改app名字的时候最好不要修改product，可以在info.plist中修改Bundle display name.</li>
<li>当UIWebView播放视频时，可以看到view hierarchy里有FigPluginView的身影。这个类来自于QuickTime Plugin，plugin的路径为：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.1.sdk/System/Library/Internet Plug-Ins/QuickTime Plugin.webplugin，这是个文件夹，里面还有链接库以及文件和图片资源。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIImage两种初始化方式的区别：<br>　　使用<strong>imageNamed</strong>：第一次读取的时候，先把这个图片放到缓存里，下次再使用到这个同名图片的时候直接从缓存中读取；优点：方便快捷，只有第一次使用的时候稍慢，接下来再使用就会稍微快点；缺点：如果在当前工程中只使用一次会浪费内存。（这个内存在程序关闭的时候才释放）<br>　　使用<strong>initWithContentsOfFile</strong>：每次都会根据路径去读取，不会占用内存，如果图片在当前工程中只使用一次，应该选择这个方法</li>
<li>UIView和CALayer的区别与联系）<ol>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li>
<li>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display</li>
<li>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</li>
<li>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</li>
<li>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</li>
</ol>
</li>
<li>在使用 ImagesQA.xcassets 时需要注意：将图片直接拖入image到ImagesQA.xcassets中时，图片的名字会保留。这个时候如果图片的名字过长，那么这个名字会存入到ImagesQA.xcassets中，名字过长会引起SourceTree判断异常。</li>
<li>UIScrollView添加了一个很好用的属性keyboardDismissMode，这样可以让键盘在滚动时自动收起。这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年04月]]></title>
    <link href="http://conanwhf.coding.me/2016/04/30/Tips201604/"/>
    <id>http://conanwhf.coding.me/2016/04/30/Tips201604/</id>
    <published>2016-04-30T09:25:39.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>当手势和touchmoved同时加在uiview上面的时候将会优先的识别手势。滑动手势的识别是需要时间的，当手势在被识别出来以前，touchbegan 依旧会被调用。如果你希望在你的手势被识别的过程中touchbegan不被调用，那么你需要调用delaysTouchesBegan。</li>
<li>修改状态栏字体颜色:只能设置两种颜色，黑色和白色，系统默认黑色。设置为白色方法：<ol>
<li>在plist里面添加Status bar style，值为UIStatusBarStyleLightContent（白色）或UIStatusBarStyleDefault（黑 色）</li>
<li>在Info.plist中设置UIViewControllerBasedStatusBarAppearance 为NO</li>
</ol>
</li>
<li>改善APP的流畅度：<ol>
<li>尽量不要实现drawRect（每次调用该方法时，都要为backing store分配内存，非常消耗CPU）</li>
<li>避免在drawRect：中进行耗费大量CPU资源的工作</li>
<li>尽量少调用setNeedsDisplay:（视图内容变化时才调用）</li>
<li>考虑使用setNeedDisplayInRect: , 传入drawRect:的rect越小，stoke，fill的时间越少, 即使drawRect:是根据视图边界绘制的）</li>
<li>充分利用GPU的资源，直接设置layer的border，shadow，corner，gradient等属性, GPU将会处理这些属性（相反如果GPU紧张，CPU空闲，应由CPU处理，可在drawRect：中实现）<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/04/30/Tips201604/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/04/30/Tips201604/'>开发Tips收集-2016年04月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
</li>
<li>如果绘制很多东西到一个视图时，可尝试开启drawsAsynchronusly，那么GPU会将视图内容绘制到backing store中，但是开启后，内存会增加，因此需要评估开启前后性能的变化，谨慎使用。</li>
</ol>
</li>
<li>推送，必须通过iOS Developer Program Portal获得SSL证书。每个证书限用于一个程序，使用程序的bundle ID作为标识。证书有两种用途的：一种是针对sandbox（用于开发和测试），另外一种针对发布产品。<ol>
<li><strong>sandbox推送是在测试环境时候做的推送</strong>需要：1开发证书2ssl证书3验证性文件。在申请ssl证书的时候需要注意bundle ID的配套，并且不能含有＊等字号。这三个申请下来就可以做推送了。因为我是用的个推，所以在推送的时候需要把申请的ssl证书在钥匙串里面导出为p12文件，然后上传到个推上去，个推会自动检测是开发证书还是生产证书。接下来就可以做推送了。</li>
<li><strong>生产环境推送</strong>需要：1生产证书app store and ad hoc 2生产环境ssl证书3验证性文件。步骤和sandbox类似。记住一定要在codesigning这里配置好。也许有人问，如果想要测试一下生产环境的推送怎么办，好办！只要你利用申请好生产证书app store and ad hoc打一个测试包装到手机里，既可以进行正式环境的测试了。</li>
</ol>
</li>
<li>应用程序的状态：<br>  <strong>Not running</strong>未运行：程序没启动。<br>  <strong>Inactive</strong>未激活：程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。<br>  <strong>Active</strong>激活：程序在前台运行而且接收到了事件。这也是前台的一个正常的模式。<br>  <strong>Backgroud</strong>后台：程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态。<br>  <strong>Suspended</strong>挂起：程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</li>
<li>UIScrollView有个keyboardDismissMode属性，设置成UIScrollViewKeyboardDismissModeOnDrag就可以在拖拽ScrollView的时候自动缩起键盘</li>
<li>iOS开发需要的图片<ol>
<li>产品设计图:可以以6的长宽比 750*1134来设计。这些图片用于描述app是什么样子的，这是app开发人员的开发参考。</li>
<li>产品切图:将设计师将设计稿切成可以用来开发的图。内部设计细节：A. 所有能点击的图片不得小于44px（Retina需要88px）B. 单独存在的部件必须是双数尺寸 C. 两倍图以@2x作为命名后缀</li>
<li>图标icon: 需要四种尺寸：58*58、80*80、120*120、180*180</li>
<li>启动图LaunchImage: 需要四种尺寸：3.5英寸（640*960），4英寸（640*1136），4.7英寸（750*1134），5.5英寸（1242*2208）</li>
<li>引导图: 用户第一次使用app或者app更新之后展示新特性的图</li>
<li>App Store上架图: 用于在App Store上面 介绍app的，需要四种尺寸：3.5英寸（640*960），4英寸（640*1136），4.7英寸（750*1134），5.5英寸（1242*2208）</li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>当手势和touchmoved同时加在uiview上面的时候将会优先的识别手势。滑动手势的识别是需要时间的，当手势在被识别出来以前，touchbegan 依旧会被调用。如果你希望在你的手势被识别的过程中touchbegan不被调用，那么你需要调用delaysTouchesBegan。</li>
<li>修改状态栏字体颜色:只能设置两种颜色，黑色和白色，系统默认黑色。设置为白色方法：<ol>
<li>在plist里面添加Status bar style，值为UIStatusBarStyleLightContent（白色）或UIStatusBarStyleDefault（黑 色）</li>
<li>在Info.plist中设置UIViewControllerBasedStatusBarAppearance 为NO</li>
</ol>
</li>
<li>改善APP的流畅度：<ol>
<li>尽量不要实现drawRect（每次调用该方法时，都要为backing store分配内存，非常消耗CPU）</li>
<li>避免在drawRect：中进行耗费大量CPU资源的工作</li>
<li>尽量少调用setNeedsDisplay:（视图内容变化时才调用）</li>
<li>考虑使用setNeedDisplayInRect: , 传入drawRect:的rect越小，stoke，fill的时间越少, 即使drawRect:是根据视图边界绘制的）</li>
<li>充分利用GPU的资源，直接设置layer的border，shadow，corner，gradient等属性, GPU将会处理这些属性（相反如果GPU紧张，CPU空闲，应由CPU处理，可在drawRect：中实现）]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2016年03月]]></title>
    <link href="http://conanwhf.coding.me/2016/03/31/Tips201603/"/>
    <id>http://conanwhf.coding.me/2016/03/31/Tips201603/</id>
    <published>2016-03-31T09:25:39.000Z</published>
    <updated>2017-05-04T08:55:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIProgressView 的 subviews 是两个 UIImageView，第一个是 TrackTintColor 层（轨道），第二个是 Progress Tint Color 层（进度）</li>
<li>如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 <a href="/">NSAttributedString boundingRectWithSize:options:context:</a> 来计算文本宽高，用 -<a href="/">NSAttributedString drawWithRect:options:context:</a> 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程</li>
<li>为了帮助你发现你的代码的问题，你可以使用Xcode来分析你的代码，帮助你找到出现问题的地方。注意，Xcode分析项目，它会指出每一个潜在的可能出现的问题的地方。从Xcode的 Product菜单选择 Analyze或按 Shift-Command-B.Xcode的将需要片刻的时间，但是当它完成的时候你会在左边的 Issue Navigator看到问题列表。由Analyze发现的问题用蓝色高亮显示</li>
<li>多视图控制器跳转方法<ol>
<li>Modal：<br> 打开：presentViewController<br> 关闭：dismissViewController</li>
<li>Push:需搭配NavigationController使用，采用压栈和出栈的方式<br> 打开：pushViewController<br> 关闭：popViewController</li>
<li>Segue：以上两种方式都可以，如果在打开目标控制器前需要额外处理，可使用perfromSegueWithIdentifier方法。Identifier在storyboard里设置。</li>
</ol>
</li>
<li>设置UIImage的渲染模式：你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：<a id="more"></a></p><span class='source'><blockquote><p>你看到的是非授权版本！爬虫凶猛，请尊重知识产权！</p><p>转载请注明出处：http://conanwhf.coding.me/2016/03/31/Tips201603/</p><p>访问原文「<a href='http://conanwhf.coding.me/2016/03/31/Tips201603/'>开发Tips收集-2016年03月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['conanwhf.github.io', 'conanwhf.coding.me', 'toutiao.io', '0.0.0.0'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
<ol>
<li>UIImageRenderingModeAutomatic  // 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。  </li>
<li>UIImageRenderingModeAlwaysOriginal   // 始终绘制图片原始状态，不使用Tint Color。  </li>
<li>UIImageRenderingModeAlwaysTemplate   // 始终根据Tint Color绘制图片，忽略图片的颜色信息。  </li>
</ol>
</li>
<li>引入了Foundation以后，数组会映射为<a href="/">AnyObject</a>,而值类型会映射了对应的Foundation类型（比如NSString，NSNumber等），也就是AnyObject了</li>
<li>在lldb中一键打开模拟器sandbox路径：<br>  打开/.lldbinit，在里面加入一行：<br>  <code>command alias sb script from subprocess import call; call([&quot;open&quot;, &#39;{0:s}&#39;.format(lldb.frame.EvaluateExpression(&quot;NSHomeDirectory()&quot;)).split(&quot;\&quot;&quot;)[1]]);</code><br>  然后中断时，在lldb里打sb回车，就能打开模拟器当前运行的app的沙箱路径了</li>
<li>UINavigationController导航控制器，是多个界面间跳转的重要元素，可以理解为它存储着多个viewController，它的存储结构是栈，栈的特点是先进后出。</li>
<li>UINavigationController有几个常用的方法：<br>  1：<a href="/">UINavigationController initWithRootViewController：viewController </a> 是指将哪一个视图控制器设置为导航控制器的根视图控制器，即运行是第一次看到的界面。<br>  2：<a href="/">UINavigationController  pushViewController：viewController animated：BOOL</a> 是指将视图控制器送入堆栈，跳转到下一个视图控制器，即下一个界面。<br>  3：<a href="/">UINavigationController popViewControlleranimated：BOOL </a>是指将栈顶的试图控制器移出，即返回上一个界面。<br>  4：<a href="/">UINavigationController popToRootViewControlleranimated：BOOL </a>是指直接返回到根视图控制器，即返回第一个界面。<br>  5：<a href="/">UINavigationController popViewController：viewController  animated：BOOL </a> 跳转到对应的视图控制器，即相应界面。<br>  UINavigationController有一个属性，viewcontrollers，它是一个数组，所有视图控制器都被包含在其中，试图控制器在其中的位置跟UINavigationController的顺序一样。可以通过<a href="/">array objectAtIdenx:index</a>得到相应的视图控制器。</li>
<li>在使用单例模式时一般使用allocWithZone，因为alloc最终还是会调用allocWithZone进行分配空间</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>UIProgressView 的 subviews 是两个 UIImageView，第一个是 TrackTintColor 层（轨道），第二个是 Progress Tint Color 层（进度）</li>
<li>如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 <a href="/">NSAttributedString boundingRectWithSize:options:context:</a> 来计算文本宽高，用 -<a href="/">NSAttributedString drawWithRect:options:context:</a> 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程</li>
<li>为了帮助你发现你的代码的问题，你可以使用Xcode来分析你的代码，帮助你找到出现问题的地方。注意，Xcode分析项目，它会指出每一个潜在的可能出现的问题的地方。从Xcode的 Product菜单选择 Analyze或按 Shift-Command-B.Xcode的将需要片刻的时间，但是当它完成的时候你会在左边的 Issue Navigator看到问题列表。由Analyze发现的问题用蓝色高亮显示</li>
<li>多视图控制器跳转方法<ol>
<li>Modal：<br> 打开：presentViewController<br> 关闭：dismissViewController</li>
<li>Push:需搭配NavigationController使用，采用压栈和出栈的方式<br> 打开：pushViewController<br> 关闭：popViewController</li>
<li>Segue：以上两种方式都可以，如果在打开目标控制器前需要额外处理，可使用perfromSegueWithIdentifier方法。Identifier在storyboard里设置。</li>
</ol>
</li>
<li>设置UIImage的渲染模式：你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.coding.me/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.coding.me/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.coding.me/categories/DevTips/"/>
    
  </entry>
  
</feed>
