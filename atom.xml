<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[iOS开发和七七八八]]></title>
  <subtitle><![CDATA[Conan学习笔记]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://conanwhf.gitcafe.io/"/>
  <updated>2015-12-31T15:52:19.000Z</updated>
  <id>http://conanwhf.gitcafe.io/</id>
  
  <author>
    <name><![CDATA[Conan Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[从打造新闻app学到的(6)：显示html格式文件/数据]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/31/newsreader-6/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/31/newsreader-6/</id>
    <published>2015-12-31T09:32:45.000Z</published>
    <updated>2015-12-31T15:52:19.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我的新闻客户端app进展告一段落，暂停两个礼拜，但之前积攒下来的东西还没有写完，继续总结码字。<br>我从API拿到的数据，具体的新闻信息，使用的是HTML格式，包括图片地址什么的。我不想用WebView，一方面是网络方面的东西我还没怎么接触，怕麻烦、不会，另一方面因为还有标题、评论什么的，最好是能直接解析显示出来，放在一个TextView里面。我的目的是学习，那些第三方库什么的能不用也都不用了，于是找了找，TextView确实能解决这个问题，一般都是OC版的，用Swift写是这样：</p>
<pre><code><span class="keyword">let</span> opt = [<span class="attribute">NSDocumentTypeDocumentAttribute</span>:NSHTMLTextDocumentType]
<span class="keyword">let</span> html =  <span class="string">"&lt;div style=\"background-color:<span class="subst">#F1F1F1</span>; font-size:14px; color:#304182; \n  text-align:center; margin-left:10px; padding-right:10px\"&gt; \n&lt;p&gt;Test &lt;span style=\"font-size:18px; color:<span class="subst">#E88834</span>;\"&gt;测试结束&lt;/span&gt; Tips&lt;/p&gt;\n&lt;/div&gt;"</span>

<span class="keyword">do</span>{
<span class="keyword">let</span> attributedString = <span class="keyword">try</span> NSMutableAttributedString(<span class="attribute">data</span>: html.dataUsingEncoding(NSUnicodeStringEncoding)!, <span class="attribute">options</span>:opt, <span class="attribute">documentAttributes</span>: nil)
post.attributedText = attributedString
}<span class="keyword">catch</span> {<span class="built_in">print</span>(error)}
</code></pre><p>不但能解析字体、颜色等等html标识，有图片的话也是没问题的。不过，事情没这么容易解决……<a id="more"></a>用这种方法显示的页面，图片是不会自动缩放的，好在我们有万能的互联网😃。我在一个前端开发的回答中找到了很赞的答案：在head的配置中将img配置为按固定宽度缩放：</p>
<pre><code><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"><span class="tag">img</span><span class="rules">{<span class="rule"><span class="attribute">max-width</span>:<span class="value"><span class="number">200px</span> <span class="important">!important</span></span></span>;}</span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
</code></pre><p>一试果然OK了，只要我们能够正确地拿到View的宽度就行了。受到这个的启发，我发现我完全可以自己添加各种配置来config整个页面的细节，只要在我拿到的数据前面加上这个配置好的头部就行了：</p>
<pre><code>let img_width = <span class="function"><span class="title">Int</span><span class="params">(post.frame.width)</span></span>
let fontsize = <span class="number">16</span>
<span class="tag">var</span> config = <span class="string">"img{max-width:\(img_width)px !important;}"</span>   <span class="comment">//img style</span>
config.<span class="function"><span class="title">appendContentsOf</span><span class="params">(<span class="string">"body {font-size:\(fontsize)px;}"</span>)</span></span>   <span class="comment">//body style</span>
config.<span class="function"><span class="title">appendContentsOf</span><span class="params">(<span class="string">"h1{font-size: \(fontsize+4)px}"</span>)</span></span>      <span class="comment">//title style</span>
config = <span class="string">"&lt;head&gt;&lt;style&gt;"</span> + config + <span class="string">"&lt;/style&gt;&lt;/head&gt;"</span>
<span class="tag">html</span> = config + <span class="string">"&lt;h1&gt;标题测试&lt;/h1&gt;&lt;hr/&gt;"</span> + html
</code></pre><p>这样一来，不但可以解决图像显示问题，还可以把具体新闻的标题、时间信息、网友评论等等全部糅合到一起，并且字体大小格式Style等随心所欲！😏<br>这里安利一个<a href="http://www.w3school.com.cn/h.asp" target="_blank" rel="external">HTML的教学网站</a>，基本上按照CSS的规则去配置就行了，我完全是开着它照葫芦画瓢，so easy😬！如果你需要看看这篇文章的测试源代码，<a href="https://github.com/conanwhf/swiftplayground/blob/master/UI_test.playground/Pages/Text.xcplaygroundpage/Contents.swift" target="_blank" rel="external">传送门</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我的新闻客户端app进展告一段落，暂停两个礼拜，但之前积攒下来的东西还没有写完，继续总结码字。<br>我从API拿到的数据，具体的新闻信息，使用的是HTML格式，包括图片地址什么的。我不想用WebView，一方面是网络方面的东西我还没怎么接触，怕麻烦、不会，另一方面因为还有标题、评论什么的，最好是能直接解析显示出来，放在一个TextView里面。我的目的是学习，那些第三方库什么的能不用也都不用了，于是找了找，TextView确实能解决这个问题，一般都是OC版的，用Swift写是这样：</p>
<pre><code><span class="keyword">let</span> opt = [<span class="attribute">NSDocumentTypeDocumentAttribute</span>:NSHTMLTextDocumentType]
<span class="keyword">let</span> html =  <span class="string">"&lt;div style=\"background-color:<span class="subst">#F1F1F1</span>; font-size:14px; color:#304182; \n  text-align:center; margin-left:10px; padding-right:10px\"&gt; \n&lt;p&gt;Test &lt;span style=\"font-size:18px; color:<span class="subst">#E88834</span>;\"&gt;测试结束&lt;/span&gt; Tips&lt;/p&gt;\n&lt;/div&gt;"</span>

<span class="keyword">do</span>{
<span class="keyword">let</span> attributedString = <span class="keyword">try</span> NSMutableAttributedString(<span class="attribute">data</span>: html.dataUsingEncoding(NSUnicodeStringEncoding)!, <span class="attribute">options</span>:opt, <span class="attribute">documentAttributes</span>: nil)
post.attributedText = attributedString
}<span class="keyword">catch</span> {<span class="built_in">print</span>(error)}
</code></pre><p>不但能解析字体、颜色等等html标识，有图片的话也是没问题的。不过，事情没这么容易解决……]]>
    
    </summary>
    
      <category term="Text" scheme="http://conanwhf.gitcafe.io/tags/Text/"/>
    
      <category term="iOS" scheme="http://conanwhf.gitcafe.io/tags/iOS/"/>
    
      <category term="Cocoa" scheme="http://conanwhf.gitcafe.io/categories/Cocoa/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发Tips收集-2015年12月]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/31/Tips201512/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/31/Tips201512/</id>
    <published>2015-12-31T09:25:39.000Z</published>
    <updated>2015-12-31T10:55:10.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>所谓闭包，就是函数及其词法作用域的合称</li>
<li>什么不是重构？:<ol>
<li>添加新功能</li>
<li>改变某个类型的公共接口</li>
<li>改变某个类型的行为<br>这些东西都只能叫做重写。有一个很简单的判断方式：<strong>你是否需要改变单元测试</strong>？如果需要的话，那么只就是重写，否则的话才是重构。</li>
</ol>
</li>
<li>设置UIView的背景图片<ol>
<li>将图片作为UIView的背景色，会在生成color时占用大量的内存。如果图片大小不够，就会平铺多张图片，不会去拉伸图片以适应View的大小</li>
<li>在UIView上再添加一个UIImageView显示图片作为UIView的背景图片<a id="more"></a></li>
</ol>
</li>
</ul>
<ol>
<li><p>iOS视图都是一个图层，最先放置的图层就会在最底层，如此最先给UIView添加一个UIImageView就可以作为UIView的背景图片使用</p>
<ol>
<li>其他方式（推荐）</li>
</ol>
<p>NSString <em>path = [[NSBundlemainBundle]pathForResource:@”image”ofType:@”jpg”];<br>UIImage </em>image = [UIImageimageWithContentsOfFile:path];<br>self.view.layer.contents = (id)image.CGImage;</p>
</li>
</ol>
<ul>
<li>代理，又称委托代理（delegate），是iOS中常用的设计一种模式。顾名思义，它是把某个对象要做的事情委托给别的对象去做。那么别的对象就是这个对象的代理，代替它来打理要做的事。反映到程序中， 首先要明确一个对象的委托方是哪个对象，委托所做的内容是什么。在iOS程序设计中，委托通过一种@protocol的方式实现，所以又称为协议。在iOS的SDK里面，UITableView、UITextField等都有用到这种设计模式。</li>
<li>协议，是多个类共享的一个方法列表，在协议中所列出的方法没有响应的实现，由其它类来实现。委托是指给一个对象提供机会对另一对象中的变化做出反应或者相应另一个对象的行为。其基本思想是协同解决问题。</li>
<li>委托模式能够起到两方面的作用：<ol>
<li>代理协助对象主体完成某项操作，将需要定制化的操作通过代理来自定义实现，达到和子类化对象主体同样的作用。</li>
<li>事件监听，代理对象监听对象主体的某些重要事件，对事件做出具体响应或广播事件交给需要作出响应的对象。</li>
</ol>
</li>
<li>NSString是不可变的，意思是他声明的对象我们不可以改变，如果要改变，可以使用它的子类：NSMutableString</li>
<li>高阶函数，指可以将其他函数作为参数或者返回结果的函数。Swift中的函数都是高阶函数</li>
<li>对象是附有行为的数据，而闭包是附有数据的行为。</li>
<li>推测苹果审核团队设备验收选型也会遵循原则：验收最新发布的两个系统版本，两个硬件版本。保证游戏可以在市场占有率最高的两个系统版本及硬件配置上可以流畅运行。</li>
<li>预审组通过细分将预审工作划为3大模块：客户端资源检查、应用内容检查和提审资源检查：<ol>
<li>客户端资源检查：确保客户端内Plist等配置符合苹果要求，不存在多余的Key值enable;</li>
<li>应用内容检查：对应用的内容进行审查，确认无涉及色情、庸俗、暴力、枪支等内容;并对公告文字等筛查，无苹果禁止的字眼等;应用内不包含cdkey兑换，好友邀请及炫耀等苹果最新禁止的内容;</li>
<li>提审资源检查：确保提交的游戏截图、视频符合苹果要求，且截图及视频中没有敏感信息;同时视频截图等均符合苹果的技术要求，帧率分辨率达标.</li>
</ol>
</li>
<li>模块化编程才是正道，尽量使用 struct 和 enum 代替 class，把 extension 和 protocol 当做胶水，把逻辑和行为分开，总结起来就是珍爱POP/VOP，远离OOP</li>
<li>为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</li>
<li>IOS字号转换：<br>  pt=(px/96)*72<br>  1 in = 2.54 cm = 25.4 mm = 72pt<br>  px(Pixel)：像素，相对长度单位。<br>  pt(Point)：点，绝对长度单位。</li>
<li>系统的这些视图控制器，都实现了CALayer的delegate，当vc的根视图的frame发生变化的时候会接受到通知<strong>layoutSublayersOfLayer</strong>，系统的视图控制器会在这里面调用这两个函数来通知其当前的子VC去做布局的工作：<ol>
<li>viewWillLayoutSubviews</li>
<li>viewDidLayoutSubviews</li>
</ol>
</li>
<li>工程Info中：<ol>
<li>CFBundleVersion，标识（发布或未发布）的内部版本号。这是一个单调增加的字符串，包括一个或多个时期分隔的整数。</li>
<li>CFBundleShortVersionString标识应用程序的发布版本号。该版本的版本号是三个时期分隔的整数组成的字符串。第一个整数代表重大修改的版本，如实现新的功能或重大变化的修订。第二个整数表示的修订，实现较突出的特点。第三个整数代表维护版本。该键的值不同于“CFBundleVersion”标识。</li>
<li>Version 对应的就是CFBundleShortVersionString （发布版本号 如当前上架版本为1.1.0  之后你更新的时候可以改为1.1.1）。</li>
<li>Build 对应的是 CFBundleVersion（内部标示，用以记录开发版本的，每次更新的时候都需要比上一次高 如：当前版本是11，下一次就要大于11 比如 12，13 ….10000）</li>
</ol>
</li>
<li>iOS app icon 通用设计规则：<ol>
<li>如果品牌 LOGO 在「颜色」上的展示诉求大于「造型」的话，可用白色背景加品牌 LOGO；<ol>
<li>如果品牌 LOGO 「造型」足够独特具有高识别度，或对「颜色」诉求相对较小的话，则可用品牌色做背景；</li>
<li>如果产品拥有具象的形象物或场景的话，可设计「拟物化」或「 场景化」的图标（游戏图标居多）。</li>
</ol>
</li>
</ol>
</li>
<li>当用户点击屏幕后，首先开启的是查找hit-View的过程。从window开始，给所有直接子视图发hit-Test的消息，直到某一个控件没有子视图了，并且这个触点在这个子视图中，则返回这个控件，于是hit-View找到了。找到hit－View后，view则成为了需要第一个为这个事件提供响应的对象，如果，该对象没有提供事件响应，则该事件对象会向视图的父视图继续传递，如果父视图依然没有提供响应，则继续向上传递，直到传递到UIApplication对象，依然没有处理的话，则抛弃该事件。这个过程叫做响应者链。</li>
<li>Swift 2.1 现在可以在字符串插值中使用双引号。表达式字符串插值现在可以包含字符串了。比如，<code>“My name is \ (attributes[“name”]!)”</code> 现在是有效的。</li>
<li>通过NSURLConnection主要通过四个类进行网络访问：NSURL,NSURLRequest,NSMutableURLRequest,NSURLConnection<ol>
<li>NSURL：请求地址</li>
<li>NSURLRequest：封装一个请求，保存发给服务器的全部数据，包括一个NSURL对象，请求方法、请求头、请求体….</li>
<li>NSMutableURLRequest：NSURLRequest的子类</li>
<li>NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送NSURLRequest的数据给服务器，并收集来自服务器的响应数据</li>
</ol>
</li>
<li>缩放的一般实现步骤 (比如缩放UIScrollView内部的UIImageView)<ol>
<li>设置UIScrollView的delegate为控制器 (self)</li>
<li>控制器遵守UIScrollViewDelegate协议 \<uiscrollviewdelegate\></uiscrollviewdelegate\></li>
<li>控制器实现viewForZoomingInScrollView:方法， 返回需要缩放的子控件</li>
<li>设置最大和最小缩放比例</li>
</ol>
</li>
<li>添加视图代码几个建议：    <ol>
<li>避免调用 layoutSubviews，在 viewDidLayoutSubviews 和 viewDidAppear 中进行 frame 的获取</li>
<li>如果你需要尽早地做一些大动作，推荐在 viewDidLayoutSubviews，此时用户还没有看到 UI，用法可以更灵活</li>
<li>注意 viewDidLayoutSubviews 可能会被多次调用，所以添加元素之类的操作尽量避免在这里做</li>
<li>viewDidAppear 中可以干一切你想干的事情，但是一些需要用户看到的东西例如动画只能在这里做</li>
<li>更推荐把需要做的事情尽量全部放到 viewDidAppear 中来做，让用户尽早地看到界面，这是人机交互的基本原则</li>
</ol>
</li>
<li>对view的layer的修改是发生在约束调整之前的如果layer和约束存在关联的话就需要好好调试了</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这些小Tips为本人近期读书笔记，收集来自网络开发者发布的技术文档，并非原创，共享的目的是为了扩散分享技术，共同进步。<strong>如有侵权不得转载等情况，请联系我告知</strong>，谢谢！</p>
</blockquote>
<ul>
<li>所谓闭包，就是函数及其词法作用域的合称</li>
<li>什么不是重构？:<ol>
<li>添加新功能</li>
<li>改变某个类型的公共接口</li>
<li>改变某个类型的行为<br>这些东西都只能叫做重写。有一个很简单的判断方式：<strong>你是否需要改变单元测试</strong>？如果需要的话，那么只就是重写，否则的话才是重构。</li>
</ol>
</li>
<li>设置UIView的背景图片<ol>
<li>将图片作为UIView的背景色，会在生成color时占用大量的内存。如果图片大小不够，就会平铺多张图片，不会去拉伸图片以适应View的大小</li>
<li>在UIView上再添加一个UIImageView显示图片作为UIView的背景图片]]>
    
    </summary>
    
      <category term="Xcode" scheme="http://conanwhf.gitcafe.io/tags/Xcode/"/>
    
      <category term="iOS - Swift" scheme="http://conanwhf.gitcafe.io/tags/iOS-Swift/"/>
    
      <category term="DevTips" scheme="http://conanwhf.gitcafe.io/categories/DevTips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书清单 2015-12]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/31/ReadingList2015-12/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/31/ReadingList2015-12/</id>
    <published>2015-12-31T02:02:38.000Z</published>
    <updated>2015-12-31T14:15:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="读完的书">读完的书</h2><ol>
<li>老码说编程之玩转Swift江湖<br>这本书从打开到终于看完也断断续续看了好久，算是中文原作开发教程中相当不错的一本。虽然作者写的例子都很中二，有点自以为幽默其实看着很烦，骗稿费之嫌，但讲正事还是蛮能讲到点子上的，看得出来是有实际经验的开发者。作为语法入门，这本书很好，也很适合曾经会一点别的语言的开发者。该知道的基本知识都有，看中实际操作，甚至是从装黑苹果开始手把手教，有自己的东西，不像很多东拼西凑的教材，新手看了摸不着头脑，半天还是连编译器都不会用。<a id="more"></a>
<h2 id="读完的杂志">读完的杂志</h2>没空读</li>
</ol>
<h2 id="其他阅读">其他阅读</h2><ol>
<li>中文传媒精选</li>
<li>每日开发者订阅源&amp;新闻</li>
<li>杂七杂八开发相关网页推送</li>
</ol>
<h2 id="正在读的书">正在读的书</h2><ol>
<li>Swift iOS应用开发实战</li>
<li>Swift与Cocoa框架开发</li>
<li>Swift语言实战精讲</li>
<li>移动应用UI设计</li>
<li>iOS组件与框架　　　</li>
</ol>
<h2 id="中亚买的书_（102-45）">中亚买的书 （<strong>102.45</strong>）</h2><ol>
<li>移动应用UI设计模式（第2版） (图灵交互设计丛书)   <strong>17.5</strong></li>
<li>O’Reilly精品图书系列共21册     <strong>49.99</strong><br>打折，其实有些不会去读。内容包括：<strong>《机器学习：实用案例解析》</strong>、<strong>《利用Python进行数据分析》、《社交网站的数据挖掘与分析（原书第2版）》、《社会网络分析：方法与实践》、《以用户为中心的软件设计：打造用户友好型应用的有效方法和准则》、《编写可读代码的艺术》、《算法精解：C语言描述》、《算法技术手册》、</strong>《JavaScript权威指南（原书第6版）》、<strong>《Python学习手册（原书第4版）》</strong>、《MySQL核心技术手册》、《HTML5应用开发实践指南》、《嵌入式系统设计与实践》、《PaaS程序设计》、<strong>《程序员度量：改善软件团队的分析学》</strong>、《Android应用开发攻略》、《Android程序设计：第2版》、《GAE编程指南》、《精通Hibernate》、《SQL与关系数据库理论：如何编写健壮的SQL代码（第2版）》、《SEO的艺术（原书第2版）》</li>
<li>（图灵社区）HTTP权威指南    <strong>6.0</strong></li>
<li>（图灵社区）机器学习实战     <strong>4.0</strong></li>
<li>（图灵社区）Web性能权威指南    <strong>3.0</strong></li>
<li>加拿大语文读本(英汉双语版)    <strong>3.99</strong></li>
<li>澳大利亚语文（套装共六册)    <strong>4.99</strong></li>
<li>美国语文：美国中学课文经典读本(英汉双语版)    <strong>2.99</strong></li>
<li>诺贝尔经济学奖经典收藏版（自由选择、生活中的经济学、增长的极限）    <strong>9.99</strong></li>
</ol>
<h2 id="总结">总结</h2><p>这个月可以说没有读书。双十二打折的时候倒是剁了些电子版，只是现在亚马逊的电子书特别是套装打折很有诚意，质量却让人无语。比如这次买的O’Reilly套装，连二级目录都没有，不只是整本书的目录没有做好，而是哪怕你去到了某本书，也没有任何目录！这就有点不靠谱了，只能在电脑上看看，用鼠标勉强翻个页，而且完全不知道这本书的结构，只能从头看到尾。😡另一方面，现在我买的书确实看不完，自己对亚马逊来来回回打折的那些书也有点厌倦了，接下来恐怕会买得比较少。<br>别说看别的书了，最近就算是kindle的每日推送我都是匆匆看完，家里中文传媒精选的读书会也好久没开了，整天埋头对着Xcode（其实玩的时候也不少啦，只是没读书），书桌上堆着的也都是开发书籍。iOS开发要学的东西太多，我又有整理癖，每次写写就要停下来整理总结一下，加上日常生活的各种杂事，感觉学完自己的那一亩三分地遥遥无期啊！年底了，今年过得太懒散玩了十个月学了两个月，实在不好意思写年终总结，明年努力吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="读完的书">读完的书</h2><ol>
<li>老码说编程之玩转Swift江湖<br>这本书从打开到终于看完也断断续续看了好久，算是中文原作开发教程中相当不错的一本。虽然作者写的例子都很中二，有点自以为幽默其实看着很烦，骗稿费之嫌，但讲正事还是蛮能讲到点子上的，看得出来是有实际经验的开发者。作为语法入门，这本书很好，也很适合曾经会一点别的语言的开发者。该知道的基本知识都有，看中实际操作，甚至是从装黑苹果开始手把手教，有自己的东西，不像很多东拼西凑的教材，新手看了摸不着头脑，半天还是连编译器都不会用。]]>
    
    </summary>
    
      <category term="BookList" scheme="http://conanwhf.gitcafe.io/tags/BookList/"/>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.gitcafe.io/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift中数据类型精度的一点探索]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/30/precision/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/30/precision/</id>
    <published>2015-12-30T09:14:35.000Z</published>
    <updated>2015-12-31T10:05:12.000Z</updated>
    <content type="html"><![CDATA[<p>昨天整理code，顺手写了个UIColor和16进制RGB表示的颜色转换。由于UIColor中的RGBA范围是0..1，所以里面用到了一些乘除法，和强制类型转换：</p>
<pre><code>CGFloat<span class="list">(<span class="keyword">Float</span><span class="list">(<span class="keyword">r</span>)</span>/255.<span class="number">0</span>)</span>
Int<span class="list">(<span class="keyword">r*255</span>)</span>
</code></pre><p>写完以后测试了一下貌似没什么问题，就睡觉去了。后来突然想到，1/255并不是一个有理数，而且<strong>Int()做的是取地板而不是四舍五入</strong>，会不会在这种转换的过程中因为精度的问题造成数据错误呢？于是写了一小段测试代码：</p>
<pre><code>//精度测试，确认转换不会丢失信息
<span class="keyword">let</span> a  = Array.init(<span class="number">0</span>...<span class="number">255</span>)
<span class="keyword">let</span> b = a.<span class="keyword">map</span>{ CGFloat(Float(<span class="variable">$0</span>)/<span class="number">255.0</span>) }
<span class="keyword">let</span> c = b.<span class="keyword">map</span>{ Int(<span class="variable">$0</span>*<span class="number">255</span>) }
a.elementsEqual(c)
</code></pre><p>还好结果是True，这个转换过程并没有出错的机会。但我怎么可能就此罢休？通过修改a的初始化条件发现，乘除255的时候，在算257的时候就出错了。按理说1/255并不是一个很小的数字，如果准确的话，16位的存储结构是可以保留足够信息的，所以我尝试这打印了一下各个数据类型的精度：</p>
<pre><code><span class="function"><span class="title">sizeof</span><span class="params">(Int)</span></span>*<span class="number">8</span><span class="comment">//64</span>
<span class="function"><span class="title">sizeof</span><span class="params">(UInt)</span></span>*<span class="number">8</span><span class="comment">//64</span>
<span class="function"><span class="title">sizeof</span><span class="params">(UInt16)</span></span>*<span class="number">8</span><span class="comment">//16</span>
<span class="function"><span class="title">sizeof</span><span class="params">(Int32)</span></span>*<span class="number">8</span><span class="comment">//32</span>

<span class="function"><span class="title">sizeof</span><span class="params">(Float)</span></span>*<span class="number">8</span><span class="comment">//32</span>
<span class="function"><span class="title">sizeof</span><span class="params">(Double)</span></span>*<span class="number">8</span><span class="comment">//64</span>
<span class="function"><span class="title">sizeof</span><span class="params">(CGFloat)</span></span>*<span class="number">8</span><span class="comment">//64</span>

<span class="function"><span class="title">sizeof</span><span class="params">(Character)</span></span>*<span class="number">8</span><span class="comment">//72</span>
<span class="function"><span class="title">sizeof</span><span class="params">(String)</span></span>*<span class="number">8</span><span class="comment">//192</span>
<span class="function"><span class="title">sizeof</span><span class="params">(CGRect)</span></span>*<span class="number">8</span><span class="comment">//256</span>
<span class="function"><span class="title">sizeof</span><span class="params">(UIColor)</span></span>*<span class="number">8</span><span class="comment">//64</span>
</code></pre><p>第一组相当的make sense，Int默认就是64位；第二组是实数部分，令我惊讶的是原来<em>CGFloat</em>也是64位的，而<em>Float</em>反而比它差只有32位。第三组的结果比较值得玩味：Swift里面的<em>String</em>搞得比较复杂，是什么都不奇怪，但我以为<em>Character</em>至少会是8，结果却是72；<em>UIColor</em>本身是由4个<em>CGFloat</em>构成，其size却不是4倍的<em>CGFloat</em>；倒是<em>CGRect</em>比较可以解释，因为它是<em>CGSize</em>和<em>CGPoint</em>组合而成，实质上也是4个<em>CGFloat</em>。<a id="more"></a><br>也就是说，sizeof()这个函数，在对某些类型如String等操作的时候，结果是这个结构体所占用的内存空间大小；而对某些类型如Int等，即使它们也是一个结构体（我们已经知道在Swift中所有的类型其实都是结构体），给出的结果却是这个类型所表示的值的内存占用。令人感兴趣的是，在一堆UIXXX的结构体中，为什么独独CGFloat会作为数值类型来看待呢？于是我去翻了翻CGFloat的头文件，发现这家伙真面目是这样的：</p>
<pre><code><span class="keyword">public</span> struct CGFloat {
<span class="comment">/// The native type used to store the CGFloat, which is Float on</span>
<span class="comment">/// 32-bit architectures and Double on 64-bit architectures.</span>
<span class="keyword">public</span> typealias NativeType = <span class="typename">Double</span>
<span class="keyword">public</span> init()
<span class="keyword">public</span> init(_ value: <span class="typename">Float</span>)
<span class="keyword">public</span> init(_ value: <span class="typename">Double</span>)
<span class="comment">/// The native value.</span>
<span class="keyword">public</span> <span class="variable"><span class="keyword">var</span> native</span>: NativeType
}
</code></pre><p>真相大白，所以CGFloat在内部实现就是个Double，头文件后面还有很长的各种协议……也就是说，其实CGFloat是可以直接做运算的？试了试，果然没错。那么<code>CGFloat(Float(r)/255.0)</code>这种计算就不妥了，人家一个好好的64位，给生生转成32位了，改成<code>CGFloat(r)/255.0</code>即可。<br>回到最开始的问题—精度。为了便于测试，我写了个函数：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">precisionTest</span> <span class="params">(div: CGFloat)</span></span> {
<span class="keyword">var</span> a : <span class="type">Int</span> = <span class="number">0</span>
<span class="keyword">var</span> b : <span class="type">CGFloat</span>
<span class="keyword">var</span> <span class="built_in">c</span> : <span class="type">Int</span>
repeat {
a = a + <span class="number">1</span>
<span class="comment">//b = CGFloat(Float(a) / Float(div)) // for Float</span>
b = <span class="type">CGFloat</span>(a) / div    <span class="comment">// for CGFloat</span>
<span class="built_in">c</span> = <span class="type">Int</span>(b * div)
}<span class="keyword">while</span> <span class="built_in">c</span> == a
<span class="built_in">print</span>(<span class="string">"div=<span class="subst">\(div)</span>, a=<span class="subst">\(a)</span>, b=<span class="subst">\(b)</span> @<span class="subst">\(b*div)</span>, c=<span class="subst">\(<span class="built_in">c</span>)</span> @ <span class="subst">\(Double(<span class="built_in">c</span>)</span>/Double(div))"</span>)
}
</code></pre><p>这个函数会从1开始找，计算在div(除数)固定的情况下，第一个将常数先除再乘后丢失精度的case。之前我们已经知道了在div=255且中间变量使用Float的时候，<code>257/255*255 != 257</code>，但中间变量换成CGFloat之后，程序跑到10000+还没找到错误，被我手动停了👻。另外随机试了几个数字，都是使用CGFloat比Float出错概率要小，<strong>这也印证了这两个类型的精度大小区别</strong>，只是这种错误的结果随机性比较高，有的用1就已经出错，有的跑了很久也没事，跟div的数值变化没有什么关联性，也就是说这种错误并不全是保存精度大小和Int()截取而造成的。<br>那么大概是因为除法吧？接下来我固定使用Float（更容易出错便于观察结果），调整不同的div数值来测试，发现：</p>
<ol>
<li>1，2，4，8，16，…，512，1024…这些div永远不会出错</li>
<li>除了2^n作为div，其他数字都会出错（只测试了10000以内的）</li>
<li>出错的数字都是奇数，但没什么特别明显的规律，跟div的相关性也不大</li>
<li>有个别出错特别晚的div（超过div本身的数值），他们都可被分解成2^n1+2^n2+2^n3…+2^nm-1<br>综上所述，在我所测试的这个问题上，结果的误差主要影响还是因为除法。<strong>除法实现到最底层（硬件层），终究还是靠电子元器件，也就归结到了二进制计算。所以那些2^n作为除数，只靠移位操作就能解决，没有精度损失；而其他数字则是有一套算法，这也和我们所知的计算机原理相吻合。</strong>至于具体怎么算的……如果我搞清楚了也许就能解释3和4了吧……😌（其实我对着打印信息研究了好半天，但数学不行实在研究不出来个结果😭）<br>以上就是我对Swift中数据类型精度的一些相关探索，如果你想看测试代码，在<a href="https://github.com/conanwhf/swiftplayground/blob/master/Play.playground/Pages/Precision.xcplaygroundpage/Contents.swift" target="_blank" rel="external">这里</a>（然而其实真没啥好看）</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天整理code，顺手写了个UIColor和16进制RGB表示的颜色转换。由于UIColor中的RGBA范围是0..1，所以里面用到了一些乘除法，和强制类型转换：</p>
<pre><code>CGFloat<span class="list">(<span class="keyword">Float</span><span class="list">(<span class="keyword">r</span>)</span>/255.<span class="number">0</span>)</span>
Int<span class="list">(<span class="keyword">r*255</span>)</span>
</code></pre><p>写完以后测试了一下貌似没什么问题，就睡觉去了。后来突然想到，1/255并不是一个有理数，而且<strong>Int()做的是取地板而不是四舍五入</strong>，会不会在这种转换的过程中因为精度的问题造成数据错误呢？于是写了一小段测试代码：</p>
<pre><code>//精度测试，确认转换不会丢失信息
<span class="keyword">let</span> a  = Array.init(<span class="number">0</span>...<span class="number">255</span>)
<span class="keyword">let</span> b = a.<span class="keyword">map</span>{ CGFloat(Float(<span class="variable">$0</span>)/<span class="number">255.0</span>) }
<span class="keyword">let</span> c = b.<span class="keyword">map</span>{ Int(<span class="variable">$0</span>*<span class="number">255</span>) }
a.elementsEqual(c)
</code></pre><p>还好结果是True，这个转换过程并没有出错的机会。但我怎么可能就此罢休？通过修改a的初始化条件发现，乘除255的时候，在算257的时候就出错了。按理说1/255并不是一个很小的数字，如果准确的话，16位的存储结构是可以保留足够信息的，所以我尝试这打印了一下各个数据类型的精度：</p>
<pre><code><span class="function"><span class="title">sizeof</span><span class="params">(Int)</span></span>*<span class="number">8</span><span class="comment">//64</span>
<span class="function"><span class="title">sizeof</span><span class="params">(UInt)</span></span>*<span class="number">8</span><span class="comment">//64</span>
<span class="function"><span class="title">sizeof</span><span class="params">(UInt16)</span></span>*<span class="number">8</span><span class="comment">//16</span>
<span class="function"><span class="title">sizeof</span><span class="params">(Int32)</span></span>*<span class="number">8</span><span class="comment">//32</span>

<span class="function"><span class="title">sizeof</span><span class="params">(Float)</span></span>*<span class="number">8</span><span class="comment">//32</span>
<span class="function"><span class="title">sizeof</span><span class="params">(Double)</span></span>*<span class="number">8</span><span class="comment">//64</span>
<span class="function"><span class="title">sizeof</span><span class="params">(CGFloat)</span></span>*<span class="number">8</span><span class="comment">//64</span>

<span class="function"><span class="title">sizeof</span><span class="params">(Character)</span></span>*<span class="number">8</span><span class="comment">//72</span>
<span class="function"><span class="title">sizeof</span><span class="params">(String)</span></span>*<span class="number">8</span><span class="comment">//192</span>
<span class="function"><span class="title">sizeof</span><span class="params">(CGRect)</span></span>*<span class="number">8</span><span class="comment">//256</span>
<span class="function"><span class="title">sizeof</span><span class="params">(UIColor)</span></span>*<span class="number">8</span><span class="comment">//64</span>
</code></pre><p>第一组相当的make sense，Int默认就是64位；第二组是实数部分，令我惊讶的是原来<em>CGFloat</em>也是64位的，而<em>Float</em>反而比它差只有32位。第三组的结果比较值得玩味：Swift里面的<em>String</em>搞得比较复杂，是什么都不奇怪，但我以为<em>Character</em>至少会是8，结果却是72；<em>UIColor</em>本身是由4个<em>CGFloat</em>构成，其size却不是4倍的<em>CGFloat</em>；倒是<em>CGRect</em>比较可以解释，因为它是<em>CGSize</em>和<em>CGPoint</em>组合而成，实质上也是4个<em>CGFloat</em>。]]>
    
    </summary>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从打造新闻app学到的(5)：解决TableCell调用segue的时序问题]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/23/newsreader-5/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/23/newsreader-5/</id>
    <published>2015-12-23T02:56:35.000Z</published>
    <updated>2015-12-24T06:01:32.000Z</updated>
    <content type="html"><![CDATA[<p>在从TableCell跳转到具体新闻页面的时候，我遇到了一个问题：整个流程的时序跟我想的不太一样。因为我需要在点击Cell的时候知道这是哪个Cell，再将它作为参数传递给下一个View，所以我实现了函数<strong> didSelectRowAtIndexPath</strong>，然后设好一个private的变量，供prepareForSegue调用。可是事实上的流程却变成了：</p>
<blockquote>
<p>prepareForSegue() -> next.viewDidLoad() -> didSelectRowAtIndexPath()</p>
</blockquote>
<p>也就是说当Cell的点击发生，会先调用StroyBaord中设置的Segue，新的View初始化完成后再回调didSelectRowAtIndexPath，导致我在viewDidLoad()中拿不到想要的数据。<br>在网上搜了一下，有人也遇到了同样的问题，他的解决方法是：<br>1) 将 ->NextView的Segue改为 ->NextViewController(NextView的代理)<br>2) 在StoryBoard中配置此Segue的ID为<strong>“ABC”</strong><br>3) 在didSelectRowAtIndexPath()准备好数据之后手动调用转场：</p>
<pre><code><span class="comment">//跳转到下一个页面，识别“ABC”</span>
self.<span class="function"><span class="title">performSegueWithIdentifier</span><span class="params">(“ABC”, sender: self)</span></span>
</code></pre><p>实测这个方法是有效的，不过我总感觉不够漂亮……于是打开Dash把所有tableView()的相关Callback都过了一遍，挑出几个加打印实测，<a id="more"></a>找到了这个：<strong>willSelectRowAtIndexPath</strong><br>看起来这是一个专门给人做点特殊需求的API，如果我们将其返回nil而不是当前的Index：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView,  willSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">NSIndexPath</span>?    {
<span class="comment">//TODO anything you want</span>
<span class="keyword">return</span> <span class="literal">nil</span>
<span class="comment">//return indexPath</span>
}
</code></pre><p>那么无论你怎么点击，Cell都不会再响应任何selected事件了……😈虽然没有做更多的尝试，但我猜如果这时候返回一个修改过的indexPath也是可以做到的，比如怎么点都是同一个结果之类……😏<br>说回正事。现在我们可以把数据的获得放到willSelectRowAtIndexPath()中了，流程变成了：</p>
<blockquote>
<p>willSelectRowAtIndexPath() ，<em>获得要传递的数据</em></p>
<p>-> prepareForSegue() ，<em>传递数据的准备</em></p>
<p>-> next.viewDidLoad()，<em>通过Segue调用新的View</em></p>
<p>-> [如果你依然需要] didSelectRowAtIndexPath()</p>
</blockquote>
<p>问题解决!😄</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在从TableCell跳转到具体新闻页面的时候，我遇到了一个问题：整个流程的时序跟我想的不太一样。因为我需要在点击Cell的时候知道这是哪个Cell，再将它作为参数传递给下一个View，所以我实现了函数<strong> didSelectRowAtIndexPath</strong>，然后设好一个private的变量，供prepareForSegue调用。可是事实上的流程却变成了：</p>
<blockquote>
<p>prepareForSegue() -> next.viewDidLoad() -> didSelectRowAtIndexPath()</p>
</blockquote>
<p>也就是说当Cell的点击发生，会先调用StroyBaord中设置的Segue，新的View初始化完成后再回调didSelectRowAtIndexPath，导致我在viewDidLoad()中拿不到想要的数据。<br>在网上搜了一下，有人也遇到了同样的问题，他的解决方法是：<br>1) 将 ->NextView的Segue改为 ->NextViewController(NextView的代理)<br>2) 在StoryBoard中配置此Segue的ID为<strong>“ABC”</strong><br>3) 在didSelectRowAtIndexPath()准备好数据之后手动调用转场：</p>
<pre><code><span class="comment">//跳转到下一个页面，识别“ABC”</span>
self.<span class="function"><span class="title">performSegueWithIdentifier</span><span class="params">(“ABC”, sender: self)</span></span>
</code></pre><p>实测这个方法是有效的，不过我总感觉不够漂亮……于是打开Dash把所有tableView()的相关Callback都过了一遍，挑出几个加打印实测，]]>
    
    </summary>
    
      <category term="Segue" scheme="http://conanwhf.gitcafe.io/tags/Segue/"/>
    
      <category term="iOS" scheme="http://conanwhf.gitcafe.io/tags/iOS/"/>
    
      <category term="Cocoa" scheme="http://conanwhf.gitcafe.io/categories/Cocoa/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从打造新闻app学到的(4)：使用Segue在ViewController之间传递数据]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/22/newsreader-4/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/22/newsreader-4/</id>
    <published>2015-12-22T13:14:35.000Z</published>
    <updated>2015-12-23T16:15:54.000Z</updated>
    <content type="html"><![CDATA[<p>要实现不同界面的跳转，简单的办法是在StroyBoard中直接拖动控件。<strong>按住^</strong>将触发跳转的控件拖到待触发的View中，松开鼠标在弹出的菜单中选择对应的选项（跳转为View），一个segue(大致译为“转场、过渡”)就完成了：<br><img src="http://7xkzuv.com1.z0.glb.clouddn.com/img_create_segue.gif" alt=""><br>而要实现在两个ViewController之间传数据，在这种建立segue的情况下也很简单。假设我们需要在从ViewA（ControllerA代理）跳转去ViewB（ControllerB代理）时传递一个Int变量id，那么先要在ControllerB中定义.id属性，然后在ControllerA中实现：</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">prepareForSegue</span><span class="params">(segue: UIStoryboardSegue, sender: AnyObject?)</span></span> {
<span class="comment">//print(“this is segue \(segue.identifier), \(sender.debugDescription)")</span>
<span class="type">ControllerB</span>.id = passValue
}
</code></pre><p>这样的方式适合参数比较少或者已经打包的情况，缺点是必须将待传递的参数在ControllerB中暴露出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>要实现不同界面的跳转，简单的办法是在StroyBoard中直接拖动控件。<strong>按住^</strong>将触发跳转的控件拖到待触发的View中，松开鼠标在弹出的菜单中选择对应的选项（跳转为View），一个segue(大致译为“转场、过渡”)就完成了：<br><img]]>
    </summary>
    
      <category term="Segue" scheme="http://conanwhf.gitcafe.io/tags/Segue/"/>
    
      <category term="StroyBoard" scheme="http://conanwhf.gitcafe.io/tags/StroyBoard/"/>
    
      <category term="iOS" scheme="http://conanwhf.gitcafe.io/tags/iOS/"/>
    
      <category term="Cocoa" scheme="http://conanwhf.gitcafe.io/categories/Cocoa/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从打造新闻app学到的(3)：让自定义的类可排序]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/21/newsreader-3/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/21/newsreader-3/</id>
    <published>2015-12-21T11:14:35.000Z</published>
    <updated>2015-12-23T16:25:55.000Z</updated>
    <content type="html"><![CDATA[<p>假如你有一个自定义类的列表，想要对它排序，怎么办？在新闻APP中，我的新闻列表就是一个自定义class的数组，用户一会儿要最新、一会儿要更多旧数据的可能性，使得它需要按时间有序。我是懒人，自己一个个拿key比较写起来觉得好麻烦，Swift这么高级的语言，应该有别的更好的办法才对！又祭出官方文档找灵感，然后看到了：<strong>Comparable</strong>。<br>Comparable是一个协议，遵守这个协议的所有类型，都可以直接比大小。而对于自定义的类型，遵守它就行了：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">Comparable</span> </span>{
    <span class="keyword">var</span> key : <span class="type">Int</span> = <span class="number">0</span>
}
<span class="comment">//在Class定义之外实现</span>
<span class="func"><span class="keyword">func</span> <span class="generics">&lt; (left: MyClass, right: MyClass) -&gt;</span> <span class="title">Bool</span> </span>{
    <span class="keyword">return</span> <span class="keyword">left</span>.key &lt; <span class="keyword">right</span>.key
}
<span class="func"><span class="keyword">func</span> == <span class="params">(<span class="keyword">left</span>: MyClass, <span class="keyword">right</span>: MyClass)</span></span> -&gt; <span class="type">Bool</span>{
    <span class="keyword">return</span> <span class="keyword">left</span>.key == <span class="keyword">right</span>.key
}   
</code></pre><p>我们只要实现<strong>\&lt;</strong>和<strong>== </strong>两个函数，编译器会自动帮我们判断>和!=的情况。于是，现在这样的排序或者比较都是合法的了：超easy!😄</p>
<pre><code><span class="tag">var</span> <span class="tag">a</span> : MyClass = []
<span class="comment">//TODO：a填了一些数据之后……</span>
<span class="tag">a</span>.<span class="function"><span class="title">sort</span><span class="params">()</span></span>
<span class="tag">a</span>[<span class="number">1</span>] &gt; <span class="tag">a</span>[<span class="number">0</span>]
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>假如你有一个自定义类的列表，想要对它排序，怎么办？在新闻APP中，我的新闻列表就是一个自定义class的数组，用户一会儿要最新、一会儿要更多旧数据的可能性，使得它需要按时间有序。我是懒人，自己一个个拿key比较写起来觉得好麻烦，Swift这么高级的语言，应该有别的更好的办法]]>
    </summary>
    
      <category term="Class" scheme="http://conanwhf.gitcafe.io/tags/Class/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从打造新闻app学到的(2)：定义类中的只读属性]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/21/newsreader-2/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/21/newsreader-2/</id>
    <published>2015-12-21T09:14:35.000Z</published>
    <updated>2015-12-23T15:19:05.000Z</updated>
    <content type="html"><![CDATA[<p>在定义各种接口的过程中，我碰到了这样一个问题：我希望定义一个只读的属性，却找不到合适的前缀（原谅我是Class白痴）。翻了一遍Class的相关文档，找到了个曲线救国的办法：计算属性。<br>所谓的计算属性，就是自己定义一个属性的名字和get/set方法，外人看不见get/set的实现，只能看作是一个普通属性来使用。而如果只实现了get部分，这个属性对外而言就是只读的了。<br>我的数据结构大致这样：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">myclass</span> {</span>
    <span class="keyword">private</span> var data =  ( <span class="string">api :</span> typeX, <span class="string">list:</span>  typeY,  <span class="string">post:</span> typeZ,  <span class="string">channel:</span> typeA) (xxx, <span class="string">list:</span> yyy, <span class="string">post:</span> zzz, .news)
}
</code></pre><p>我想要把这一组相关数据打包成元组使用，又只想把其中某些暴露出来，并且部分是只读，那么就将其设成private并且在类中实现：</p>
<pre><code><span class="built_in">var</span> <span class="built_in">list</span> : typeY {<span class="comment">//只有get，实现只读封装</span>
    get {
        <span class="keyword">return</span> <span class="built_in">data</span><span class="built_in">.</span><span class="built_in">list</span>
    }
}

<span class="built_in">var</span> ch : typeA {
    get {
        <span class="keyword">return</span> <span class="built_in">data</span><span class="built_in">.</span>channel
    }
    <span class="built_in">set</span> (channel) {<span class="comment">//这次可读写了</span>
        <span class="built_in">data</span><span class="built_in">.</span>channel = channel
    }
}
</code></pre><p>现在，外部可以用myclass.list来获取list，或者用myclass.ch来改变channel了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在定义各种接口的过程中，我碰到了这样一个问题：我希望定义一个只读的属性，却找不到合适的前缀（原谅我是Class白痴）。翻了一遍Class的相关文档，找到了个曲线救国的办法：计算属性。<br>所谓的计算属性，就是自己定义一个属性的名字和get/set方法，外人看不见get/s]]>
    </summary>
    
      <category term="Class" scheme="http://conanwhf.gitcafe.io/tags/Class/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从打造新闻app学到的(1)：抽象概念，定义好的数据结构]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/20/newsreader-1/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/20/newsreader-1/</id>
    <published>2015-12-20T09:14:35.000Z</published>
    <updated>2015-12-23T15:18:57.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>怎么从JSON拿数据学会了，那么接下来就是正式打造一个自己的新闻客户端了。虽然我Swift语法还没认真学完，但实在是心痒痒，就跳过一点基础，先来个实战吧！经过这个礼拜，我的APP也基本成型了。网上关于怎么做一个新闻客户端的例子很多，我就不赘述了，只是把过程中碰到的一些小问题和心得、我自己无法很容易搜到完美答案的写一写。过程中的弯路肯定没少走，但经验的收获也是不少的。</p>
</blockquote>
<p>关于这个APP使用的数据结构，其实我是重构过的。新闻一般都是有两种数据源：新闻列表(List)，和单条新闻(Post)详细信息。开始我在playground写了对应的List&amp;Post数据结构，以及处理数据的函数。打印测试成功后，往project里面放的时候……不忍直视！作为一个初学者，我往viewDidLoad()里面塞了几乎所有的流程调用，以至于第一次运行成功在模拟器中看到数据的时候，我最大的感觉不是兴奋，而是我怎么把code写得这么丑陋！😖<br><strong>功能不行可以再学习怎么做，但代码太丑是真真正正不能忍！</strong>我曾经的经验如是告诉我。我试着模块化各种数据和过程，一番思考和尝试后，变成了现在的结构：<br><img src="http://7xkzuv.com1.z0.glb.clouddn.com/img_wxc_data.png" alt="" title="新闻APP拿取数据框图"><br>DataManager是整个业务的最顶层类，它提供了很少的几个接口供ViewController使用：请求最新列表、请求更多列表数据、请求某个新闻、少量设置，并且设置也都是有default值的。考虑到将来有可能支持更多的新闻网站，GetURL和数据解析部分也是独立可更换的模块。在数据结构部分，我定义了一个Item类型，包括几个通用的属性，以及几个通用函数的实现，然后让ListItem，PostItem，CommentItem分别继承。这样既逻辑清晰，减少重复代码，也便于调试。所有上层不需要知道的参数都封装在内部，只有一个Manger和它的API，以及几个配置属性暴露在外。<br>也许这样的抽象定义过程，对于老手来说是不值一提的基础，就像吃饭要先煮饭一样简单。但我想对于刚刚接触APP开发的新人来说，如何更好的定义数据结构和API，恰当地抽象各种概念，还是值得多多思考的功课。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>怎么从JSON拿数据学会了，那么接下来就是正式打造一个自己的新闻客户端了。虽然我Swift语法还没认真学完，但实在是心痒痒，就跳过一点基础，先来个实战吧！经过这个礼拜，我的APP也基本成型了。网上关于怎么做一个新闻客户端的例子很多，我就不赘述了，只]]>
    </summary>
    
      <category term="iOS开发杂项" scheme="http://conanwhf.gitcafe.io/categories/iOS%E5%BC%80%E5%8F%91%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新配置了多说]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/16/creatDuoshuo/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/16/creatDuoshuo/</id>
    <published>2015-12-16T05:35:25.000Z</published>
    <updated>2015-12-23T12:10:49.000Z</updated>
    <content type="html"><![CDATA[<p>测试一下！配置好像相当简单嘛！:) 而且好像不是用域名而是ID单匹配的，自己本地的测试服务也能用，所以像我这种两个域名的配置起来完全无障碍，注册、改config一站式完成，赞！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>测试一下！配置好像相当简单嘛！:) 而且好像不是用域名而是ID单匹配的，自己本地的测试服务也能用，所以像我这种两个域名的配置起来完全无障碍，注册、改config一站式完成，赞！</p>
]]>
    </summary>
    
      <category term="Life &amp; Other" scheme="http://conanwhf.gitcafe.io/categories/Life-Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用原生库解析JSON]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/15/swift_json/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/15/swift_json/</id>
    <published>2015-12-15T12:14:35.000Z</published>
    <updated>2015-12-23T16:16:45.000Z</updated>
    <content type="html"><![CDATA[<p>（挖坑自己跳系列四）<br>以为实现了xml的解析，我就能拿到所有想要的数据，可是经过几次尝试，发现有的API失效了！😱无论我怎么尝试，有的数据就是拿不到，苦恼了好久，灵光一闪：前阵子买的surge可以派上用场了！不知道surge是啥的我给解释一下，是个iOS App，利用iOS9的特性能给设备做个全局代理，前阵子大家纷纷用来流畅FQ，已下架。对我来说，用来过滤下广告正好，偶尔还能看看http log。<br>看了下自己手机上的第三方客户端，request居然直接是网页，看来是直接解析网页了，这个太高深、放弃；只好去下载官方客户端来看，在网页看同样的请求，返回居然换成JSON了……😥<br>还能说啥呢，去找找JSON怎么解析呗！这次看了看，似乎比XML简单多了……先拿数据：</p>
<pre><code><span class="built_in">let</span> url = NSURL(string:TESTURL)!
guard data = NSData(contentsOfURL: url)  <span class="keyword">else</span>{
    <span class="built_in">print</span>(<span class="string">"Can't get any data"</span>)
    <span class="built_in">exit</span>(<span class="number">0</span>)
}
</code></pre><p>然后解析出来：<a id="more"></a></p>
<pre><code><span class="keyword">do</span> {
    let json = <span class="keyword">try</span> NSJSONSerialization.JSONObjectWithData(data, <span class="keyword">options</span>: NSJSONReadingOptions.MutableContainers)
    <span class="comment">// TODO：</span>
} <span class="keyword">catch</span> {
    <span class="keyword">print</span>(<span class="string">"JSONObjectWithData: \(error)"</span>)
}
</code></pre><p>问题是，明明看起来正常的数据，每次解析都报错！开始以为是unicode编码的问题（我的数据里有中文），一头扎进编码里……后来花了好长时间Debug，才发现关键在于我拿到的数据在头尾多了个“CALLBACK({正常的JSON数据})”！手动处理去掉了这个壳，数据才终于正常了……关于这个数据形式，我原本揣测是服务器和官方客户端之间的约定，心里暗骂了他们好多遍（原谅我的无知吧），直到偶然看到了这一段：</p>
<blockquote>
<p>为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
</blockquote>
<p>这样就解释了为什么自带的库不能处理这种情况（_非正式协议_），以及为何我用的在线JSON转换器可以处理（_都是喜欢偷偷商量个后门程序员干的哇！_），之前我连啥是JSON都没见过，没注意到只怪自己读书少……😭<br>言归正传。当JSON数据解析完成后，就可以直接拿来用了。API已经返回一个层层嵌套的完整数据字典，供你享用，这一点可比XML方便多了。我们要做的就是强制转换，然后拿数据（当然你也许需要转化为自己的数据结构，称为_模型化_，此处不表）。以简单的数据为例：</p>
<pre><code>{
        "<span class="attribute">person</span>": <span class="value">{
            "<span class="attribute">employees</span>": 
            <span class="value">[
                {"<span class="attribute">id</span>": <span class="value"><span class="number">1</span></span>, "<span class="attribute">firstName</span>": <span class="value"><span class="string">"Bill"</span></span>, "<span class="attribute">lastName</span>": <span class="value"><span class="string">"Gates"</span></span>},
                {"<span class="attribute">id</span>": <span class="value"><span class="number">2</span></span>, "<span class="attribute">firstName</span>": <span class="value"><span class="string">"George"</span></span>, "<span class="attribute">lastName</span>": <span class="value"><span class="string">"Bush"</span></span>}
            ]</span>,
        "<span class="attribute">boss</span>": <span class="value">[
                {"<span class="attribute">id</span>": <span class="value"><span class="number">1</span></span>, "<span class="attribute">firstName</span>": <span class="value"><span class="string">"Bill"</span></span>, "<span class="attribute">lastName</span>": <span class="value"><span class="string">"Gates"</span></span>}
        ]
</span>}</span>}
</code></pre><p>强制转换成字典：　</p>
<pre><code>let dic : NSDictionary? = json[<span class="link_label">"person"</span>](<span class="link_url"></span>) as? NSDictionary
</code></pre><p>这时的dic就是个包括了employees和boss的字典：[“employess”:[…], “boss”:[…]]，将employess的数据再次强制转换成数组：</p>
<pre><code>let arr : NSArray? = dic?[<span class="link_label">"employees"</span>](<span class="link_url"></span>) as? NSArray
</code></pre><p>你会得到一个包含两个元素的数组，每个元素都是一部雇员信息的字典。够简单吧？如果你需要，源码传送门：<a href="https://github.com/conanwhf/swiftplayground/tree/master/Play.playground/Pages/JSON.xcplaygroundpage" target="_blank" rel="external">这里</a><br><strong>后记</strong><br>JSON确实是个很好用的数据表达方式，也难怪会如此流行。就我个人的感受来说，如果你只是需要从服务器端拿一些少量（我指的是种类）数据，那么用原生的库就行了，简单方便；如果你需要的是整个数据结构，那么手动慢慢填充转换也还是挺累的，建议引入第三方库建模。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>（挖坑自己跳系列四）<br>以为实现了xml的解析，我就能拿到所有想要的数据，可是经过几次尝试，发现有的API失效了！😱无论我怎么尝试，有的数据就是拿不到，苦恼了好久，灵光一闪：前阵子买的surge可以派上用场了！不知道surge是啥的我给解释一下，是个iOS App，利用iOS9的特性能给设备做个全局代理，前阵子大家纷纷用来流畅FQ，已下架。对我来说，用来过滤下广告正好，偶尔还能看看http log。<br>看了下自己手机上的第三方客户端，request居然直接是网页，看来是直接解析网页了，这个太高深、放弃；只好去下载官方客户端来看，在网页看同样的请求，返回居然换成JSON了……😥<br>还能说啥呢，去找找JSON怎么解析呗！这次看了看，似乎比XML简单多了……先拿数据：</p>
<pre><code><span class="built_in">let</span> url = NSURL(string:TESTURL)!
guard data = NSData(contentsOfURL: url)  <span class="keyword">else</span>{
    <span class="built_in">print</span>(<span class="string">"Can't get any data"</span>)
    <span class="built_in">exit</span>(<span class="number">0</span>)
}
</code></pre><p>然后解析出来：]]>
    
    </summary>
    
      <category term="JSON" scheme="http://conanwhf.gitcafe.io/tags/JSON/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Swift原生库解析XML数据]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/15/swift_xml/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/15/swift_xml/</id>
    <published>2015-12-15T10:14:35.000Z</published>
    <updated>2015-12-23T16:17:05.000Z</updated>
    <content type="html"><![CDATA[<p>（挖坑自己跳系列三）<br>在实现文件操作的时候我意识到了一个事实：由于NSURL是可支持的路径，很多文件的操作实际上可以扩充到网络上去，比如从网上下载一个文件、拿取一些数据……想到这里，埋藏在心中很久的愿望又开始蠢蠢欲动：写一个新闻客户端！<br>我有一个常看的新闻网站（不要问我是哪个，要FQ），官方客户端很难用，第三方广告满天飞，严重影响心情。所以当初开始学iOS的时候就把重做一个客户端的目标放在了首位。最开始的时候想得太简单，兴冲冲地开了个project，搞了两下TableView，然后发现……对于我这种从来只写底层代码，swift/OC语法都不会的人，做这个简直是异想天开好嘛！<br>折腾的过程中，为了拿到数据，还跑去下了Android的官方客户端反编译，find + grep出来了人家的数据接口地址（论一个爱折腾的程序员是怎么给自己挖坑的），返回的是XML数据，连蒙带猜试了试，可以用！不过后来做UI受挫（其实不止做UI，挫败感太大），就把那份东西闲置起来了。这两天突然想起来，现在我貌似感觉有点良好，何不捡起来继续写我的客户端？<br>因为UI我还一窍不通，不懂怎么调试，也不懂怎么把数据显示出来，为了避免到处打印的麻烦，我选择playground。这样也就是需要用原生库，这个很简单，搜一下就有了：NSXMLParserDelegate，还有好些源码，虽然大多是OC的。<br>问题是有源码，我依！然！看！不！懂！怎么用！每个教程都是扔了源码上来，可没人解释清楚到底怎么运行。我研究了好一阵，终于明白了大概的机制：</p>
<blockquote>
<p><strong>自己写一个类继承NSXMLParserDelegate，就叫它XmlReader吧；并且实现一些必须的callback函数，在XmlReader的Init中调用.parse()方法，最后在new XmlReader的时候就会自动完成整个parse了</strong><br><a id="more"></a></p>
</blockquote>
<p>当然你也可以不把parse()放在init()中调用，而是在new了XmlReader之后强制调用，重要的是那些callback函数的实现。XmlReader中还可以声明一些变量，来保存解析过程中的状态，而具体的获得到的数据填充，也是需要你自己做的（数据结构自行定义）。<br><strong>鉴于XML是一个有层级的带递归意味的数据结构，程序会层层解析下去直到结束，中间遇到的各种类似section开始、结束、拿到字符串等情况都会call一个固定的函数，将解析出来的数据作为参数传进去，而你要做的，就是实现这些callback以完成自己想要做的事。</strong><br>下面是具体的代码示范。首先是定义一个新的类：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">XmlReader</span>: <span class="title">NSObject</span>, <span class="title">NSXMLParserDelegate</span> </span>{
<span class="keyword">var</span> currentName :<span class="type">String</span>? = <span class="literal">nil</span>
<span class="keyword">var</span> level :<span class="type">Int</span> = <span class="number">0</span>

 <span class="keyword">init</span>(add :<span class="type">String</span> ) {

    <span class="keyword">super</span>.<span class="keyword">init</span>()
    <span class="keyword">let</span> url = <span class="type">NSURL</span>(string:add)!
    guard <span class="keyword">let</span> parserXML = <span class="type">NSXMLParser</span>(contentsOfURL: url) <span class="keyword">else</span> {
        <span class="keyword">return</span>
    }

    parserXML.delegate = <span class="keyword">self</span>
    parserXML.parse()
    }

<span class="func"><span class="keyword">func</span> <span class="title">parserDidStartDocument</span><span class="params">(parser: NSXMLParser)</span></span> {}

<span class="func"><span class="keyword">func</span> <span class="title">parserDidEndDocument</span><span class="params">(parser: NSXMLParser)</span></span>{}

<span class="func"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(parser: NSXMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String])</span></span> {}

<span class="func"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(parser: NSXMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?)</span></span> {}

<span class="func"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(parser: NSXMLParser, <span class="keyword">var</span> foundCharacters string: String)</span></span> {}

<span class="func"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(parser: NSXMLParser, parseErrorOccurred parseError: NSError)</span></span> {}
}
</code></pre><p>这是一个基础部分，里面定义了一些callback但没有实现它。我把xml的地址作为参数传给了init()，并且声明了两个变量currentName和level分别用来保存当前的标签名字和递归深度。然后我们基于下面这个简单的XML文件继续完成callback部分：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span>
<span class="tag">&lt;<span class="title">language</span> <span class="attribute">cat</span>=<span class="value">"it"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">lan</span> <span class="attribute">id</span>=<span class="value">"1"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span>C#<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">IDE</span>&gt;</span>vs<span class="tag">&lt;/<span class="title">IDE</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">lan</span>&gt;</span>
    <span class="tag">&lt;<span class="title">lan</span> <span class="attribute">id</span>=<span class="value">"2"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">language</span>&gt;</span>
</code></pre><p> 首先是文档开始和结束时：</p>
<pre><code><span class="comment">//文档开始解析时触发，只触发一次</span>
<span class="func"><span class="keyword">func</span> <span class="title">parserDidStartDocument</span><span class="params">(parser: NSXMLParser)</span></span> {
    <span class="built_in">print</span>(<span class="string">"    start"</span>)
}

<span class="comment">//文档结束时触发，只触发一次，通常需要在这里给出一个信号告诉上层或其他人解析已经结束</span>
<span class="func"><span class="keyword">func</span> <span class="title">parserDidEndDocument</span><span class="params">(parser: NSXMLParser)</span></span>{
    <span class="built_in">print</span>(<span class="string">"    end"</span>)
}
</code></pre><p>然后是标签的开始和结束事件：</p>
<pre><code><span class="comment">//遇到一个开始标签触发，elementName为当前标签，如果当前标签有属性，则字典sttributeDict不为空</span>
<span class="func"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(parser: NSXMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String]<span class="params">()</span></span></span>) {
    <span class="keyword">self</span>.currentName = elementName
    <span class="keyword">self</span>.level++
    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(level)</span> start, <span class="subst">\(elementName)</span>, <span class="subst">\(attributeDict)</span>"</span>)
    <span class="keyword">if</span> currentName == <span class="string">"language"</span> { <span class="comment">// 获取language属性的内容</span>
        <span class="comment">//print("language: \(attributeDict)")</span>
    }
}

<span class="comment">//遇到结束标签触发，该方法主要是做一些清理工作，在这里我修改了当前的深度</span>
<span class="func"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(parser: NSXMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?)</span></span> {
    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(level)</span> end, <span class="subst">\(elementName)</span>"</span>)
    <span class="keyword">self</span>.currentName = <span class="literal">nil</span>
    <span class="keyword">self</span>.level--
}
</code></pre><p>接下来是字符串值的handler</p>
<pre><code><span class="comment">// 遇到字符串时触发</span>
<span class="func"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(parser: NSXMLParser, <span class="keyword">var</span> foundCharacters string: String)</span></span> {
    <span class="comment">//删除首尾的回车符和空格</span>
    string = string.stringByTrimmingCharactersInSet(<span class="type">NSCharacterSet</span>.whitespaceAndNewlineCharacterSet())
    <span class="keyword">if</span> string.isEmpty {
        <span class="keyword">return</span>
    }
    <span class="built_in">print</span>(<span class="string">"---- <span class="subst">\(string)</span>"</span>)
}
</code></pre><p>最后是Error Handler</p>
<pre><code><span class="comment">// 文档出错时触发</span>
<span class="func"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(parser: NSXMLParser, parseErrorOccurred parseError: NSError)</span></span> {
    <span class="built_in">print</span>(parseError)
}
</code></pre><p>以上的callback函数实现都只放了些打印信息，在实际操作中需要把这些获取的信息一一填充进自己的数据结构中。说实话是挺麻烦的，难怪都说XML快要被JSON全面取代（其实对于曾被libxml折磨过的码农来说，这已经挺好了）。全部的代码传送门：<a href="https://github.com/conanwhf/swiftplayground/tree/master/Play.playground/Pages/GetXML.xcplaygroundpage" target="_blank" rel="external">这里</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>（挖坑自己跳系列三）<br>在实现文件操作的时候我意识到了一个事实：由于NSURL是可支持的路径，很多文件的操作实际上可以扩充到网络上去，比如从网上下载一个文件、拿取一些数据……想到这里，埋藏在心中很久的愿望又开始蠢蠢欲动：写一个新闻客户端！<br>我有一个常看的新闻网站（不要问我是哪个，要FQ），官方客户端很难用，第三方广告满天飞，严重影响心情。所以当初开始学iOS的时候就把重做一个客户端的目标放在了首位。最开始的时候想得太简单，兴冲冲地开了个project，搞了两下TableView，然后发现……对于我这种从来只写底层代码，swift/OC语法都不会的人，做这个简直是异想天开好嘛！<br>折腾的过程中，为了拿到数据，还跑去下了Android的官方客户端反编译，find + grep出来了人家的数据接口地址（论一个爱折腾的程序员是怎么给自己挖坑的），返回的是XML数据，连蒙带猜试了试，可以用！不过后来做UI受挫（其实不止做UI，挫败感太大），就把那份东西闲置起来了。这两天突然想起来，现在我貌似感觉有点良好，何不捡起来继续写我的客户端？<br>因为UI我还一窍不通，不懂怎么调试，也不懂怎么把数据显示出来，为了避免到处打印的麻烦，我选择playground。这样也就是需要用原生库，这个很简单，搜一下就有了：NSXMLParserDelegate，还有好些源码，虽然大多是OC的。<br>问题是有源码，我依！然！看！不！懂！怎么用！每个教程都是扔了源码上来，可没人解释清楚到底怎么运行。我研究了好一阵，终于明白了大概的机制：</p>
<blockquote>
<p><strong>自己写一个类继承NSXMLParserDelegate，就叫它XmlReader吧；并且实现一些必须的callback函数，在XmlReader的Init中调用.parse()方法，最后在new XmlReader的时候就会自动完成整个parse了</strong><br>]]>
    
    </summary>
    
      <category term="XML" scheme="http://conanwhf.gitcafe.io/tags/XML/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[文件操作]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/15/fileop/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/15/fileop/</id>
    <published>2015-12-15T08:14:35.000Z</published>
    <updated>2015-12-23T16:17:14.000Z</updated>
    <content type="html"><![CDATA[<p>（挖坑自己跳系列二）<br>上回说到文件操作，那就把文件操作来一遍吧，先放源码：<a href="https://github.com/conanwhf/swiftplayground/tree/master/Play.playground/Pages/File.xcplaygroundpage" target="_blank" rel="external">GitHub某个地方</a></p>
<h2 id="初始化_&amp;_文件路径">初始化 &amp; 文件路径</h2><p>所有的文件操作都要先声明一个根控制器以获得文件的句柄：</p>
<pre><code>let manager = NSFileManager.<span class="function"><span class="title">defaultManager</span><span class="params">()</span></span>
</code></pre><p>而文件路径的表示有两种方式：String和NSURL。在NSURL的视角中，本地文件作为一种特殊的网络文件而存在，以“file://”开头。多数的操作对于两种路径方式都有两个相对应的接口，要注意对于NSURL，表示本地文件时必须以“file://”开头，否则很多API会失败。为了测试方便，我给String加了个转换的扩展：</p>
<pre><code><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>{
    <span class="keyword">var</span> toFilePathURL : <span class="type">NSURL</span> {
    <span class="keyword">let</span> url =  <span class="type">NSURL</span>( fileURLWithPath: <span class="keyword">self</span>)
    <span class="keyword">return</span> url
    }
}
</code></pre><p>这里使用参数<strong>fileURLWithPath:</strong>而不是<strong>string:</strong>就是为了上述原因。<br>对于路径的修改，String表示方法很简单，直接相加即可；NSURL需要用以下代码：<a id="more"></a></p>
<pre><code>let newUrl = url.<span class="function"><span class="title">URLByAppendingPathComponent</span><span class="params">(<span class="string">"/urlNewDir/"</span>, isDirectory: true)</span></span>   
<span class="comment">//当然false也是可以的，但要注意匹配，别把参数给错了</span>
</code></pre><h2 id="获取用户目录">获取用户目录</h2><p>由于Apple的沙盒机制，平时在iOS上能操作的文件也只存在于App当前用户目录、临时文件之类的地方而已，获得这个地址的方法是：</p>
<pre><code><span class="function"><span class="title">NSHomeDirectory</span><span class="params">()</span></span>
<span class="function"><span class="title">NSHomeDirectoryForUser</span><span class="params">(<span class="string">"Conan"</span>)</span></span>
</code></pre><p>另外还有一些别的”NSXXXDirectory()”，大家自己可以去探索下。对于NSURL的方法如下：</p>
<pre><code><span class="keyword">let</span> urlForDocument = manager.URLsForDirectory( NSSearchPathDirectory.DocumentDirectory, inDomains:NSSearchPathDomainMask.UserDomainMask)    <span class="comment">//获得用户Document目录</span>
<span class="keyword">let</span> url = urlForDocument[<span class="number">0</span>] <span class="keyword">as</span> NSURL
</code></pre><p>返回的是Document目录。第一句其实是获得一个搜索集，目标由<strong>NSSearchPathDirectory.XXX</strong>参数指定，在我们知道只有一个搜索结果的情况下，可以直接指定数组中的[0]<br>在第一种方法中，我还没找到怎么拿到Document文件夹，谁知道麻烦留言告诉我，谢谢！🤗<br>在Playground中跑的时候，用户环境其实是在模拟器中，各种权限问题和奇怪的找不到文件之类，调试也不太方便，我就在此吃了点亏。建议有想不通错哪里的时候去终端跑一下，说不准就OK了（怎么跑见前一篇）。</p>
<blockquote>
<p>从这里开始进入罗列模式，因为文件操作的很多API实在雷同。我默认文件路径方面已经没有问题了，且你也申明了文件的根控制器manager，那么基本上就是使用：<strong>manager.TODOWHAT(URL/PATH)</strong>，如果有针对String和URL的不同API我会分别列出，写两次。</p>
</blockquote>
<h2 id="判断文件或者文件夹是否存在">判断文件或者文件夹是否存在</h2><p>首先是判断文件是否存在：</p>
<pre><code>manager.<span class="function"><span class="title">fileExistsAtPath</span><span class="params">(workdir)</span></span>       <span class="comment">//文件夹</span>
manager.<span class="function"><span class="title">fileExistsAtPath</span><span class="params">(workdir + <span class="string">"aaa.txt”) //文件</span></span></span>
</code></pre><h2 id="新建文件">新建文件</h2><h3 id="创建文件夹">创建文件夹</h3><pre><code><span class="keyword">do</span> {
<span class="keyword">try</span> manager.createDirectoryAtPath(fn, <span class="attribute">withIntermediateDirectories</span>: <span class="literal">true</span>, <span class="attribute">attributes</span>: nil)
} <span class="keyword">catch</span> {
<span class="built_in">print</span>(<span class="string">"Error by createDirectoryAtPath: \(error)\n"</span>)
}

<span class="keyword">do</span> {
<span class="keyword">try</span> manager.createDirectoryAtURL(fnUrl,     <span class="attribute">withIntermediateDirectories</span>: <span class="literal">true</span>, <span class="attribute">attributes</span>: nil)
} <span class="keyword">catch</span> {
<span class="built_in">print</span>(<span class="string">"Error by createDirectoryAtURL: \(error)\n"</span>)
}
</code></pre><p>其中参数_withIntermediateDirectories_为true则表示路径中间如果有不存在的文件夹都会一并创建</p>
<h3 id="创建普通文件">创建普通文件</h3><pre><code><span class="keyword">fn</span>          = workdir + <span class="string">"try.txt"</span>
manager.createFileAtPath(<span class="keyword">fn</span>, <span class="symbol">contents:</span> <span class="keyword">nil</span> , <span class="symbol">attributes:</span> <span class="keyword">nil</span>)
</code></pre><h3 id="创建符号链接">创建符号链接</h3><pre><code><span class="keyword">do</span> {
<span class="keyword">try</span> manager.createSymbolicLinkAtPath(workdir + <span class="string">"tryLink.txt"</span>, <span class="attribute">withDestinationPath</span>: fn)
} <span class="keyword">catch</span> {
    <span class="built_in">print</span>(<span class="string">"Error by createSymbolicLinkAtPath: \(error)\n"</span>)
}

<span class="keyword">do</span> {
<span class="keyword">let</span> linkurl = url.URLByAppendingPathComponent(<span class="string">"link-url"</span>, <span class="attribute">isDirectory</span>: <span class="literal">false</span>)
<span class="keyword">try</span> manager.createSymbolicLinkAtURL(linkurl, <span class="attribute">withDestinationURL</span>: fnUrl)
} <span class="keyword">catch</span> {
<span class="built_in">print</span>(<span class="string">"Error by createSymbolicLinkAtURL: \(error)\n"</span>)
}
</code></pre><p>以上的文件创建，在默认的情况下如果已有目标文件存在则会失败；除了<strong>createFileAtPath</strong>会直接覆盖掉。</p>
<h2 id="读取文件">读取文件</h2><p>读取文件的数据结果为NSData，如果需要变成可读的文字，转换成String即可：</p>
<pre><code><span class="keyword">let</span> st      = <span class="built_in">String</span>(<span class="built_in">data</span>: <span class="built_in">data</span><span class="subst">!</span>, encoding: NSUTF8StringEncoding)
</code></pre><p>而读取文件有两种方式，一种直接获取全部数据:</p>
<pre><code><span class="typedef"><span class="keyword">data</span>        = manager.contentsAtPath<span class="container">(<span class="title">fn</span>)</span></span>
</code></pre><p>另一种是使用文件句柄：</p>
<pre><code>let <span class="keyword">handler</span> = NSFileHandle(forReadingAtPath: fn)
data        = <span class="keyword">handler</span>?.readDataToEndOfFile()

do {
    let <span class="keyword">handler</span> = <span class="keyword">try</span> NSFileHandle(forReadingFromURL: fnUrl)
    data        = <span class="keyword">handler</span>.readDataToEndOfFile()
} <span class="keyword">catch</span> {
    print(<span class="string">"Error by NSFileHandle: \(error)\n"</span>)
}
</code></pre><p>第二种方式比较灵活，还有别的参数可用，通常结合写数据用来修改文件</p>
<h2 id="将数据写入文件">将数据写入文件</h2><h3 id="整体数据写入">整体数据写入</h3><p>可以通过writeToFile方法，创建并将数据整体写入文件。支持的数据对象包括String，NSString，UIImage，NSArray，NSDictionary等。</p>
<h4 id="字符串">字符串</h4><pre><code><span class="keyword">let</span> info        = <span class="string">"测试数据1234"</span>
<span class="keyword">do</span> {
<span class="keyword">try</span> info.writeToFile(fn + <span class="string">"_string.txt"</span>, <span class="attribute">atomically</span>: <span class="literal">true</span>, <span class="attribute">encoding</span>: NSUTF8StringEncoding)
} <span class="keyword">catch</span> {
<span class="built_in">print</span>(<span class="string">"Error by writeToFile: \(error)\n"</span>)
}
</code></pre><h4 id="图片">图片</h4><pre><code>let image       = UIImage(named: workdir + "/test/207006981.jpg”)//这里只是先<span class="operator"><span class="keyword">load</span>一下
let <span class="keyword">data</span>:NSData = UIImagePNGRepresentation(image!)!
<span class="keyword">data</span>.writeToFile(fn + <span class="string">"_img.jpg"</span>, atomically: <span class="literal">true</span>)</span>
</code></pre><h4 id="数组">数组</h4><pre><code>let<span class="instruction"> array </span>      =<span class="function"> NSArray(</span>objects: <span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span><span class="function">)</span>
array.writeToFile(fn + <span class="string">"_arr.txt"</span>, atomically: true<span class="function">)</span>
</code></pre><h4 id="字典">字典</h4><pre><code>let dictionary  = NSDictionary(<span class="string">objects:</span> [<span class="string">"111"</span>,<span class="string">"222"</span>], <span class="string">forKeys:</span> [<span class="string">"aaa"</span>,<span class="string">"bbb"</span>]
dictionary.writeToFile(fn + <span class="string">"_dic.txt"</span>, <span class="string">atomically:</span> <span class="literal">true</span>)
</code></pre><h3 id="末尾添加、修改文件">末尾添加、修改文件</h3><p>修改文件跟C的用法很像，使用文件句柄，结合seek到的某个位置，写入数据。需要注意的是没有专门的插入数据方法，所以如果你想插入数据，就需要把后面的数据都出来（或者另存下来），添加数据，再续上之前的后半截。所以如果数据量大，下面的暴力方法不合适，需要用callback结合缓存去做读写。</p>
<h4 id="末尾添加数据">末尾添加数据</h4><pre><code>let <span class="operator"><span class="keyword">handler</span> = NSFileHandle(forUpdatingAtPath: fn)
<span class="keyword">guard</span> <span class="keyword">handler</span> != nil <span class="keyword">else</span> {
    print(<span class="string">"No such file"</span>)
    <span class="keyword">return</span>
}
<span class="keyword">string</span>      = <span class="string">"\n用forUpdatingAtPath在文件末尾添加XXX"</span>
<span class="keyword">data</span>        = <span class="keyword">string</span>.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: <span class="literal">true</span>)!
<span class="keyword">handler</span>!.seekToEndOfFile()
<span class="keyword">handler</span>!.writeData(<span class="keyword">data</span>)</span>
</code></pre><h4 id="插入数据">插入数据</h4><pre><code>var string  = <span class="string">"\n用forUpdatingAtURL在文件第10个字节插入XXX\n"</span>
var data    = string.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: <span class="keyword">true</span>)!
do {
    let <span class="keyword">handler</span> = <span class="keyword">try</span> NSFileHandle(forUpdatingURL: fnUrl)
    <span class="keyword">handler</span>.seekToFileOffset(10)
    let data2   = <span class="keyword">handler</span>.readDataToEndOfFile()
    <span class="keyword">handler</span>.seekToFileOffset(10)
    <span class="keyword">handler</span>.writeData(data)
    <span class="keyword">handler</span>.writeData(data2)
} <span class="keyword">catch</span> {
    print(<span class="string">"Error by NSFileHandle: \(error)\n"</span>)
}
</code></pre><p>这里两种方式用了不同的句柄获得方式，实际上可以随意互换。</p>
<h2 id="复制文件（夹）">复制文件（夹）</h2><pre><code><span class="name">do</span> {
    try manager.copyItemAtPath(src, toPath: dest)
} <span class="name">catch</span> <span class="name">let</span> <span class="name">error</span> <span class="name">as</span> <span class="name">NSError</span> {
    print(<span class="string">"Error by Path: \(error)\n"</span>)
}

<span class="name">do</span> {
    try manager.copyItemAtURL( srcUrl, toURL: destUrl)
} <span class="name">catch</span> <span class="name">let</span> <span class="name">error</span> <span class="name">as</span> <span class="name">NSError</span> {
    print(<span class="string">"Error by URL: \(error)\n"</span>)
}
</code></pre><h2 id="移动文件（夹）">移动文件（夹）</h2><pre><code><span class="keyword">do</span> {
    <span class="keyword">try</span> manager.moveItemAtPath(src, <span class="attribute">toPath</span>: dest)
} <span class="keyword">catch</span> {
<span class="built_in">print</span>(<span class="string">"Error by Path: \(error)\n"</span>)
}

<span class="keyword">do</span> {
    <span class="keyword">try</span> manager.moveItemAtURL( srcUrl, <span class="attribute">toURL</span>: destUrl)
} <span class="keyword">catch</span>  {
    <span class="built_in">print</span>(<span class="string">"Error by URL: \(error)\n"</span>)
}
</code></pre><h2 id="删除文件（夹）">删除文件（夹）</h2><pre><code><span class="keyword">do</span> {
    <span class="keyword">try</span> manager.removeItemAtPath(fn)
} <span class="keyword">catch</span> {
    <span class="built_in">print</span>(<span class="string">"Error by Path: \(error)\n"</span>)
}

<span class="keyword">do</span> {
    <span class="keyword">try</span> manager.removeItemAtURL( fn.toFilePathURL)
} <span class="keyword">catch</span>  {
    <span class="built_in">print</span>(<span class="string">"Error by URL: \(error)\n"</span>)
}   
</code></pre><h2 id="遍历文件夹">遍历文件夹</h2><p>遍历文件夹有两种方式：遍历当前文件夹，和递归遍历子文件夹。下面是范例。注意：<strong>使用Path为参数的时候返回的是相对路径和文件名，而使用URL方式时返回的是绝对路径！</strong></p>
<h3 id="不遍历子文件夹">不遍历子文件夹</h3><pre><code>do {
let contentsOfPath   = try manager.contentsOfDirectoryAtPath(dir)
    contentsOfPath.forEach{ print(<span class="variable">$0</span>) }
} <span class="keyword">catch</span> {
    print(<span class="string">"Error by 1-1: \(error)\n"</span>)
}

do {
let contentsOfURL    = try manager.contentsOfDirectoryAtURL(url, includingPropertiesForKeys: nil, options: NSDirectoryEnumerationOptions.SkipsHiddenFiles)
    contentsOfURL.forEach{ print(<span class="variable">$0</span>) }
} <span class="keyword">catch</span> {
    print(<span class="string">"Error by 1-2: \(error)\n"</span>)
}
</code></pre><h3 id="递归遍历子文件夹，但不递归符号链接">递归遍历子文件夹，但不递归符号链接</h3><pre><code><span class="keyword">let</span> enumeratorAtPath = manager.enumeratorAtPath(dir)
<span class="keyword">if</span> enumeratorAtPath == nil  {
    print(<span class="string">"Error by 2-1: no such folder: \(dir)"</span>)
    //return
}
<span class="keyword">else</span> {
    enumeratorAtPath!.forEach{ print(<span class="variable">$0</span>) }
}

<span class="keyword">let</span> enumeratorAtURL  = manager.enumeratorAtURL(url,includingPropertiesForKeys: nil, options: NSDirectoryEnumerationOptions.SkipsHiddenFiles, errorHandler:nil)
<span class="keyword">if</span> enumeratorAtURL == nil  {
    print(<span class="string">"Error by 2-2: no such folder: \(url)"</span>)
    //return
}
<span class="keyword">else</span> {
    enumeratorAtURL!.forEach{ print(<span class="variable">$0</span>) }
}
</code></pre><h3 id="递归遍历子文件夹，包括符号链接">递归遍历子文件夹，包括符号链接</h3><pre><code><span class="keyword">let</span> subpathsAtPath   = manager.subpathsAtPath(dir)
<span class="keyword">if</span> subpathsAtPath == nil  {
    print(<span class="string">"-Error by 3: no such folder: \(dir)"</span>)
    //return
}
<span class="keyword">else</span> {
    subpathsAtPath!.forEach{ print(<span class="variable">$0</span>) }
}
</code></pre><p>这个函数有点危险，可能一不小心就死循环了，建议慎用。</p>
<h2 id="获取文件属性和权限">获取文件属性和权限</h2><h3 id="权限判断">权限判断</h3><pre><code>let readable   = manager.<span class="function"><span class="title">isReadableFileAtPath</span><span class="params">(fn)</span></span>
let writeable  = manager.<span class="function"><span class="title">isWritableFileAtPath</span><span class="params">(fn)</span></span>
let executable = manager.<span class="function"><span class="title">isExecutableFileAtPath</span><span class="params">(fn)</span></span>
let deleteable = manager.<span class="function"><span class="title">isDeletableFileAtPath</span><span class="params">(fn)</span></span>
<span class="function"><span class="title">print</span><span class="params">(<span class="string">"文件\(fn) \(readable ? "</span><span class="string">" : "</span>不<span class="string">")可读， \(writeable ? "</span><span class="string">" : "</span>不<span class="string">")可写，\(executable ? "</span><span class="string">" : "</span>不<span class="string">")可执行，\(deleteable ? "</span><span class="string">" : "</span>不<span class="string">")可删除"</span>)</span></span>
</code></pre><h3 id="获取文件属性">获取文件属性</h3><pre><code><span class="keyword">do</span> {
<span class="keyword">let</span> attributes = <span class="keyword">try</span> manager.attributesOfItemAtPath(fn)
        <span class="built_in">print</span>(<span class="string">"attributes: \(attributes)"</span>)
} <span class="keyword">catch</span> {
    <span class="built_in">print</span>(<span class="string">"Error by attributesOfItemAtPath: \(error)\n"</span>)
}
</code></pre><h2 id="比较文件（夹）">比较文件（夹）</h2><pre><code>manager.<span class="function"><span class="title">contentsEqualAtPath</span><span class="params">(workdir + <span class="string">"read.md"</span>, andPath: workdir + <span class="string">"copied.txt"</span>)</span></span>   <span class="comment">//文件</span>
manager.<span class="function"><span class="title">contentsEqualAtPath</span><span class="params">(workdir, andPath: workdir + <span class="string">"/tesst/"</span>)</span></span>  <span class="comment">//文件夹</span>
</code></pre><p>这个函数不是diff，只能判断是否相同，不能做内容对比</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>（挖坑自己跳系列二）<br>上回说到文件操作，那就把文件操作来一遍吧，先放源码：<a href="https://github.com/conanwhf/swiftplayground/tree/master/Play.playground/Pages/File.xcplaygroundpage">GitHub某个地方</a></p>
<h2 id="初始化_&amp;_文件路径">初始化 &amp; 文件路径</h2><p>所有的文件操作都要先声明一个根控制器以获得文件的句柄：</p>
<pre><code>let manager = NSFileManager.<span class="function"><span class="title">defaultManager</span><span class="params">()</span></span>
</code></pre><p>而文件路径的表示有两种方式：String和NSURL。在NSURL的视角中，本地文件作为一种特殊的网络文件而存在，以“file://”开头。多数的操作对于两种路径方式都有两个相对应的接口，要注意对于NSURL，表示本地文件时必须以“file://”开头，否则很多API会失败。为了测试方便，我给String加了个转换的扩展：</p>
<pre><code><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>{
    <span class="keyword">var</span> toFilePathURL : <span class="type">NSURL</span> {
    <span class="keyword">let</span> url =  <span class="type">NSURL</span>( fileURLWithPath: <span class="keyword">self</span>)
    <span class="keyword">return</span> url
    }
}
</code></pre><p>这里使用参数<strong>fileURLWithPath:</strong>而不是<strong>string:</strong>就是为了上述原因。<br>对于路径的修改，String表示方法很简单，直接相加即可；NSURL需要用以下代码：]]>
    
    </summary>
    
      <category term="File" scheme="http://conanwhf.gitcafe.io/tags/File/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在终端运行Swift程序]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/15/runInTerm/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/15/runInTerm/</id>
    <published>2015-12-15T04:14:35.000Z</published>
    <updated>2015-12-23T16:17:37.000Z</updated>
    <content type="html"><![CDATA[<p>好几天没做总结了，一直被写code的欲望牵引着，噼里啪啦打了很多code，也走了很多弯路。好多时候，突然搞定的时候，才发现自己真真像个新新手一样，给自己挖了好多坑，真是傻到家了！<br>好在我一直觉得，在debug上浪费的时间通常都不会是彻底浪费掉的，总有那么一些东西是留在脑子里，通俗地来讲，就是经验。是时候把过程理一理，记录下来了。<br>之前也说过，之所以把String顺了一遍，其根本缘由是想找到一个编码转换的函数，把我那些下载下来的书名乱码都改过来。后来编码是解决了，但改名还需要自己来……于是我琢磨着给Mac写个文件pickup的界面？刚巧看到源码推荐一个swift开源的命令行增强工具，突然意识到swift也是可以直接编译跑在终端的！做起来简单得不能更简单（先要装好Xcode command line tool，如果没装，在终端跑<code>xcode-select --install</code>）：</p>
<pre><code>swiftc <span class="keyword">test</span>.swift<span class="comment">//生成一个test二进制程序</span>
./<span class="keyword">test</span>
</code></pre><p>这是有编译过程的，更省事的是直接跑了：</p>
<pre><code><span class="built_in">swift</span> test.<span class="built_in">swift</span>
</code></pre><p>当然这个<strong>swift</strong>命令还有更多用法和参数，<a id="more"></a>需要的话可以自己研究研究。<br>现在程序可以跑了，但是还缺自动重命名的环节，这个需要用到文件操作，先按下不表，总之是我做完这个小工具，又花了扎扎实实一整天把各种文件操作实现了一遍。在这个程序里，我搜索了某个目录下的文件名，将他们转换成UTF8再批量重命名。<br>这样显然还不够完美，那就是如果我的文件不是放在这个固定目录，而是想用参数传进去怎么办？解决方案依然那么简单：</p>
<pre><code><span class="keyword">for</span> s <span class="keyword">in</span> Process.arguments {  
    <span class="built_in">print</span>(s)
} 
</code></pre><p>这个跟C一样，Process.arguments是一个字符串数组，第[0]个元素就是程序本身跑起来的名字。这个用法对于Linux程序员来说，简直是打开了新世界的大门啊！<br>好了，现在OK，虽然我还不会写Mac的应用，但给自己写点简单的小工具用用是没问题了。虽然其实之前也可以用C写，但毕竟Swift的API多，写起来方便，学以致用嘛！<br>源码传送门<a href="https://github.com/conanwhf/swiftplayground/blob/master/Play.playground/Pages/Rename.xcplaygroundpage/Contents.swift" target="_blank" rel="external">在此</a><br>P.S.这种模式下，貌似UIKit不能用</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好几天没做总结了，一直被写code的欲望牵引着，噼里啪啦打了很多code，也走了很多弯路。好多时候，突然搞定的时候，才发现自己真真像个新新手一样，给自己挖了好多坑，真是傻到家了！<br>好在我一直觉得，在debug上浪费的时间通常都不会是彻底浪费掉的，总有那么一些东西是留在脑子里，通俗地来讲，就是经验。是时候把过程理一理，记录下来了。<br>之前也说过，之所以把String顺了一遍，其根本缘由是想找到一个编码转换的函数，把我那些下载下来的书名乱码都改过来。后来编码是解决了，但改名还需要自己来……于是我琢磨着给Mac写个文件pickup的界面？刚巧看到源码推荐一个swift开源的命令行增强工具，突然意识到swift也是可以直接编译跑在终端的！做起来简单得不能更简单（先要装好Xcode command line tool，如果没装，在终端跑<code>xcode-select --install</code>）：</p>
<pre><code>swiftc <span class="keyword">test</span>.swift<span class="comment">//生成一个test二进制程序</span>
./<span class="keyword">test</span>
</code></pre><p>这是有编译过程的，更省事的是直接跑了：</p>
<pre><code><span class="built_in">swift</span> test.<span class="built_in">swift</span>
</code></pre><p>当然这个<strong>swift</strong>命令还有更多用法和参数，]]>
    
    </summary>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift2.0 中的String（六）：正则匹配]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/</id>
    <published>2015-12-09T08:20:16.000Z</published>
    <updated>2015-12-23T16:22:41.000Z</updated>
    <content type="html"><![CDATA[<p>Swift中的字符串，第六篇，正则匹配。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages" target="_blank" rel="external">这里</a>看到</li>
</ul>
<p>对于字符串的操作来说，正则匹配算是很重要的一项应用了。虽然其实我不太用，但偶尔需要的时候还是感到这东西真挺有用的。在网上找了找，对于iOS中使用正则，基本上都是说有三种方法，可惜给的Swift源码比较少，版本问题也不能直接跑，于是自己动手做一遍。总结了下其实所谓的三种方法其中两种还是很有局限性的。</p>
<p>首先我们定义好待匹配的字符串和pattern：</p>
<pre><code>let str = "18800002222---13144445555"
let pattern = "1[<span class="link_label">3|5|7|8</span>][<span class="link_reference">0-9</span>]\\d{8}"
</code></pre><p>简单示范，就不搞太复杂了。这个pattern是手机号码的正则，因为准备demo匹配多个结果，没有加开头和结尾的限制。<a id="more"></a></p>
<h2 id="String直接支持的匹配方式">String直接支持的匹配方式</h2><p>严格地来说，只有这一种才算是真正的“Swift中的正则”，其他的都是使用了OC继承过来的类。而这种方法也很简单，就是简单的使用rangOfString而已。</p>
<pre><code>str.<span class="function"><span class="title">rangeOfString</span><span class="params">(pattern, options: NSStringCompareOptions.RegularExpressionSearch)</span></span>
</code></pre><p>很简单吧？只是把option的参数改成<strong>RegularExpressionSearch</strong>就行了。这种方法会得到一个Range类型的返回值，是匹配到的第一个子串的位置。在这个例子中，返回0..\&lt;11；如果找不到匹配，返回nil</p>
<h2 id="使用NSPredicate的方式">使用NSPredicate的方式</h2><p>这是我最不推荐的方式。NSPredicate本身是数据查找、过滤的强大工具，他自己本身有一套语法，而正则只是其中的一小部分方式：</p>
<pre><code>let pred: NSPredicate = <span class="function"><span class="title">NSPredicate</span><span class="params">(format: <span class="string">"SELF MATCHES %@"</span>, pattern)</span></span>
pred.<span class="function"><span class="title">evaluateWithObject</span><span class="params">(str)</span></span>
</code></pre><p>这个方法返回一个bool来说明是否匹配到，而且只能匹配全字符串（在这个例子中就会返回false），比第一种方法还复杂，除非是想用NSPredicate相关的奇技淫巧，否则还是用rangOfString要好得多。</p>
<h2 id="使用NSRegularExpression的方式">使用NSRegularExpression的方式</h2><p>NSRegularExpression是专门的正则匹配类型，如果你需要更专业的匹配，推荐使用这种方法。<br>首先需要声明一个新的NSRegularExpression类型，并且设定它的匹配pattern:</p>
<pre><code><span class="tag">var</span> expr              = try <span class="function"><span class="title">NSRegularExpression</span><span class="params">(pattern: pattern, options: [])</span></span>
expr<span class="class">.pattern</span>    <span class="comment">// Show the pattern</span>
</code></pre><p>这一步可以看到正则表达式已经设置好了，可以使用这个变量对各种字符串进行匹配。<br>匹配的方法有两种，一种是Block的方式（在Swift中可以近似于闭包），另外一种是普通的（我也不知道是不是可以说成non-block）。</p>
<blockquote>
<p>插播吐个槽：_这个什么鬼Block真的搞得我好困惑啊！在C里面的Block函数是指那些阻塞进程的，而在OC里面是个反的！有callback专门做异步的！搞得我每次看到都要反应一下！求问为啥这么定义？！😖_</p>
</blockquote>
<p>另外我在网上看到的示例中某些API都已经找不到了，这个类的完善看来也经历了一些过程……言归正传。Block的方法还要用到Callback来拿返回值，懒得用，我们的数据量反正也不大，先拿普通用法来解释：</p>
<pre><code><span class="tag">var</span> range             = <span class="function"><span class="title">NSMakeRange</span><span class="params">(<span class="number">0</span>, str.characters.count)</span></span>
<span class="tag">var</span> res               = expr.<span class="function"><span class="title">firstMatchInString</span><span class="params">(str, options: NSMatchingOptions.ReportProgress, range: range)</span></span>
<span class="function"><span class="title">print</span><span class="params">(res?.range)</span></span>
</code></pre><p>这是最简单常用的匹配，匹配第一个字串，返回一个封装好的类。如果没有结果，返回nil。通常我们只需要拿到它的range属性，注意：<strong>!!!这里的range是NSRange而不是Range，它的结构是（start, length）！！！</strong></p>
<p>然后是另外一种获取全部匹配的方法：</p>
<pre><code><span class="keyword">var</span> resAll            = expr.matchesInString(str, options: NSMatchingOptions.ReportProgress, <span class="keyword">range</span>: <span class="keyword">range</span>)
resAll.<span class="keyword">forEach</span>{ <span class="keyword">print</span>(<span class="label">$0</span>.<span class="keyword">range</span>) }
</code></pre><p>这个方法返回一个数组，内容是每一个匹配结果。<strong>使用NSRegularExpression是唯一一种能够获得所有匹配结果的方法</strong>，如果没有匹配，则返回一个空数组。<br>同时我们还可以直接获取匹配到的结果的数量：</p>
<pre><code><span class="type">expr</span>.numberOfMatchesInString(str, options: <span class="type">NSMatchingOptions</span>.<span class="type">ReportProgress</span>, <span class="type">range</span>: <span class="type">range</span>)
</code></pre><p>很方便的另一个方法，是将所有匹配替换为另外的字符串：</p>
<pre><code><span class="tag">var</span> newStr = <span class="function"><span class="title">NSMutableString</span><span class="params">(string: str)</span></span>
expr.<span class="function"><span class="title">replaceMatchesInString</span><span class="params">(newStr, options: [] , range: range, withTemplate: <span class="string">"phoneNum"</span>)</span></span>
newStr
</code></pre><p>结果newStr变成了_“phoneNum—phoneNum”_。这里要用NSMutableString当作Input，是因为它本身是给OC~NSString系统用的，而NSString是固定memory的，替换可能改变字符串长度，所以需要强制要求提供一个NSMutableString的入口。Swift中的String类型是没有这种问题的。<br>这个方法其实靠rangeOfString + stringByReplacingCharactersInRange 也能做到，就是麻烦点儿。参数中的Template应该还有别的动态用法，我没深入研究了。</p>
<h2 id="URL的匹配和解析">URL的匹配和解析</h2><p>说了这么多，最后顺便来一点URL吧。URL的解析在实用中也是很常见的，虽然也是可以使用正则表达式，但其实它有自己的接口来实现parser。下面就是范例代码：</p>
<pre><code><span class="keyword">let</span> url        = NSURL(string: <span class="string">"http://weibo.com/u/1864854042?sudaref=conanwhf.github.io&amp;test=???&amp;lalalvy=irobot"</span>)!
<span class="keyword">let</span> components = NSURLComponents(URL: url, resolvingAgainstBaseURL: <span class="literal">false</span>)
<span class="keyword">let</span> <span class="literal">item</span>       = components?.queryItems
<span class="literal">item</span>?.forEach { print(<span class="variable">$0</span>.name, <span class="variable">$0</span>.value!) }
</code></pre><p>最后打印出结果：<br>    <em>sudaref conanwhf.github.io<br>    test ???<br>    lalalvy irobot</em><br>很方便！</p>
<blockquote>
<p>至此，字符串的部分应该是差不多了，如果说还有待研究的部分，那就是xml和json数据解析了吧。String本身在C语言中是作为数据存储万金油的存在，而在Swift中，它的数据层面被淡化了很多，同时多了很多新特性。学习它的时候，我常常会想，为什么要这么设置API，和旧的API相比这么做有什么好处，为什么会有这样的属性，什么情况下会用到……希望能通过这样的思考弥补自己对于面向对象概念的不足，慢慢找到感觉。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Swift中的字符串，第六篇，正则匹配。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages">这里</a>看到</li>
</ul>
<p>对于字符串的操作来说，正则匹配算是很重要的一项应用了。虽然其实我不太用，但偶尔需要的时候还是感到这东西真挺有用的。在网上找了找，对于iOS中使用正则，基本上都是说有三种方法，可惜给的Swift源码比较少，版本问题也不能直接跑，于是自己动手做一遍。总结了下其实所谓的三种方法其中两种还是很有局限性的。</p>
<p>首先我们定义好待匹配的字符串和pattern：</p>
<pre><code>let str = "18800002222---13144445555"
let pattern = "1[<span class="link_label">3|5|7|8</span>][<span class="link_reference">0-9</span>]\\d{8}"
</code></pre><p>简单示范，就不搞太复杂了。这个pattern是手机号码的正则，因为准备demo匹配多个结果，没有加开头和结尾的限制。]]>
    
    </summary>
    
      <category term="String" scheme="http://conanwhf.gitcafe.io/tags/String/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift2.0 中的String（五）：String和NS-XXX系列的互相转换]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/</id>
    <published>2015-12-08T08:20:16.000Z</published>
    <updated>2015-12-23T16:22:33.000Z</updated>
    <content type="html"><![CDATA[<p>Swift中的字符串，第五篇，常用NS-XXX系列的类型转换。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages" target="_blank" rel="external">这里</a>看到</li>
</ul>
<p>刚开始碰String的时候着实被各种繁琐的操作折腾得不轻，不能随便取字串、比较、赋值，不能获得实际编码值……往往想干点什么，一搜，就是NSString，NSData的API，晕头转向。研究了一阵子编码，慢慢也摸清了这些数据类型和它们的方法，简单总结一下互相转换的方法，给新手一点方向。这篇文章里的类型包括了String, NSString, NSURL, NSData这几种，String是Swift的字符串类型不用多讲，封装得很豪华但各种概念多用起来有点麻烦；NSString是OC里面的字符串，但有很多实用且方便的API；NSData其实属于无差别的Data类型，存储字符串的话是RawData，有点像C语言里面的string，其实是数据块；NSURL专门用来表示网络地址，有一些网络相关API。<a id="more"></a>一些主要的操作其实在（四）编码转换 中特别是手动编码转换那一节实现过，这里更多的是总结。首先定义几个变量：</p>
<pre><code><span class="variable"><span class="keyword">var</span> str</span> = “测试”
<span class="variable"><span class="keyword">var</span> data</span> :NSData?
<span class="variable"><span class="keyword">var</span> nstr</span> : NSString?
<span class="variable"><span class="keyword">var</span> url</span> : NSURL?
</code></pre><h2 id="NSString和String的转换">NSString和String的转换</h2><p>NSString和String就是兄弟，可以简单地直接赋值或者强制类型转换：</p>
<pre><code>nstr = <span class="built_in">str</span>
<span class="built_in">str</span> = <span class="keyword">String</span>(nstr)
</code></pre><h2 id="NSURL和其他类型的转换">NSURL和其他类型的转换</h2><p>从String到NSURL使用初始化函数即可，但NSURL由于是网络传递用字符串，编码使用UTF8，如果原始地址String中有中文字符，直接转换会返回nil，所以需要先将String转换一下编码。而对于NSString，则可以简单地强制换为String操作。</p>
<pre><code>let utf8str = str.<span class="function"><span class="title">stringByAddingPercentEncodingWithAllowedCharacters</span><span class="params">(.URLHostAllowedCharacterSet()</span></span>)!
nstr = utf8str
url = <span class="function"><span class="title">NSURL</span><span class="params">(string: utf8str)</span></span>
url = <span class="function"><span class="title">NSURL</span><span class="params">(string: String(nstr!)</span></span>)
</code></pre><p>NSURL转换成String或NSString也是使用相应的初始化函数（不考虑编码）</p>
<pre><code>str = <span class="function"><span class="title">String</span><span class="params">(url!)</span></span>
nstr = <span class="function"><span class="title">NSString</span><span class="params">(string: url!.absoluteString)</span></span>
</code></pre><h2 id="NSData和其他类型的转换">NSData和其他类型的转换</h2><p>理论上来说NSData可以是任何数据，有时候我们需要其数据层面的操作API，又需要解读数据里面的文本，那么需要将NSData转换为其他类型。将字符串转换成Data的接口都是同一个dataUsingEncoding，记得不要弄错编码，编码不同会改变数据。</p>
<pre><code><span class="typedef"><span class="keyword">data</span> = str.dataUsingEncoding<span class="container">(<span class="type">NSUTF8StringEncoding</span>)</span></span>
<span class="typedef"><span class="keyword">data</span> = nstr?.dataUsingEncoding<span class="container">(<span class="type">NSUTF8StringEncoding</span>)</span></span>
<span class="typedef"><span class="keyword">data</span> = url?.absoluteString.dataUsingEncoding<span class="container">(<span class="type">NSUTF8StringEncoding</span>)</span></span>
</code></pre><p>而有时候我们需要自己填充数据，再转换为字符串，这种时候以填充Ascii码值比较多，毕竟汉字和Unicode的编码规则比较复杂，不过也是可以用的：</p>
<pre><code>let byte :[UInt8]    = [<span class="number">0</span>xe4, <span class="number">0</span>x8d, <span class="number">0</span>xa9, <span class="number">0</span>x20, <span class="number">0</span>xe3, <span class="number">0</span>x8e, <span class="number">0</span>x8f]
data                 = <span class="function"><span class="title">NSData</span><span class="params">(bytes: byte, length: byte.count)</span></span>
str = <span class="function"><span class="title">String</span><span class="params">(data: data!, encoding: NSUTF8StringEncoding)</span></span>!
nstr = <span class="function"><span class="title">NSString</span><span class="params">(data: data!, encoding: NSUTF8StringEncoding)</span></span>
url                 = <span class="function"><span class="title">NSURL</span><span class="params">(dataRepresentation: data!, relativeToURL: nil)</span></span>
</code></pre><p>上面的做法是先将一个Uint8数组填充好，转化为NSData，然后再变成需要的字符串。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Swift中的字符串，第五篇，常用NS-XXX系列的类型转换。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages">这里</a>看到</li>
</ul>
<p>刚开始碰String的时候着实被各种繁琐的操作折腾得不轻，不能随便取字串、比较、赋值，不能获得实际编码值……往往想干点什么，一搜，就是NSString，NSData的API，晕头转向。研究了一阵子编码，慢慢也摸清了这些数据类型和它们的方法，简单总结一下互相转换的方法，给新手一点方向。这篇文章里的类型包括了String, NSString, NSURL, NSData这几种，String是Swift的字符串类型不用多讲，封装得很豪华但各种概念多用起来有点麻烦；NSString是OC里面的字符串，但有很多实用且方便的API；NSData其实属于无差别的Data类型，存储字符串的话是RawData，有点像C语言里面的string，其实是数据块；NSURL专门用来表示网络地址，有一些网络相关API。]]>
    
    </summary>
    
      <category term="String" scheme="http://conanwhf.gitcafe.io/tags/String/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift2.0 中的String（四）：编码转换]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/</id>
    <published>2015-12-08T07:20:16.000Z</published>
    <updated>2015-12-23T16:22:21.000Z</updated>
    <content type="html"><![CDATA[<p>Swift中的字符串，第四篇，中文字符编码的转换。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages" target="_blank" rel="external">这里</a>看到</li>
</ul>
<p>不知道是不是Safari的原因，我用浏览器下载中文名文件的时候常常文件名会变成乱码，就是“%EF%77%3D%20”那种，又因为很多是电子书，名称也不能乱改，还需要自己去copy一遍重命名，很烦，于是想到用Swift自己写个函数试试纠正这个乱码。<br>最开始我的想法是在String的API里面找，所有encoding相关的都过滤了一遍，<a id="more"></a>未果（后来证明其实我找对了方向，只是用错了编码参数）；然后决定用自己拿手的方式，读取乱码数值填进数据块中，然后变成字符串。于是去网上搜索怎么填充字符串（顺便吐槽：我这边抽风cocoachina打不开，烦死），发现牵涉到NSData，NSString等等，同时也发现有人提供了一个字符串中文乱码的解决方案（UTF8转GBK）：</p>
<pre><code><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlStr];
<span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url]; 
<span class="built_in">NSStringEncoding</span> enc =  <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(k<span class="built_in">CFStringEncodingGB_18030_2000</span>);
<span class="built_in">NSString</span> *retStr = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:enc];
</code></pre><p>这一段OC又是url又是data的，看得我这个新手晕晕的，_kCFStringEncodingGB_18030_2000_在swift里面又没了，只好去看文档、头文件，试了很久还是没搞定。但这个过程让我又回到最开始的路子上了：找对应的函数，于是很快找到另外一个Swift的方案：</p>
<pre><code>func UTF8ToGB2312(str: <span class="built_in">String</span>) <span class="subst">-&gt; </span>(NSData?, UInt) {
<span class="keyword">let</span> enc              = CFStringConvertEncodingToNSStringEncoding(UInt32(CFStringEncodings<span class="built_in">.</span>GB_18030_2000<span class="built_in">.</span>rawValue))
<span class="keyword">let</span> <span class="built_in">data</span>             = str<span class="built_in">.</span>dataUsingEncoding(enc, allowLossyConversion: <span class="literal">false</span>)    
<span class="keyword">return</span> (<span class="built_in">data</span>, enc)
}
<span class="keyword">let</span> (<span class="built_in">data</span>, enc)      = UTF8ToGB2312(<span class="string">"123中文"</span>)
NSString(<span class="built_in">data</span>: <span class="built_in">data</span><span class="subst">!</span>, encoding: enc)<span class="subst">!</span>
</code></pre><p>说实话这个也没有用啊！逻辑上是这个意思，但事实上input什么样output还是什么样！纠缠于GB_18030这么久却一无所获，我开始怀疑是Swift语法更新导致的差异了……（没有根据胡说而已）<br>好在几经胡乱努力，我终于找到了正确的API：</p>
<pre><code><span class="function"><span class="keyword">func</span> <span class="title">addEncoding</span><span class="params">(st : String )</span> -&gt;<span class="title">String</span>? {</span>
    <span class="keyword">if</span> <span class="preprocessor">#available(iOS 7.0, OSX 10.9, *) {</span>
        <span class="keyword">return</span> st.stringByAddingPercentEncodingWithAllowedCharacters(.URLHostAllowedCharacterSet())
    }
    <span class="keyword">else</span> {
        <span class="keyword">return</span>  st.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)
    }
}


<span class="function"><span class="keyword">func</span> <span class="title">rmEncoding</span><span class="params">(st : String )</span> -&gt;<span class="title">String</span>? {</span>
    <span class="keyword">if</span> <span class="preprocessor">#available(iOS 7.0, OSX 10.9, *) {</span>
        <span class="keyword">return</span>  st.stringByRemovingPercentEncoding
    }
    <span class="keyword">else</span> {
    <span class="keyword">return</span> st.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding)
    }
}
</code></pre><p>其中stringByAdding(Replacing)PercentEncodingWithAllowedCharacters已经失效，iOS7以上使用两个替代品。如果说把重新编码看成是某种操作的话，上面的两个函数就是对字符串叠加和消除这种操作。经过测试，效果如下：</p>
<pre><code>let s1 = <span class="string">"王"</span><span class="comment">// 中文字符串：王</span>
let s2 = <span class="function"><span class="title">addEncoding</span><span class="params">(s1)</span></span>!   <span class="comment">// UTF8重编码后：%E7%8E%8B</span>
let s3 = <span class="function"><span class="title">addEncoding</span><span class="params">(s2)</span></span>!   <span class="comment">// 补全%25(即为空字符)后：%25E7%258E%258B</span>
let s4  = <span class="function"><span class="title">addEncoding</span><span class="params">(s3)</span></span>!  <span class="comment">// %2525E7%25258E%25258B</span>

<span class="function"><span class="title">rmEncoding</span><span class="params">(s4)</span></span>  <span class="comment">// %25E7%258E%258B == s3</span>
<span class="function"><span class="title">rmEncoding</span><span class="params">(s3)</span></span>  <span class="comment">// %E7%8E%8B == s2</span>
<span class="function"><span class="title">rmEncoding</span><span class="params">(s2)</span></span>  <span class="comment">// 王 == s1</span>
<span class="function"><span class="title">rmEncoding</span><span class="params">(s1)</span></span>  <span class="comment">// 王 == s1 == self</span>
</code></pre><p>由此可见，（仅对UTF8编码，别的没测过）加减是相反的操作，有点像加壳脱壳的过程。已编码的字符串每继续叠加一次编码，就会用0x25填充每个字符；而有填充码时每remove一次编码就删掉一组填充码，直到最后还原为原始字符串后就不做任何操作了。于是，UTF8的中文编码转换变得很简单：</p>
<pre><code><span class="comment">// 包含中文字符串转成utf8编码</span>
let st               = <span class="string">"www.google.com/测 🙃test/."</span>
let utf8str          = <span class="function"><span class="title">addEncoding</span><span class="params">(st)</span></span>
<span class="comment">// UTF8转成中文</span>
<span class="function"><span class="title">rmEncoding</span><span class="params">(utf8str!)</span></span>
</code></pre><p>至此，事情基本解决了，不过我还没有忘记最开始“手动填充数据的”梦想……😎正好在之前的研究过程中对String,NSData这些也有了一些了解，于是自己动手写了个相同功能的UTF8转中文，顺便练习String，还特意去用String中的Range：</p>
<pre><code>func stConvert(var st: String) -&gt;String{
var byte :[UInt8]    = []
let start            = st.startIndex
var range: Range?    = Range(start: start, end: start)

<span class="keyword">while</span> !st.isEmpty {
    range                = String(st.characters.dropFirst()).rangeOfString(<span class="string">"<span class="variable">%"</span>)
    if (range != nil) {     
        /*still have next "</span><span class="variable">%"</span>
         because the range is <span class="keyword">for</span> dropfirst, the endIndex is the the true endof <span class="keyword">no</span> % *<span class="regexp">/
        range!.startIndex    = start
    }
    else {  /</span>*<span class="keyword">no</span> <span class="string">"<span class="variable">%"</span> any more */
        range                = Range(start:start, end:st.endIndex)
    }
    if st.hasPrefix("</span><span class="variable">%"</span>){
        var res:UInt32       = <span class="number">0</span>
        range!.endIndex      = range!.startIndex.advancedBy(<span class="number">3</span>)
        var temp             = st.substringWithRange(range!)
        temp                 = temp.stringByReplacingOccurrencesOfString(<span class="string">"<span class="variable">%"</span>, withString: "</span>0x<span class="string">")
        NSScanner.localizedScannerWithString(temp).scanHexInt(&amp;res)
        byte.append(UInt8(res))
    }
    else {
        let temp :NSString   = st.substringWithRange(range!)
        for i in 0..&lt;temp.lengthOfBytesUsingEncoding(NSUTF8StringEncoding) {
            byte.append(UInt8(temp.UTF8String[i]))
        }

    }
    st.removeRange(range!)
}

let data             = NSData(bytes: byte, length: byte.count)
return String(data: data, encoding: NSUTF8StringEncoding)!
}

stConvert("</span><span class="number">1</span><span class="variable">%2B12</span><span class="variable">%EF</span><span class="variable">%BC</span><span class="variable">%9A</span><span class="variable">%E9</span><span class="variable">%80</span><span class="variable">%9A</span><span class="variable">%E5</span><span class="variable">%90</span><span class="variable">%91</span><span class="variable">%E5</span><span class="variable">%B8</span><span class="variable">%B8</span><span class="variable">%E8</span><span class="variable">%AF</span><span class="variable">%86</span><span class="variable">%E7</span><span class="variable">%9A</span><span class="variable">%84</span><span class="variable">%E9</span><span class="variable">%81</span><span class="variable">%93</span><span class="variable">%E8</span><span class="variable">%B7</span><span class="variable">%AF</span><span class="variable">%20</span><span class="variable">%28</span><span class="variable">%E6</span><span class="variable">%80</span><span class="variable">%9D</span><span class="variable">%E4</span><span class="variable">%BA</span><span class="variable">%AB</span><span class="variable">%E5</span><span class="variable">%AE</span><span class="variable">%B6</span><span class="variable">%E4</span><span class="variable">%B8</span><span class="variable">%9B</span><span class="variable">%E4</span><span class="variable">%B9</span><span class="variable">%A6</span><span class="variable">%29</span><span class="variable">%20</span>-<span class="variable">%20</span><span class="variable">%E5</span><span class="variable">%88</span><span class="variable">%98</span><span class="variable">%E8</span><span class="variable">%8B</span><span class="variable">%8F</span><span class="variable">%E9</span><span class="variable">%87</span><span class="variable">%8C</span><span class="variable">%F0</span><span class="variable">%9F</span><span class="variable">%90</span><span class="variable">%B6</span>.mobi<span class="string">")</span>
</code></pre><p>主要的思路就是找“%”，然后将格式化的十六进制数转换为数值按次序填进NSData中，最后用RawData转换成字符串。考虑到给的字符串可能包含部分不会被重编码的部分（例如数字之类），需要判断一下，这部份字符串就转换成Ascii码填充进去。在做的过程中我碰到了一个很无语的坑：</p>
<blockquote>
<p><strong>Rang获取的范围(start, end)表示的是String的start..\&lt;end，即[start…end-1]部分！string[end]是不包括的！</strong></p>
</blockquote>
<p>我不知道我是不是一个人，虽然文档明明白白写了，但没太注意到，用的时候又想当然了，结果死循环差点把Xcode搞死……😂话说没有找到在字符串中匹配某个字符第一个位置的API，感觉用Range还是蛮不方便的……</p>
<p>其实编码无非是编码和解码，所以String中的转换基本上就这样了。关于不同的编码类型NSStringEncoding，其实是一个UInt32。这里通篇都用的<strong>NSUTF8StringEncoding</strong>，按照文档的描述：</p>
<blockquote>
<p>This type is used to define the constants for the <strong>built-in encodings</strong> (see Built-in String Encodings for a list) and for platform-dependent encodings (see <strong>External String Encodings</strong>). If CFString does not recognize or support the string encoding of a particular string, CFString functions will identify the string’s encoding as kCFStringEncodingInvalidId.</p>
</blockquote>
<p>在Swift中Built-in的编码是有对应的类似_NSXXXXEncoding_可以作为参数直接使用，而External那些则需要申请一个NSStringEncoding类型的变量，按照前面_func UTF8ToGB2312_的方式去赋值使用了。顺手附上<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFStringRef/index.html#//apple_ref/c/tdef/CFStringBuiltInEncodings" target="_blank" rel="external">Build-in</a>和<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFStringRef/index.html#//apple_ref/doc/constant_group/External_String_Encodings" target="_blank" rel="external">Externel</a>编码的列表供查询。<br>OK，编码部分结束！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Swift中的字符串，第四篇，中文字符编码的转换。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages">这里</a>看到</li>
</ul>
<p>不知道是不是Safari的原因，我用浏览器下载中文名文件的时候常常文件名会变成乱码，就是“%EF%77%3D%20”那种，又因为很多是电子书，名称也不能乱改，还需要自己去copy一遍重命名，很烦，于是想到用Swift自己写个函数试试纠正这个乱码。<br>最开始我的想法是在String的API里面找，所有encoding相关的都过滤了一遍，]]>
    
    </summary>
    
      <category term="String" scheme="http://conanwhf.gitcafe.io/tags/String/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift开源了！！！]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/04/Swift_open/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/04/Swift_open/</id>
    <published>2015-12-04T10:29:26.000Z</published>
    <updated>2015-12-04T10:50:36.000Z</updated>
    <content type="html"><![CDATA[<p>这篇都不知道该算吐槽还是开发文章😀。<br>早晨起床一刷新闻，Swift承诺中的开源实现了！想想读书的时候写Pascal玩，进了大学才发现原来这玩意儿早过时了，大学的时候也是东搞西搞像无头苍蝇一样没有方向，偶尔有需要写程序的偏门作业就突击什么vfox, delphi, jsp之类的……等毕业工作半年了才开始学C，后来对着个Android1.2研究了下就觉得一层一层好复杂啊！😥这么些年永远走在潮流之后，什么GitHub是什么鬼从来没用过，学习Swift的过程就跟不断发现新大陆一样感觉信息爆炸性扑面而来，这次突然有一种自己终于跟上了时代的感觉，哈哈！<br>下午跑去Github上观光了一下Swift，手贱Watch了，结果十几分钟来了20封邮件！吓得我赶紧去unwatch，终于懂了为什么star的那么多watch的却很少了。这效率让我有点瞠目结舌：才一天，搭搭环境看看代码结构就差不多了吧，哪里来那么多大神神速找了bug出来还fix了！！膜拜的同时心生自卑：人家是怎么做到的？是我智商低吗？难道说这就是老人被拍死在沙滩上的真实写照……😱<br>看看文档，Swift3.0还要大改，居然都有计划做什么2.0到3.0的迁移器，那多半是改动多得大项目根本无法用人力迁移了。1.2到2.0的改动就够让我晕头转向的了，还没整明白呢，又来，我也真是醉……跟钱同学讨论这个问题，他相当不能理解这种不稳定性，觉得iOS开发者都这么好脾气吗？！其实我一个月前也不能忍，那种随便一找资料就过时、网上几乎所有的sample都编不过又不知道怎么改的感觉太令人抓狂，不过随着慢慢入门，这种感觉就好多了，也知道如何应对。也许对于这种剧烈变动的语言，亦步亦趋比猛插一杠子开干还是要容易吧！<br>最近读了一些文档、文章，感觉自己虽然语法差不多知道了些，思维却还是旧式的。对于那些流行的（或者其实是已经用了很长时间了，只是我不知道）的编程思想和范式，还很陌生。这种思维方式的转变，需要更多的时间来磨练和体会，不求成为大牛，只想做一个不是吃青春饭的工程师。给自己加油！🤗</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇都不知道该算吐槽还是开发文章😀。<br>早晨起床一刷新闻，Swift承诺中的开源实现了！想想读书的时候写Pascal玩，进了大学才发现原来这玩意儿早过时了，大学的时候也是东搞西搞像无头苍蝇一样没有方向，偶尔有需要写程序的偏门作业就突击什么vfox, delphi, j]]>
    </summary>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift2.0 中的String（三）：类型转换]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/</id>
    <published>2015-12-03T07:20:26.000Z</published>
    <updated>2015-12-23T16:22:52.000Z</updated>
    <content type="html"><![CDATA[<p>本系列第三篇，String相关的类型转换。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages" target="_blank" rel="external">这里</a>看到</li>
</ul>
<p>虽然Swift是强类型语言，但简单的String类型转换其实还是比较方便的，最暴力的就是强制类型转换，百试百灵：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">toString</span><span class="generics">&lt;T&gt;</span><span class="params">(a: T)</span></span> -&gt; <span class="type">String</span>{
    <span class="comment">// Way one, format</span>
    <span class="comment">//return "\(a)"</span>
    <span class="comment">// Way two, new string</span>
    <span class="keyword">return</span> <span class="type">String</span>(a)
}
<span class="built_in">toString</span>(<span class="number">123</span>)
<span class="built_in">toString</span>(<span class="number">0.007</span>)
<span class="built_in">toString</span>([<span class="number">4</span>, <span class="number">8</span>, <span class="number">32</span>, <span class="number">5</span> ])
<span class="built_in">toString</span>(<span class="string">"test"</span>.startIndex)
</code></pre><p>同样照葫芦画瓢也能转回来：</p>
<pre><code><span class="function"><span class="title">Int</span><span class="params">(<span class="string">"123"</span>)</span></span>
<span class="function"><span class="title">Float</span><span class="params">(<span class="string">"3.1"</span>)</span></span>
</code></pre><p>但这个太简单、太有局限性了！我最喜欢的是下面这个，利用了New的时候format方法，简直就是<strong>sprintf()</strong>的替代品！ <a id="more"></a></p>
<pre><code><span class="comment">// Way 1, 格式化转String</span>
<span class="function"><span class="title">String</span><span class="params">(format:<span class="string">"%i,  0x%x,  0o%o,  %.2f"</span>, <span class="number">31</span>, <span class="number">31</span>,  <span class="number">31</span>, <span class="number">3.1</span>)</span></span>
<span class="comment">// Way 2</span>
<span class="function"><span class="title">String</span><span class="params">()</span></span>.<span class="function"><span class="title">stringByAppendingFormat</span><span class="params">(<span class="string">"%x"</span>,<span class="number">31</span>)</span></span>
<span class="function"><span class="title">String</span><span class="params">()</span></span>.<span class="function"><span class="title">stringByAppendingFormat</span><span class="params">(<span class="string">"%o"</span>,<span class="number">31</span>)</span></span>
</code></pre><p>同样的，有了sprintf()，怎么能没有<strong>sscanf()</strong>？？</p>
<pre><code><span class="comment">//十六进制String转整数</span>
<span class="tag">var</span> res:UInt32   = <span class="number">0</span>
NSScanner.<span class="function"><span class="title">localizedScannerWithString</span><span class="params">(str)</span></span>.<span class="function"><span class="title">scanHexInt</span><span class="params">(&amp;res)</span></span>
</code></pre><p>当然，这个用起来就要麻烦许多，类似的一堆API:</p>
<pre><code>    NSScanner.<span class="function"><span class="title">localizedScannerWithString</span><span class="params">(str)</span></span>.<span class="function"><span class="title">scanInt</span><span class="params">(&amp;res)</span></span>
    NSScanner.<span class="function"><span class="title">localizedScannerWithString</span><span class="params">(str)</span></span>.<span class="function"><span class="title">scanFloat</span><span class="params">(&amp;res)</span></span>
    NSScanner.<span class="function"><span class="title">localizedScannerWithString</span><span class="params">(str)</span></span>.<span class="function"><span class="title">scanDouble</span><span class="params">(&amp;res)</span></span>
    NSScanner.<span class="function"><span class="title">localizedScannerWithString</span><span class="params">(str)</span></span>.<span class="function"><span class="title">scanInteger</span><span class="params">(&amp;res)</span></span>
NSScanner.<span class="function"><span class="title">localizedScannerWithString</span><span class="params">(str)</span></span>.<span class="function"><span class="title">scanHexFloat</span><span class="params">(&amp;res)</span></span>
</code></pre><p>最后，虽然ASCII码现在不大常用了，但我这种老人家还是很喜欢……写个ASCII码的转换函数吧：</p>
<pre><code><span class="comment">/**
ASCII value to char
*/</span>
<span class="func"><span class="keyword">func</span> <span class="title">ASCII</span> <span class="params">( n : Int)</span></span> -&gt; <span class="type">String</span>? {
    guard (n &gt;= <span class="number">0</span> &amp;&amp; n &lt; <span class="number">255</span> ) <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="literal">nil</span>
    }
<span class="keyword">return</span> <span class="type">String</span>(format:<span class="string">"%c"</span>, n)
}

<span class="comment">/**
ASCII char to int value
*/</span>
<span class="func"><span class="keyword">func</span> <span class="title">ASCII</span> <span class="params">(<span class="built_in">c</span> : String)</span></span> -&gt; <span class="type">Int8</span>?{
    <span class="keyword">let</span> str:<span class="type">NSString</span> = <span class="built_in">c</span>
    <span class="keyword">let</span> n = str.<span class="type">UTF8String</span>[<span class="number">0</span>]
    guard n&gt;=<span class="number">0</span> <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="literal">nil</span>
    }
    <span class="keyword">return</span> n
}

<span class="type">ASCII</span>(<span class="number">70</span>)
<span class="type">ASCII</span>(<span class="string">"B"</span>)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>本系列第三篇，String相关的类型转换。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages">这里</a>看到</li>
</ul>
<p>虽然Swift是强类型语言，但简单的String类型转换其实还是比较方便的，最暴力的就是强制类型转换，百试百灵：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">toString</span><span class="generics">&lt;T&gt;</span><span class="params">(a: T)</span></span> -&gt; <span class="type">String</span>{
    <span class="comment">// Way one, format</span>
    <span class="comment">//return "\(a)"</span>
    <span class="comment">// Way two, new string</span>
    <span class="keyword">return</span> <span class="type">String</span>(a)
}
<span class="built_in">toString</span>(<span class="number">123</span>)
<span class="built_in">toString</span>(<span class="number">0.007</span>)
<span class="built_in">toString</span>([<span class="number">4</span>, <span class="number">8</span>, <span class="number">32</span>, <span class="number">5</span> ])
<span class="built_in">toString</span>(<span class="string">"test"</span>.startIndex)
</code></pre><p>同样照葫芦画瓢也能转回来：</p>
<pre><code><span class="function"><span class="title">Int</span><span class="params">(<span class="string">"123"</span>)</span></span>
<span class="function"><span class="title">Float</span><span class="params">(<span class="string">"3.1"</span>)</span></span>
</code></pre><p>但这个太简单、太有局限性了！我最喜欢的是下面这个，利用了New的时候format方法，简直就是<strong>sprintf()</strong>的替代品！]]>
    
    </summary>
    
      <category term="String" scheme="http://conanwhf.gitcafe.io/tags/String/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift2.0 中的String（二）：基本操作]]></title>
    <link href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/"/>
    <id>http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/</id>
    <published>2015-12-03T07:20:16.000Z</published>
    <updated>2015-12-23T16:22:11.000Z</updated>
    <content type="html"><![CDATA[<p>Swift中的字符串，第二篇，基本操作。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages" target="_blank" rel="external">这里</a>看到</li>
</ul>
<p>首先，我们要记得使用字符串最常用的两个参数：下标(Index)和范围(Range)，几乎所有API都要用到它们</p>
<pre><code><span class="built_in">let</span> <span class="built_in">offset</span> = <span class="built_in">str</span>.startIndex.advancedBy(<span class="number">2</span>)<span class="comment">// offset: 3rd char</span>
<span class="built_in">let</span> range  = Range(start: <span class="built_in">str</span>.startIndex.advancedBy(<span class="number">3</span>), end: <span class="built_in">str</span>.endIndex.advancedBy(-<span class="number">2</span>))<span class="comment">// range: 3..&lt;6, "345"</span>
</code></pre><p><strong>强制类型转换</strong></p>
<pre><code>let n      = <span class="function"><span class="title">Int</span><span class="params">(str)</span></span>!
<span class="function"><span class="title">String</span><span class="params">(<span class="string">"the number is \(n)"</span>)</span></span>
<span class="function"><span class="title">String</span><span class="params">(format:<span class="string">"%.2f,  %i"</span>, <span class="number">9.1</span>, <span class="number">304</span>)</span></span>
</code></pre><p><strong>内容反转</strong><a id="more"></a></p>
<pre><code>String<span class="list">(<span class="keyword">str</span>.characters.reverse<span class="list">()</span>)</span>
</code></pre><p><strong>删除和部分删除</strong></p>
<pre><code>str.<span class="function"><span class="title">removeRange</span><span class="params">(range)</span></span>
str.<span class="function"><span class="title">removeAtIndex</span><span class="params">(offset)</span></span>
<span class="function"><span class="title">String</span><span class="params">(str.characters.dropFirst()</span></span>)
<span class="function"><span class="title">String</span><span class="params">(str.characters.dropFirst(<span class="number">3</span>)</span></span>)
<span class="function"><span class="title">String</span><span class="params">(str.characters.dropLast()</span></span>)
<span class="function"><span class="title">String</span><span class="params">(str.characters.dropLast(<span class="number">3</span>)</span></span>)
<span class="comment">//以上对character的操作不改变原来的值！</span>
<span class="comment">// 删除头尾空白字符</span>
<span class="string">"     I love you "</span>.<span class="function"><span class="title">stringByTrimmingCharactersInSet</span><span class="params">(NSCharacterSet.whitespaceCharacterSet()</span></span>)
<span class="comment">// 删除头尾字符集</span>
<span class="string">" I love you, too!"</span>.<span class="function"><span class="title">stringByTrimmingCharactersInSet</span><span class="params">(NSCharacterSet(charactersInString: <span class="string">",. !"</span>)</span></span>)
<span class="comment">//清空</span>
str.<span class="function"><span class="title">removeAll</span><span class="params">()</span></span>
</code></pre><p><strong>获取固定位置的子串</strong></p>
<pre><code>str.<span class="function"><span class="title">substringToIndex</span><span class="params">(offset)</span></span>
str.<span class="function"><span class="title">substringFromIndex</span><span class="params">(offset)</span></span>
str.<span class="function"><span class="title">substringWithRange</span><span class="params">(range)</span></span>
str[range]
</code></pre><p> <strong>分割</strong></p>
<pre><code>st         = <span class="string">"&lt;123, test2,???&gt;   &lt;测试: 数据  .&gt;"</span>
<span class="comment">// 用固定字符分割</span>
str.<span class="function"><span class="title">componentsSeparatedByString</span><span class="params">(<span class="string">" "</span>)</span></span>
<span class="comment">// 用固定字符集分割</span>
str.<span class="function"><span class="title">componentsSeparatedByCharactersInSet</span><span class="params">(NSCharacterSet(charactersInString: <span class="string">", ."</span>)</span></span>)
</code></pre><p><strong>过滤/查找替换</strong><br>使用替换字符串的API，让替换的目标字符串为空即为过滤</p>
<pre><code><span class="comment">// 替换固定位置子串</span>
str.<span class="function"><span class="title">stringByReplacingCharactersInRange</span><span class="params">(range, withString: <span class="string">"!!!"</span>)</span></span>
<span class="comment">// 查找所有匹配并替换/过滤</span>
str.<span class="function"><span class="title">stringByReplacingOccurrencesOfString</span><span class="params">(<span class="string">"???"</span>, withString: <span class="string">"~"</span>)</span></span>
str.<span class="function"><span class="title">stringByReplacingOccurrencesOfString</span><span class="params">(<span class="string">" "</span>, withString: <span class="string">""</span>, options: NSStringCompareOptions.LiteralSearch, range: nil)</span></span>
<span class="comment">// 过滤字符集合(分割后合并)</span>
let arr    = str.<span class="function"><span class="title">componentsSeparatedByCharactersInSet</span><span class="params">(NSCharacterSet(charactersInString:<span class="string">"-&lt;&gt;"</span>)</span></span>)
arr.<span class="function"><span class="title">joinWithSeparator</span><span class="params">(<span class="string">""</span>)</span></span>
</code></pre><p><strong>合并/拼接</strong></p>
<pre><code>s1 + s2 + s3
str.<span class="function"><span class="title">appendContentsOf</span><span class="params">(<span class="string">"123"</span>)</span></span>
str.<span class="function"><span class="title">stringByAppendingString</span><span class="params">(<span class="string">"000"</span>)</span></span>         <span class="comment">//不改变原值！</span>
str.<span class="function"><span class="title">stringByAppendingFormat</span><span class="params">(<span class="string">"- num %d "</span>, <span class="number">100</span>)</span></span>      <span class="comment">//不改变原值！</span>
<span class="comment">// 以固定字符串为分隔符拼接</span>
[str, str, str].<span class="function"><span class="title">joinWithSeparator</span><span class="params">(<span class="string">"\n"</span>)</span></span>
</code></pre><p><strong>插入</strong></p>
<pre><code>str.insert(<span class="string">" "</span>, atIndex: <span class="built_in">offset</span>)
str.insertContentsOf(<span class="string">" hello"</span>.<span class="keyword">characters</span>, <span class="keyword">at</span>: <span class="built_in">offset</span>)
str.replaceRange(Range( <span class="built_in">start</span>:<span class="built_in">offset</span>, <span class="keyword">end</span>: <span class="built_in">offset</span> ), <span class="operator">with</span>: <span class="string">"???OK!!!"</span>)
</code></pre><p><strong>判断前缀或后缀</strong></p>
<pre><code>str.<span class="function"><span class="title">hasPrefix</span><span class="params">(<span class="string">"01"</span>)</span></span>
str.<span class="function"><span class="title">hasSuffix</span><span class="params">(<span class="string">"567"</span>)</span></span>
</code></pre><p><strong>比较字符串</strong></p>
<pre><code>s1<span class="class">.characters</span><span class="class">.elementsEqual</span>(s2.characters)
str<span class="class">.characters</span><span class="class">.elementsEqual</span>(<span class="string">"01234567"</span>.characters)
s1 == s2
<span class="string">"111"</span> &lt; <span class="string">"222"</span>
</code></pre><p><strong>匹配字符串</strong></p>
<pre><code>str.<span class="function"><span class="title">rangeOfString</span><span class="params">(<span class="string">"efg"</span>)</span></span>
str.<span class="function"><span class="title">rangeOfString</span><span class="params">(<span class="string">"efg"</span>, options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil)</span></span>
</code></pre><p><strong>固定位置的部分替换</strong></p>
<pre><code>str.<span class="function"><span class="title">replaceRange</span><span class="params">(range, with: <span class="string">"test_for_replace"</span>)</span></span>
str.<span class="function"><span class="title">stringByReplacingCharactersInRange</span><span class="params">(range, withString: <span class="string">"哈哈😄Tes\nt"</span>)</span></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Swift中的字符串，第二篇，基本操作。其他的几篇传送门：</p>
<ul>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_1/" title="Swift2.0 中的String（一）：常用属性">Swift2.0 中的String（一）：常用属性</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_2/" title="Swift2.0 中的String（二）：基本操作">Swift2.0 中的String（二）：基本操作</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/03/Swift_String_3/" title="Swift2.0 中的String（三）：类型转换">Swift2.0 中的String（三）：类型转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_4/" title="Swift2.0 中的String（四）：编码转换">Swift2.0 中的String（四）：编码转换</a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/08/Swift_String_5/" title="Swift2.0 中的String（五）：String和NS-XXX系列的互相转换">Swift2.0 中的String（五）：String和NS-XXX系列的互相转换 </a></li>
<li><a href="http://conanwhf.gitcafe.io/2015/12/09/Swift_String_6/" title="Swift2.0 中的String（六）：正则匹配">Swift2.0 中的String（六）：正则匹配</a><br>我的关于String练习源代码可以在<a href="https://github.com/conanwhf/swiftplayground/tree/master/String.playground/Pages">这里</a>看到</li>
</ul>
<p>首先，我们要记得使用字符串最常用的两个参数：下标(Index)和范围(Range)，几乎所有API都要用到它们</p>
<pre><code><span class="built_in">let</span> <span class="built_in">offset</span> = <span class="built_in">str</span>.startIndex.advancedBy(<span class="number">2</span>)<span class="comment">// offset: 3rd char</span>
<span class="built_in">let</span> range  = Range(start: <span class="built_in">str</span>.startIndex.advancedBy(<span class="number">3</span>), end: <span class="built_in">str</span>.endIndex.advancedBy(-<span class="number">2</span>))<span class="comment">// range: 3..&lt;6, "345"</span>
</code></pre><p><strong>强制类型转换</strong></p>
<pre><code>let n      = <span class="function"><span class="title">Int</span><span class="params">(str)</span></span>!
<span class="function"><span class="title">String</span><span class="params">(<span class="string">"the number is \(n)"</span>)</span></span>
<span class="function"><span class="title">String</span><span class="params">(format:<span class="string">"%.2f,  %i"</span>, <span class="number">9.1</span>, <span class="number">304</span>)</span></span>
</code></pre><p><strong>内容反转</strong>]]>
    
    </summary>
    
      <category term="String" scheme="http://conanwhf.gitcafe.io/tags/String/"/>
    
      <category term="Swift" scheme="http://conanwhf.gitcafe.io/categories/Swift/"/>
    
  </entry>
  
</feed>
